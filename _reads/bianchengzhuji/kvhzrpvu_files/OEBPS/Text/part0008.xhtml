<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>第二部分 性能</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc54">第二部分 性能</a>
</h1>
<p class="content">一个简单而又功能强大的程序，令用户欣喜而又不令开发者烦恼，这正是程序员的终极目标，也是本书前面5章讨论的重点。</p>
<p class="content">现在我们将注意力转向令人欣喜的程序的一个具体的方面：效率。低效率的程序令其用户沮丧：等候很长的时间并因此失去许多机会。因此，下面的几章讨论提高程序性能的几种不同的途径。</p>
<p class="content">第6章总结多种方法及其相互作用。随后的3章按照通常的次序讨论了3种改善运行时间的方法：</p>
<p class="content">第7章论述在设计过程的早期阶段如何使用“粗略估算”来确保基本的系统结构具有足够的效率。</p>
<p class="content">第8章讨论算法设计技术，有时候这些技术可以显著减少模块的运行时间。</p>
<p class="content">第9章讨论代码调优，这一步通常在系统实现的后期完成。</p>
<p class="content">在第二部分的最后，我们用第10章讨论程序性能的另一个重要方面：空间效率。</p>
<p class="content">研究程序的效率有3个很充足的理由。首先是其在许多应用中固有的重要性。我敢打赌，本书的每一个读者都曾经失望地盯着监视器，迫切希望程序运行得更快一些。我认识的一个软件经理估计她有一半的开发预算用于提高程序的性能。许多程序有严格的时间要求，包括实时程序、大型数据库系统和交互式软件。</p>
<p class="content">研究程序性能的第二个原因是教学意义。除了实际好处之外，效率是很好的训练手段。这些章节覆盖了从算法理论到常识性技术（如“粗略估算”）的各种思想。主旨在于训练思维的活跃性；这在第6章体现得尤其明显，该章鼓励我们从许多不同的视角来考虑同一个问题。</p>
<p class="content">通过其他许多主题也能学到类似的东西。这些章也可以围绕用户界面、系统健壮性或安全性展开讨论。效率的一个优点是可以度量：例如，我们中的每个人都会认可一个程序的运行速度是另一个程序的2.5倍，但是当讨论用户界面时，则常常会陷入个人喜好之争。</p>
<p class="content">研究程序性能的最重要的原因用1986年的电影《壮志凌云》（Top Gun）中的一句经典台词来描述最为恰当：“I feel the need...the need for speed!”（“我感觉到了需要……对速度的需要！”）</p>
<p class="content_1">本部分内容</p>
<p class="content_">第6章 程序性能分析</p>
<p class="content_">第7章 粗略估算</p>
<p class="content_">第8章 算法设计技术</p>
<p class="content_">第9章 代码调优</p>
<p class="content_">第10章 节省空间</p>
<h2 class="secondtitle" id="bw46">
<a href="part0000.xhtml#toc55">第6章 程序性能分析</a>
</h2>
<p class="content">本章后面的三章描述了提高运行时效率的三种不同方法。在本章中，我们将会看到这些方法如何组合成一个整体：每种技术应用于构建计算机系统的几个设计层面之一。我们首先研究一个特定的程序，然后采用更加系统化的观点来看待系统设计的各个层面。</p>
<h3 class="thirdtitle" id="bw47">
<a href="part0000.xhtml#toc56">6.1 实例研究</a>
</h3>
<p class="content">1985年1月，SIAM Journal on Scientific and Statistical Computing第6卷第1期的第85页～第103页上刊登了Andrew Appel<span id="ref27">
<a href="part0008.xhtml#annot27">[1]</a>
</span>
 的文章“An efficient program for many-body simulations”。通过在几个不同的层面上进行改进，Andrew Appel将程序的运行时间从一年缩短为一天。</p>
<p class="content">该程序解决了计算重力场中多个物体相互作用的经典“n体问题”。给定物体的质量、初始位置和速度，该程序可以对三维空间中n个物体的运动进行仿真。想象一下，这些物体可以是行星、恒星或星系。在二维空间中，输入可能类似于下图：Appel的论文讨论了n＝10 000时的两个天体物理学问题。通过研究仿真运行，物理学家可以测试理论与天文观测的吻合程度。（若要了解该问题的更多细节和基于Appel方法的后续解决方案，参见Pfalzner和Gibbon的Many-Body Tree Methods in Physics一书，该书由剑桥大学出版社于1996年出版。）</p>
<div class="bodypic_"><img alt="" src="../Images/image00198.jpeg" class="calibre3"/>
</div>
<p class="content">显而易见的仿真程序将时间划分成小“步”，并计算每个物体在每一步的移动情况。由于程序需要计算每个物体对其他每一个物体的吸引力，每一时间步的开销正比于n<span class="super">2</span>
 。Appel估算出当n=10 000时，该算法在他的计算机上运行1 000个时间步大约需要一年的时间。</p>
<p class="content">Appel最终的程序在不到一天的时间内就解决了该问题（加速系数为400）。从那以后，许多物理学家都采用了他的技术。下面简要总结一下他的程序，我们忽略的许多重要细节可以在他的论文中找到。该方法所传达出的重要信息是，可以通过在几个不同层面上的改进，来获得巨大的加速。</p>
<p class="content">算法和数据结构。Appel 首先考虑要选择一个高效的算法。通过把物体表示为二叉树的叶结点，他将每个时间步 O(n<span class="super">2</span>
 )的开销减少为 O(n log n)<span id="ref28">
<a href="part0008.xhtml#annot28">[2]</a>
</span>
 。更高层的结点为物体簇。作用于特定物体上的力可以使用大物体簇所施加的力来近似，Appel 证明了这样的近似不会影响仿真的正确性。该二叉树有大约log n层，最终的O(n log n)算法与8.3节讨论的分治算法在思想上是相似的。Appel的这一改进使得程序的运行时间缩短为原来的十二分之一。</p>
<p class="content">算法调优。这一简单的算法总是使用小时间步处理两个粒子相互接近的罕见情况。树数据结构允许我们用一个特殊的函数来识别并处理这样的粒子对。这样就使得时间步加倍，从而使程序的运行时间减半。</p>
<p class="content">数据结构重组。如果用表示初始物体集合的树来表示后续的集合，效果会很差。在每个时间步对数据结构进行重新配置，仅需要花费很少的时间，却可以减少局部计算的次数，从而使总的运行时间减半。</p>
<p class="content">代码调优。由于树数据结构提供了额外的数值精度，64位的双精度浮点数可以用32位单精度浮点数代替；这一改变使得运行时间减半。对程序的性能监视表明，98%的运行时间都花在一个函数上；使用汇编语言重新编写该函数，可以将运行速度提升为原来的2.5倍。</p>
<p class="content">硬件。在经过上述所有改进之后，程序在价值 25 万美元的部门机器上运行仍需要两天的时间，而且该程序需要运行好几次。于是，Appel 将程序转移到一个稍贵一些的、装配有加速器的机器上运行，这使得运行时间再次减半。</p>
<p class="content">上面描述的所有改进累积起来就得到了总的加速系数 400。Appel 最终的程序完成10 000个物体的仿真需要大约一天的时间。但是，加速是有代价的。简单的算法也许只要几十行代码就可以实现了，而快速程序则需要1 200行代码。Appel花了几个月的时间才完成了该快速程序的设计和实现。加速的情况汇总在下表中。</p>
<div class="pic_"><img alt="" src="../Images/image00199.jpeg" class="calibre3"/>
</div>
<p class="content">该表格说明了各种加速之间的几种依赖关系。最主要的加速是使用树数据结构，它是后续三个改进的前提条件。最后的两个加速（使用汇编语言和使用浮点加速器）在本例中与树数据结构无关。树数据结构对超级计算机的运行时间影响较小（超级计算机的管道体系结构非常适合原先的简单算法）；算法加速并不是一定要独立于硬件的。</p>
<h3 class="thirdtitle" id="bw48">
<a href="part0000.xhtml#toc57">6.2 设计层面</a>
</h3>
<p class="content">一个计算机系统可以在很多层面上进行设计：从高层的软件结构一直深入到硬件中的晶体管。下面的总结是对设计层面的直观导引，请不要将其看作正式的分类。<span id="ref29">
<a href="part0008.xhtml#annot29">[3]</a>
</span>
</p>
<p class="content">问题定义。追求快速系统，可能在定义该系统需要解决的问题时就已经注定成败了。在我写这一段文章的那天，一个供货商告诉我他无法供货，因为采购单在本部门和本公司采购部之间的某个环节弄丢了。大量类似的采购单导致采购完全无法进行，因为本部门中有 50 个人都各自下了单。在部门管理人员和公司的采购部进行了友好协商以后，50份采购单被合并成一份大采购单。这样不仅使得两个部门的管理工作得以简化，也使得计算机系统某一部分的运行速度变成了原来的 50 倍。优秀的系统分析员应该时刻留意此类改进，无论在系统部署之前还是之后。</p>
<p class="content">有时候，良好的问题定义可以避免用户对问题需求的过高估计。第1章介绍了如何在排序程序中通过把一些关于输入的重要事实考虑进来，从而使运行时间和程序长度都减少一个数量级。问题定义和程序效率之间具有复杂的相互影响。例如，良好的错误恢复能力会使编译器运行得稍慢一些，但是通常会由于减少了总的编译次数而缩短总的时间。</p>
<p class="content">系统结构。将大型系统分解成模块，也许是决定其性能的最重要的单个因素。在构建出整个系统的框架以后，设计者需要完成简单的“粗略估算”（将在第7章讨论），以确保程序的性能在正确的范围之内。由于提高新系统的效率比改进已有系统的效率要容易得多，所以，性能分析在系统设计阶段至关重要。</p>
<p class="content">算法和数据结构。获得快速模块的关键通常是表示数据的结构和操作这些数据的算法。Appel程序的最大改进就是用O(n log n)算法取代了O(n<span class="super">2</span>
 )算法。第2章和第8章讨论了相似的加速方法。</p>
<p class="content">代码调优。Appel对代码做了一些小改进，就获得了5倍的加速。第9章专门讨论这个问题。</p>
<p class="content">系统软件。有时候改变系统所基于的软件比改变系统本身更容易。对于系统中的查询操作，新的数据库系统是否更快？对于当前任务的实时性限制，另一个操作系统是否更合适？所有可能的编译器优化都启用了吗？</p>
<p class="content">硬件。更快的硬件可以提高系统的性能。通用计算机通常都足够快了，可以通过在同一处理器或多处理器上提高时钟速度来实现加速。声卡、显卡和其他的卡将中央处理器的工作转移到小型的、快速的专用处理器上，游戏设计者特别善于使用这些设备来实现巧妙的加速。例如，专用的数字信号处理器（DSP）可以使廉价的玩具和家用电器能与人交流。Appel 给现有机器添加浮点加速器的解决方案是这两个极端方法的一个折中。</p>
<h3 class="thirdtitle" id="bw49">
<a href="part0000.xhtml#toc58">6.3 原理</a>
</h3>
<p class="content">由于预防远胜于治疗，我们应当牢记Gordon Bell<span id="ref30">
<a href="part0008.xhtml#annot30">[4]</a>
</span>
 在为DEC公司设计计算机时所观察到的事实：</p>
<p class="content">计算机系统中最廉价、最快速且最可靠的元件是根本不存在的。</p>
<p class="content">这些缺失的元件同时也是最精确（从不出错）、最安全（无法入侵）且最容易设计、文档化、测试和维护的。简单设计的重要性怎么强调都不过分。</p>
<p class="content">当程序性能问题无法回避时，考虑设计层面会有助于程序员集中精力解决问题。</p>
<p class="content">如果仅需要较小的加速，就对效果最佳的层面做改进。对于效率，大多数程序员都有自己的下意识反应：“改变算法”或“调整排队规则”会脱口而出。决定在某一特定层面着手之前，请先考虑一下所有可能的设计层面，然后选择“性价比”最高的那一个：投入最小的精力就可以获得最大加速系数的那个设计层面。</p>
<p class="content">如果需要较大的加速，就对多个层面做改进。要取得Appel那样的大幅加速，必须从各个不同的方向对问题进行深入研究，这通常需要付出巨大的努力。如果在任一设计层面上的改进都独立于其他层面的改进，那么各个层面上的加速系数可以相乘。</p>
<p class="content">第7章、第8章和第9章讨论了在3个不同设计层面上的加速，在考虑各个独立的加速时要有全局观念。</p>
<h3 class="thirdtitle" id="bw50">
<a href="part0000.xhtml#toc59">6.4 习题</a>
</h3>
<p class="content">1.假设现在的计算机比Appel做实验时所用的计算机快1 000倍。如果使用相同的总计算时间（大约一天），对于O(n<span class="super">2</span>
 )算法和O(n log n)算法，问题的规模n分别增加到多少？</p>
<p class="content">2.在各个不同的设计层面讨论下列问题的加速：对 500 位的整数进行因子分解、傅立叶分析、模拟VLSI电路、在大文本文件中搜索给定字符串。讨论各个加速方法之间的依赖性。</p>
<p class="content">3.Appel发现，将双精度运算改为单精度运算，可以令他的程序运行速度加倍。选择一个合适的测试，在你的计算机系统中度量这种加速效果。</p>
<p class="content">4.本章集中讨论了运行时效率。程序性能的其他常见度量包括容错性、可靠性、安全性、开销、开销/性能、精度以及对用户错误的健壮性。讨论如何在几个不同的设计层面上对这些问题进行改进。</p>
<p class="content">5.讨论在不同的设计层面上使用最新技术所需的开销。要求包括所有可度量的开销：开发时间（人月）、可维护性和费用。</p>
<p class="content">6.有这样一句流传很久的谚语：“效率永远排在正确性后面——如果程序的运行结果是错误的，速度再快也没有用。”这句话正确吗？</p>
<p class="content">7.讨论如何从不同的层面处理日常生活中的问题，如交通事故导致的受伤。</p>
<h3 class="thirdtitle" id="bw51">
<a href="part0000.xhtml#toc60">6.5 深入阅读</a>
</h3>
<p class="content">Butler Lampson<span id="ref31">
<a href="part0008.xhtml#annot31">[5]</a>
</span>
 的“Hints for Computer System Design”一文发表在1984年1月1日的IEEE Software 1上。其中的许多提示都是关于性能的。他的论文特别适合于集成硬件和软件的计算机系统设计。在本书行将出版之际，www.research.microsoft.com/~lampson/上提供了这篇论文的副本。</p>
<h2 class="secondtitle" id="bw52">
<a href="part0000.xhtml#toc61">第7章 粗略估算</a>
</h2>
<p class="content">在一次关于软件工程的有趣讨论中，Bob Martin<span id="ref32">
<a href="part0008.xhtml#annot32">[6]</a>
</span>
 突然问我：“密西西比河一天流出多少水？”因为在这之前我正洗耳恭听他的真知灼见，所以，我有礼貌地止住自己的惊讶说：“请再说一遍。”当他重复这个问题的时候，我意识到自己别无选择，只有迁就一下这个可怜的家伙。很明显他已经在经营大型软件企业的巨大压力下崩溃了。</p>
<p class="content">我的回答大致如下。我估算出河的出口大约有1英里（1英里=1.609公里）宽和可能20英尺（1英尺=0.305米）深（即1/250英里）。我猜测河水的流速是每小时5英里，或者说每天120英里。由乘式</p>
<p class="content_">1英里×1/250英里×120英里/天 ≈ 1/2英里 <span class="super">3</span>
 /天</p>
<p class="content">可知，密西西比河每天大约流出半立方英里水，误差在一个数量级之内。但是这又能说明什么呢？</p>
<p class="content">这时候，Martin从桌子上拿起一份他的公司为夏季奥林匹克运动会构建的通信系统提案，并进行了一系列类似的计算。在我们谈话的时候，他通过度量给自己发送一封单字符邮件所需要的时间，估算出了一个关键参数，其他的数则都是直接取自提案，因此相当精确。他的计算与上面有关密西西比河的计算一样简单，但更能说明问题。计算显示，即使在宽松的假设下，提案中的系统也只有在每分钟至少有120秒的情况下才能正常运转。前一天他已经将该设计驳回重做了。（这次对话大约发生在奥林匹克运动会开幕前一年，最终的系统在奥林匹克运动会中运行得很好，没有出现任何故障。）</p>
<p class="content">这就是Bob Martin引入“粗略估算”这一工程技术的神奇方式（或许有点古怪）。“粗略估算”在工程院校中是标准课程，对多数从业工程师来说则是谋生的必备技能。遗憾的是，在实际计算中该方法往往被忽略。</p>
<h3 class="thirdtitle" id="bw53">
<a href="part0000.xhtml#toc62">7.1 基本技巧</a>
</h3>
<p class="content">下面这些提示在进行粗略估算时很有用。</p>
<p class="content">两个答案比一个答案好。当我问 Peter Weinberger<span id="ref33">
<a href="part0008.xhtml#annot33">[7]</a>
</span>
 密西西比河每天流出多少水时，他回答：“与流入的一样多。”随后，他估算出密西西比流域的面积大约为1 000英里×1 000英里，每年的降雨径流量大约为1英尺（或者说1/5 000英里）。于是可以得到如下等式：</p>
<p class="content_">1 000英里×1 000英里×1/5 000英里/年≈200英里 <span class="super">3</span>
 /年</p>
<p class="content_">200英里 <span class="super">3</span>
 /年/400天/年≈1/2英里 <span class="super">3</span>
 /天</p>
<p class="content">或者说每天半立方英里多一点。仔细检查所有的计算是很重要的，对于快速估算尤其如此。</p>
<p class="content">我们来做一个三重检验吧。某年鉴记载，密西西比河每秒的排水量是640 000立方英尺。从该数据出发有如下计算：</p>
<p class="content_">640 000英尺 <span class="super">3</span>
 /秒×3 600秒/小时≈2.3×10<span class="super">9</span>
 英尺 <span class="super">3</span>
 /小时</p>
<p class="content_">2.3×10<span class="super">9</span>
 英尺 <span class="super">3</span>
 /小时×24小时/天≈6×10<span class="super">10</span>
 英尺 <span class="super">3</span>
 /天</p>
<p class="content">6×10<span class="super">10</span>
 英尺 <span class="super">3</span>
 /天/（5 000英尺/英里）<span class="super">3</span>
 ≈6×10<span class="super">10</span>
 英尺 <span class="super">3</span>
 /天/（125×10<span class="super">9</span>
 英尺 <span class="super">3</span>
 /英里 <span class="super">3</span>
 ）</p>
<p class="content_12">≈60/125英里 <span class="super">3</span>
 /天</p>
<p class="content_12">≈1/2 英里 <span class="super">3</span>
 /天</p>
<p class="content">两次估算的结果很接近，而且都与根据年鉴得到的计算结果很接近，这真是够巧的。</p>
<p class="content">快速检验。Polya在他的How to Solve It一书中用了3页篇幅讨论“量纲检验”。他将该方法描述为一种“检验几何或物理等式的快速而有效的著名方法”。第一个法则是和式中各项的量纲必须相同，这个量纲同时也是最终求和结果的量纲——可以把英尺相加得到英尺，但是不能把秒和磅相加。第二个法则是乘积的量纲是各乘数量纲的乘积。上面的例子同时遵循这两条法则；如果不考虑常数，以下乘式具有正确的形式：</p>
<p class="content_">（英里＋英里）×英里×英里/天=英里 <span class="super">3</span>
 /天</p>
<p class="content">对于跟上面类似的复杂表达式，一个简单的表格可以帮助我们明了其量纲。要进行Weinberger的计算，首先列出3个原始的因数。</p>
<div class="bodypic_"><img alt="1 000英里 1 000英里 1英里5000年" src="../Images/image00200.jpeg" class="calibre3"/>
</div>
<p class="content">接下来通过约分简化表达式，得到运算的结果200英里3/年。</p>
<div class="bodypic_"><img alt="" src="../Images/image00201.jpeg" class="calibre3"/>
</div>
<p class="content">然后除以（近似的）常数400天/年。</p>
<div class="bodypic_"><img alt="" src="../Images/image00202.jpeg" class="calibre3"/>
</div>
<p class="content">再次约分就得到了熟悉的结果：每天半立方英里。</p>
<div class="bodypic_"><img alt="" src="../Images/image00203.jpeg" class="calibre3"/>
</div>
<p class="content">这样的列表计算可以使量纲一目了然。</p>
<p class="content">量纲检验检验的是等式的形式。对于乘除法，可以使用计算尺时代的一种古老方法来检验：分别计算第一个数位和指数。对于加法，可以进行多种快速检验。</p>
<div class="bodypic_"><img alt="983+1123 2718 3142 6982+1123 2718 3142 6973+1123 2718 3142" src="../Images/image00204.jpeg" class="calibre3"/>
</div>
<p class="content">第一个和的数位过少，而第二个和在最低有效位出错了。“舍九法”揭示出了第三个例子中的错误：三个加数的数字总和对9取模得8，而和数的数字总和对9取模得7。在正确的加法中，加数的数字总和与和数的数字总和模9相等。</p>
<p class="content">最重要的是，不要忘记常识性的东西：要对诸如密西西比河每天流出450升水之类的计算表示怀疑。</p>
<p class="content">经验法则。我最初是在一节会计课上了解到“72法则”的。假设以年利率r%投资一笔钱y年，金融版本的“72法则”指出，如果r×y＝72，那么你的投资差不多会翻倍。该近似相当精确：以年利率6%投资1 000美元12年，可得到2 012美元；以年利率8%投资1 000美元9年，可得到1999美元。</p>
<p class="content">72法则用于估算指数过程的增长非常便利。如果一个盘子里的菌群以每小时3%的速率增长，那么其数量每天都会翻倍。翻倍使程序员回忆起了熟悉的经验法则：由于2<span class="super">10</span>
 ＝1 024，10次翻倍大约是1 000倍，20次翻倍大约是100万倍，30次翻倍大约是10亿倍。</p>
<p class="content">假设一个指数程序解决规模为n＝40的问题需要10秒的时间，并且n每增加1运行时间就增加12%（我们也许可以通过在对数坐标纸上描点的方法来知道这一点）。72法则告诉我们，n每增加6，运行时间就加倍。或者，n每增加60，运行时间就增加为原来的1 000倍。于是，当n＝100时，程序将运行10 000秒，或者说几个小时。但是当n增加到160时，运行时间增加到10<span class="super">7</span>
 秒是什么概念呢？这到底是多长时间？</p>
<p class="content">你可能会觉得难以记住一年有3.155×10<span class="super">7</span>
 秒。而另一方面，要忘记Tom Duff的便捷经验法则也很不容易：在误差不超过千分之五的情况下，</p>
<p class="content">π秒就是一个纳世纪。<span id="ref34">
<a href="part0008.xhtml#annot34">[8]</a>
</span>
</p>
<p class="content">由于指数程序需要运行10<span class="super">7</span>
 秒，所以我们应该做好等上大约4个月时间的准备。</p>
<p class="content">实践。与其他许多活动一样，估算技巧只能通过实践来提高。尝试本章末尾的习题以及附录B中的估算测试（我曾经做过一个类似的测试，该测试给我上了非常必要的一课，使我学会了谦虚地看待自己的估算能力）。7.8节讨论了日常生活中的速算。多数工作场合都提供了大量的快速估算机会。某只箱子中包装用的发泡塑料球有多少个？在你的公司中人们每天需要花多少时间来排队等候上午茶、午餐、影印机或者其他类似的东西？这些时间又消耗公司多少薪水？下次你在午餐桌边百无聊赖的时候，可以问问你的同事密西西比河每天流出多少水。</p>
<h3 class="thirdtitle" id="bw54">
<a href="part0000.xhtml#toc63">7.2 性能估计</a>
</h3>
<p class="content">现在来看一个速算的例子。数据结构（链表或散列表等）中的结点中存储着一个整数和一个指向另一结点的指针。</p>
<p class="content">struct node { int i; struct node *p; };</p>
<p class="content">请粗略估算：两百万个这样的结点是否可以装入128 MB内存的计算机中？</p>
<p class="content">查看系统性能监视器可知，我机器上的128 MB内存通常只有85 MB空闲。（我通过运行第2章的向量旋转程序并观察何时因内存不够用而开始使用磁盘来验证了这一点。）但是一个结点占用多少内存呢？在过去的16位机时代，一个指针和一个整数共占用4字节；在我编写这本书的时候，32位的整数和指针已经非常普遍，因此我预计答案是8字节；有时我还会在64位模式下编译程序，所以还有可能占用16字节。我们可以使用如下的一行C语句来找出在任何特定系统中占用的字节数。</p>
<p class="content">printf("sizeof(struct node)=%d\n",sizeof(struct node));</p>
<p class="content">正如我预计的一样，我的系统中每条记录占用8个字节。两百万个结点总共只需要16 MB的空间，很轻松地就可以装入85 MB的空闲内存中。</p>
<p class="content">但是，当我使用两百万条这样的8字节记录时，为什么机器上的128 MB内存会像疯了一样不够用呢？问题的关键是我使用了C语言中的malloc函数（类似于C++中的new运算符）来为这些记录动态分配空间。我曾假定那些8字节的记录都额外占用了8字节的空间，因此所有这些结点预计共需要约32 MB的空间。事实上每个结点多占用了40字节的空间，于是每条记录就占用了48个字节。这样一来，两百万条记录就需要使用总计96 MB的空间。（但是在其他系统和编译器上，每条记录仅多占用8字节。）</p>
<p class="content">附录C描述了一个用于探测常用数据结构空间开销的程序。该程序输出的第一部分由sizeof操作符构成：</p>
<p class="content">sizeof(char)=1　　 sizeof(short)=2　　　　 sizeof(int)=4</p>
<p class="content">sizeof(float)=4　　sizeof(struct *)=4　　　sizeof(long)=4</p>
<p class="content">sizeof(double)=8</p>
<p class="content">我在自己的 32 位编译器上也精确地估计出了这些值。进一步的实验度量出了由存储分配器返回的连续指针之间的差别，这一差别是对记录大小的一种看似合理的猜测。（还应该使用其他的工具来验证这一粗略的猜测。）现在我明白了，如果使用这种耗费空间的分配器，1~12字节的记录需要消耗48字节的内存空间，13~28字节的记录需要消耗64字节的内存空间，依此类推。我们将在第10章和第13章中再次讨论这个空间模型。</p>
<p class="content">下面再做一个速算的测验。已知某数值算法的运行时间主要取决于其n<span class="super">3</span>
 次的开方运算，这里n=1 000。大约需要多长时间才能完成10亿次开方运算呢？</p>
<p class="content">为了在我自己的系统中得到答案，我从下面的简单C程序开始：</p>
<p class="content">#include &lt;math.h&gt;</p>
<p class="content">int main(void)</p>
<p class="content">{ int i,n = 1000000;</p>
<p class="content_4">float fa;</p>
<p class="content_4">for (i = 0; i &lt; n; i++)</p>
<p class="content_5">fa = sqrt(10.0);</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">我运行该程序，并用一条命令来报告其运行时间。（我在计算机旁边放了一块旧电子表来检验该运行时间。电子表的表带坏了，但是具有秒表功能。）我发现程序进行百万次开方运算大约需要0.2秒，进行千万次开方运算大约需要2秒，进行亿次开方运算大约需要20秒；由此推断进行10亿次开方运算大约需要200秒的时间。</p>
<p class="content">但是在实际的程序中，一次开方运算真的需要200纳秒吗？实际的程序可能会慢很多：或许是因为开方函数缓存了最近的参数作为计算的起始值；寄希望于用相同的参数来重复调用一个函数以减少运行时间不太现实。另一方面，实际的程序也可能会快很多：我在编译该程序的时候禁用了优化功能（优化会删除计时循环，进而导致运行时间始终为零）。附录C描述了如何扩展这个小程序，来产生在给定系统上执行基本C运算所需时间开销的整页描述。</p>
<p class="content">网络的速度到底有多快？我键入ping machine-name进行测试。ping本楼的机器需要几毫秒的时间，因此这也代表了启动时间。运气好的时候，我可以在 70 毫秒的时间内ping上美国另一侧海岸的计算机（以光速完成这段往返5 000英里的行程大约需要27毫秒）；运气不好的时候，会在等待1 000毫秒之后出现超时。对大型文件复制时间的度量表明，10 Mbit/s的以太网每秒可以传送1 MB的内容（也就是说，达到了其潜在带宽的80%）；类似地，100 Mbit/s的以太网每秒可以传送10 MB的内容。</p>
<p class="content">可以通过一些小实验来获得关键参数。数据库设计者应当知道读写记录、连接各种表格所需的时间。图形程序员应当知道关键屏幕操作的开销。今天花一点时间来做这些小实验是值得的，因为它们能帮助我们在将来作出明智的决策，从而节省更多的时间。</p>
<h3 class="thirdtitle" id="bw55">
<a href="part0000.xhtml#toc64">7.3 安全系数</a>
</h3>
<p class="content">计算的输入决定了其输出的质量。基于良好的数据，简单的计算也可以得到精确的计算结果，这些计算结果有时候特别有用。Don Knuth曾经编写过一个磁盘排序程序，却发现其运行时间是他预先计算出来的时间的两倍。经过细致的检查，他找出了问题所在：由于一个软件错误，系统中用了一年的那些磁盘的运转速度仅为其额定速度的一半。修正了该错误之后，Knuth 的排序程序的运行速度与预期的一样快了，而且其他与磁盘紧密相关的程序也运行得更快了。</p>
<p class="content">不过，漫不经心的输入常常也可以得到正确的结果。（附录B中的测试可以帮助你评估自己的估算能力。）如果你估计这里有20%的误差，那里有50%的误差，却依然发现实际设计结果与设计要求相差100倍，那么额外的精度就没有意义了。在对20%的误差幅度给予太多信心之前，请听听 Vic Vyssotsky 多次在讲话中给出的建议。Vyssotsky说:</p>
<p class="content">你们中的大多数人，或许都能够回忆起 1940 年在一场风暴中断裂的外号“Galloping Gertie”的塔科马纳罗斯大桥的样子。在那之前的大约80年里，已经有数座悬索桥以同样的方式断掉了。这是一种气动上升现象。如果想对受力进行正确的工程计算（涉及很大的非线性），需要使用数学方法和Kolmogorov<span id="ref35">
<a href="part0008.xhtml#annot35">[9]</a>
</span>
 的思想为涡旋谱建模。直到20世纪50年代前后，人们才知道如何进行正确的计算。那么，为什么布鲁克林大桥没有如Galloping Gertie一样断裂呢？</p>
<p class="content">这是因为 John Roebling 清楚地知道自己对哪些问题不了解。与设计布鲁克林大桥有关的笔记和信函现在还保存着，这些笔记和信函是优秀工程师了解自己知识局限性的很好的例子。他知道悬索桥有气动上升现象，并且进行了仔细的观察；但他也知道自己不清楚如何为之建模。于是他就将布鲁克林大桥车行道的托架的强度按照基于已知的静态和动态负荷的正常计算结果的6倍设计。此外，他还对延伸到车行道的斜拉网络进行了特别地设计，以加强整座桥的强度。看看这些方法，独一无二。</p>
<p class="content">当Roebling被问到他设计的大桥是否会如其他许多大桥一样垮掉时，他说：“不会，因为我按照所需强度的 6 倍设计了这座大桥，可以防止那种情况的发生。”</p>
<p class="content">Roebling是一位优秀工程师，他通过使用很大的安全系数来补偿自己的知识局限，从而建造了一座高质量的大桥。我们又该怎样做呢？我建议为了补偿我们的知识局限，在估算实时软件系统性能的时候，以2、4或6的系数来降低对性能的估计；在做出可靠性/可用性保证时，给出一个比我们认为能达到的目标差 10 倍的结果；在估算规模、开销和时间进度时，给出保守2倍或4倍的结果。我们应该按照John Roebling的方式进行设计，而不是按照其同代人的方式进行设计——据我所知，美国已经没有Roebling同代人所设计的悬索桥了；在19世纪70年代建造的各种类型的大桥中，有四分之一在建成之后的10年之内就垮掉了。</p>
<p class="content">我们是和John Roebling一样的工程师吗？我很怀疑。</p>
<h3 class="thirdtitle" id="bw56">
<a href="part0000.xhtml#toc65">7.4 Little定律</a>
</h3>
<p class="content">大多数粗略估算都基于显而易见的法则：总开销等于每个单元的开销乘以单元的个数。但是，有时我们需要更为深入的洞察。Bruce Weide 描述了一个令人惊奇的通用法则。</p>
<p class="content">Denning和Buzen介绍的“运筹分析”（参见Computing Surveys第10卷第3期，1978年11月，第225页～第261页）远比计算机系统中的排队网络模型具有普遍意义。他们的研究很出色，但是由于文章主题的限制，他们没有阐明 Little 定律的一般性。他们的证明方法与队列或计算机系统都没有关系。考虑一个带有输入和输出的任意系统，Little定律指出“系统中物体的平均数量等于物体离开系统的平均速率和每个物体在系统中停留的平均时间的乘积。”（并且如果物体离开和进入系统的总体出入流是平衡的，那么离开速率也就是进入速率。）</p>
<p class="content">我在俄亥俄州立大学的计算机体系结构课程中教授这一性能分析方法。但是我试图强调该结论是系统论中的一个通用法则，并且可以应用到许多其他类型的系统中去。例如，假设你正在排队等待进入一个火爆的夜总会，你可以通过估计人们进入的速率来了解自己还要等待多长时间。依据 Little 定律，你可以推论：“这个地方可以容纳约60人，每个人在里面逗留的时间大约是 3小时，因此我们进入夜总会的速率大概是每小时 20人。现在队伍中我们前面还有 20 人，这也就意味着我们需要等待大约一小时。不如我们回家去读《编程珠玑》吧。”我想这下你应该明白了。</p>
<p class="content">Peter Denning简明扼要地将这条法则表述为“队列中物体的平均数量为进入速率与平均停留时间的乘积”。他将这条法则应用于他的酒窖：“在我的地下室里有150箱酒，我每年喝掉25箱并买入25箱，那么每箱酒保存的时间是多长？Little定律告诉我，用150箱除以25箱/年，得到答案6年。”</p>
<p class="content">随后他转向更严肃的应用。“可以用Little定律和流平衡的原理来证明多用户系统中的响应时间公式。假定平均思考时间为z的n个用户同时登录到响应时间为r的任意系统中。每个用户周期都由思考和等待系统响应两个阶段组成，因此整个元系统（包括用户和计算机系统）中的作业总数固定为 n。如果切断系统输出到用户的路径，你就会发现元系统的平均负荷为n、平均响应时间为z+r而吞吐量为x（用每个时间单位处理的作业数来度量）。Little定律告诉我们n=x×(z+r)，对r求解得到r = n/x-z。”</p>
<h3 class="thirdtitle" id="bw57">
<a href="part0000.xhtml#toc66">7.5 原理</a>
</h3>
<p class="content">在进行粗略估算的时候，要切记爱因斯坦的名言：</p>
<p class="content">任何事都应尽量简单，但不宜过于简单。</p>
<p class="content">我们知道简单计算并不是特别简单，其中包含了安全系数，以补偿估算参数时的错误和对问题的了解不足。</p>
<h3 class="thirdtitle" id="bw58">
<a href="part0000.xhtml#toc67">7.6 习题</a>
</h3>
<p class="content">附录B的测试提供了一些额外的习题。</p>
<p class="content">1.贝尔实验室距离狂野的密西西比河有大约1 000英里，而我们距离平时比较温和的帕塞伊克河只有几公里。在一星期的倾盆大雨之后，1992年6月10日出版的Star-Ledger援引一位工程师的话说：“帕塞伊克河的流速为每小时200英里，大约是平时的5倍。”对此你有何评论？</p>
<p class="content">2.在什么距离下骑自行车的送信人使用移动存储介质传递信息的速度高于高速数据线的数据传输速度？</p>
<p class="content">3.手动录入文字来填满一张软盘需要多长时间？</p>
<p class="content">4.假设整个世界变慢为原来的百万分之一。你的计算机执行一条指令需要多长时间？你的磁盘旋转一周需要多长时间？磁盘臂在磁盘上搜索需要多长时间？键入自己的名字又需要多长时间？</p>
<p class="content">5.证明为什么“舍九法”可以正确地检验加法。如何进一步检验“72 法则”？关于这个法则你能证明些什么？</p>
<p class="content">6.联合国估算1998年的世界人口为59亿，年增长率为1.33%。如果按这个速率下去，到2050年世界人口会是多少？</p>
<p class="content">7.附录C描述了对系统进行时间和空间开销建模的程序。阅读这些模型，并写下你对自己系统的时间和空间开销的猜测。然后从本书的网站上下载这些程序，在你的系统上运行，并将所得的估算值和你的猜测进行比较。</p>
<p class="content">8.请使用速算估计一下本书勾勒出的那些设计方案的运行时间。</p>
<p class="content">a.估计一下这些程序和设计方案的时间和空间需求。</p>
<p class="content">b.大O表示法可以看作是速算的形式化，该表示法仅考虑增长率而忽略了常系数。</p>
<p class="content">使用第6章、第8章、第11章、第12章、第13章、第14章和第15章中算法的大O运行时间估算这些算法实现为程序后的运行时间。请将你的估算值与各章中的实验结果进行比较。</p>
<p class="content">9.假设系统处理一个事务需要执行 100 次磁盘访问（尽管有些系统需要的次数可能会少些，但有些系统则需要数百次的磁盘访问）。该系统在每个磁盘中每小时可以处理多少事务?</p>
<p class="content">10.请估计一下你所在城市的死亡率，用每年的总人口百分比来度量。</p>
<p class="content">11.[P.J.Denning]请给出Little定律的概要证明。</p>
<p class="content">12.一篇报纸文章称，25美分硬币的“平均寿命是 30年”。如何检验该论述的真伪呢？</p>
<h3 class="thirdtitle" id="bw59">
<a href="part0000.xhtml#toc68">7.7 深入阅读</a>
</h3>
<p class="content">我最钟爱的数学常识方面的书籍就是1954年出版的Darrell Huff的经典书籍How To Lie With Statistics<span id="ref36">
<a href="part0008.xhtml#annot36">[10]</a>
</span>
 ，这本书由Norton出版社在1993年重新发行。现在看来，书中的例子有些老了（比如其中说某些富人每年可以挣到惊人的2.5万美元！），但是书中的原理却是永远正确的。John Allen Paulos的《数盲：数学无知者眼中的迷惘世界》论述了1990年解决类似问题时所采用的方法（Farrar,Stratus and Giroux出版社出版）。</p>
<p class="content">物理学家很了解这个话题。本章发表在《ACM通讯》上以后，Jan Wolitzky写道：</p>
<p class="content">我经常听到有人根据物理学家费米的名字，将“粗略估算”称为“费米近似”。故事的梗概如下：费米、奥本海默以及其他一些曼哈顿项目的骨干人员隐蔽在一堵低矮的防冲击波墙的后面，等待数千码之外的第一个核装置的爆炸。费米将几张纸撕成小碎片，当看到火光一闪时，即把碎片撒向空中。等冲击波过去之后，他用脚步测量出纸片飞过的距离，然后通过快速的“粗略估算”得出了炸弹的爆炸当量。很久之后这个数得到了昂贵监视设备的确认。</p>
<p class="content">搜索字符串“back of the envelope”和“Fermi problems”可以找到大量的相关网页。</p>
<h3 class="thirdtitle" id="bw60">
<a href="part0000.xhtml#toc69">7.8 日常生活中的速算（边栏）</a>
</h3>
<p class="content">本章在《ACM 通讯》上发表以后，引来了许多有趣的信件。有位读者提到，他曾听一则广告说，某位销售员驾驶新车在一年之内行驶了100 000英里，于是他要他的儿子验证一下这个说法是否成立。这里有一个快速的答案：每年有2 000个工作小时（50周×40小时/周），销售员可能平均每小时行驶50英里；若忽略实际用于销售的时间，则其乘积刚好是广告中所说的数。因此广告的说法超出了可信范围。</p>
<p class="content">日常生活为我们提供了许多训练速算技能的机会。例如，去年你在餐馆就餐总共花了多少钱？一位纽约人经过快速计算后说他和他的妻子每个月花在出租车上的钱要比花在房租上的钱还要多，我听到后非常吃惊。加利福尼亚的读者（他们可能不知道什么是出租车）可以计算一下，如果用橡胶软管向游泳池注水，需要多长时间才能将其注满？</p>
<p class="content">有几位读者说他们在孩提时代就已经学习过速算了。Roger Pinkham这样写道：</p>
<p class="content">我是一位教师，多年以来一直在向每一位听课的人讲授粗略估算。可是我却不可思议地失败了，看来只有怀疑主义者才能学好粗略估算。</p>
<p class="content">是父亲教会了我这种速算的方法。我来自缅因州海岸，小时候有一次无意中听到了我父亲和他的朋友Homer Potter之间的谈话。Homer坚持说两位来自康涅狄格州的女士一天就捕到了200磅（1磅=0.454公斤）龙虾。我父亲说，“让我们来算算。如果你15分钟捕一盆龙虾，每盆约3磅，那么每小时可以捕到12磅，或者说每天能捕到约100磅。我不相信这是真的!”</p>
<p class="content">“是真的”，Homer 发誓说，“你什么都不相信!”。但父亲就是不信他的话。两个星期后，Homer 说，“你知道吗，Fred？那两位女士一天只捕到了20磅龙虾。”</p>
<p class="content">父亲宽宏大量地咕哝到：“这样的话我就相信了。”</p>
<p class="content">其他几位读者从父母和孩子的观点，分别讨论了如何将这种怀疑的态度传授给孩子。适合小孩的问题通常是“步行到华盛顿特区需要多长时间?”、“今年我们用耙子清理了多少片树叶?”等形式。引导得当的话，这类问题似乎可以激发起孩子们终其一生的好奇心，代价是时常会激怒可怜的孩子们。</p>
<h2 class="secondtitle" id="bw61">
<a href="part0000.xhtml#toc70">第8章 算法设计技术</a>
</h2>
<p class="content">第2章描述了算法设计对程序员的日常影响：算法上的灵机一动可以使程序更加简单。本章我们将发现算法设计的一个不那么常见但更富于戏剧性的贡献：复杂深奥的算法有时可以极大地提高程序性能。</p>
<p class="content">本章就一个小问题研究了四种不同的算法，重点强调这些算法的设计技术。其中的一些算法稍微复杂一些，但合情合理。将要研究的第一个程序要花15天时间才能解决一个规模为100 000的问题，而最后一个程序在5毫秒时间内就解决了同样的问题。</p>
<h3 class="thirdtitle" id="bw62">
<a href="part0000.xhtml#toc71">8.1 问题及简单算法</a>
</h3>
<p class="content">问题来自一维的模式识别，后面会讲这个问题的来历。问题的输入是具有n个浮点数的向量 x，输出是输入向量的任何连续子向量中的最大和。例如，如果输入向量包含下面10个元素：</p>
<div class="bodypic_"><img alt="" src="../Images/image00205.jpeg" class="calibre3"/>
</div>
<p class="content">那么该程序的输出为x[2..6]的总和，即187。当所有数都是正数时，问题很容易解决，此时最大子向量就是整个输入向量。当输入向量中含有负数时麻烦就来了：是否应该包含某个负数并期望旁边的正数会弥补它呢？为了使问题的定义更加完整，我们认为当所有的输入都是负数时，总和最大的子向量是空向量，总和为0。</p>
<p class="content">完成该任务的浅显程序对所有满足0≤i≤j&lt;n的(i,j)整数对进行迭代。对每个整数对，程序都要计算x[i..j]的总和，并检验该总和是否大于迄今为止的最大总和。算法1的伪代码如下所示：</p>
<p class="content">maxsofar = 0</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">for j = [i,n)</p>
<p class="content_7">sum = 0</p>
<p class="content_7">for k = [i,j]</p>
<p class="content_8">sum += x[k]</p>
<p class="content_7">/* sum is sum of x[i..j] */</p>
<p class="content_7">maxsofar = max(maxsofar,sum)</p>
<p class="content">这段代码简洁、直观并且易于理解。不幸的是，程序的运行速度也很慢。例如在我的机器上，如果n=10 000，该程序的运行时间约为22 分钟；如果n为100 000，则要运行15天的时间。我们将在8.5节详细讨论有关计时的问题。</p>
<p class="content">这些时间很有趣，我们现在对于该算法效率的感受，跟6.l节用大O表示法描述时所获得的感受不一样。最外层的循环刚好执行n次，而中间循环在外循环的每次执行中至多执行n次。将这两个系数n相乘可知中间循环中的代码将执行O(n<span class="super">2</span>
 )次。中间循环里面的内循环执行的次数不会超过n，因此内循环的运行时间是O(n)。将每次内循环的开销跟它的执行次数相乘，可以得知整个程序的运行时间与n的立方成正比。因此我们将该算法称为立方算法。</p>
<p class="content">这个例子说明了大O分析方法及其众多的优缺点。其主要的缺点就是我们实际上仍然不知道对于任意特定的输入，程序的运行时间是多少，我们只知道步数的数量级是O(n<span class="super">3</span>
 )。该缺点可以由大O分析方法的另外两个优点来弥补：大O分析通常比较容易实现（如上面所示）；而且其渐进运行时间用于粗略估算通常已经足够了，可以以此为依据判断程序是否满足具体应用的要求。</p>
<p class="content">接下来的几节使用渐近运行时间作为程序效率的唯一度量。如果你不喜欢这些内容，请直接跳到8.5节。从8.5节也可以看出，大O分析对于该问题是非常有用的。在继续阅读之前，请花几分钟时间尝试着找到一个更快的算法。</p>
<h3 class="thirdtitle" id="bw63">
<a href="part0000.xhtml#toc72">8.2 两个平方算法</a>
</h3>
<p class="content">大多数程序员对算法 1 都有类似的反应：“有一个明显的方法可以使其运行起来快得多。”实际上有两个明显的方法，对给定程序员来说如果其中一个方法是显而易见的，那么另一个方法则通常不那么明显。这两个算法都是平方时间的（对于输入规模n来说，需要执行O(n<span class="super">2</span>
 )步），都是通过在固定的步数而不是算法1的j-i+1步内完成对 x[i..j]的求和来达到平方时间的。但是这两个平方算法在固定时间内计算总和时却使用了极为不同的方法。</p>
<p class="content">第一个平方算法注意到，x[i..j]的总和与前面已计算出的总和（x[i..j-1]的总和）密切相关。利用这一关系即可得到算法2。</p>
<p class="content">maxsofar = 0</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">sum = 0</p>
<p class="content_5">for j = [i,n)</p>
<p class="content_7">sum += x[j]</p>
<p class="content_7">/* sum is sum of x[i..j] */</p>
<p class="content_7">maxsofar = max(maxsofar,sum)</p>
<p class="content">第一个循环内的语句需要执行n次，第二个循环内的语句在每次执行外循环时至多执行n次，所以总的运行时间是O(n<span class="super">2</span>
 )。</p>
<p class="content">另一个平方算法是通过访问在外循环执行之前就已构建的数据结构的方式在内循环中计算总和。cumarr 中的第 i 个元素包含 x[0..i]中各个数的累加和，所以 x[i..j]中各个数的总和可以通过计算cumarr[j]-cumarr[i-1]得到。从而我们可以得到算法2b的代码，如下所示：</p>
<p class="content">cumarr[-1] = 0</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">cumarr[i] = cumarr[i-1] + x[i]</p>
<p class="content">maxsofar = 0</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">for j = [i,n)</p>
<p class="content_7">sum = cumarr[j] - cumarr[i-1]</p>
<p class="content_7">/* sum is sum of x[i..j] */</p>
<p class="content_7">maxsofar = max(maxsofar,sum)</p>
<p class="content">（习题5解决了访问cumarr[-1]的问题。）这段代码的运行时间为O(n<span class="super">2</span>
 )，其分析过程与算法2完全一样。</p>
<p class="content">迄今为止，我们所看到的算法考虑了所有可能的子向量，并计算了每个子向量中所有数的总和。因为存在 O(n<span class="super">2</span>
 )个子向量，所以这些算法至少需要平方时间。你能想办法避免检测所有可能的子向量，从而获得运行时间更短的算法吗?</p>
<h3 class="thirdtitle" id="bw64">
<a href="part0000.xhtml#toc73">8.3 分治算法</a>
</h3>
<p class="content">我们的第一个次平方（subquadratic）算法很复杂，如果你不想陷入其繁琐的细节问题中，可以直接跳到下一节，那样并不会有多少损失。该算法基于如下的分治原理：</p>
<p class="content">要解决规模为n的问题，可递归地解决两个规模近似为n/2的子问题，然后对它们的答案进行合并以得到整个问题的答案。</p>
<p class="content">在本例中，初始问题要处理大小为n的向量。所以将它划分为两个子问题的最自然的方法就是创建两个大小近似相等的子向量，分别称为a和b。</p>
<div class="bodypic_"><img alt="" src="../Images/image00206.jpeg" class="calibre3"/>
</div>
<p class="content">然后递归地找出a、b中元素总和最大的子向量，分别称为m<span class="sub">a</span>
 和m<span class="sub">b</span>
 。</p>
<div class="bodypic_"><img alt="" src="../Images/image00207.jpeg" class="calibre3"/>
</div>
<p class="content">现在我们很容易误以为自己已经找到问题的解了，因为我们可能会觉得在整个向量中总和最大的子向量必定在m<span class="sub">a</span>
 或m<span class="sub">b</span>
 中。这不完全正确。事实上，最大子向量要么整个在a中，要么整个在b中，要么跨越a和b之间的边界。我们将跨越边界的最大子向量称为m<span class="sub">c</span>
 。</p>
<div class="bodypic_"><img alt="" src="../Images/image00208.jpeg" class="calibre3"/>
</div>
<p class="content">我们的分治算法将递归地计算m<span class="sub">a</span>
 和m<span class="sub">b</span>
 ，并通过其他某种方法计算m<span class="sub">c</span>
 ，然后返回3个总和中的最大者。</p>
<p class="content">有了以上的描述就差不多可以开始编写程序代码了，还需要解决的问题是如何处理小向量以及如何计算m<span class="sub">c</span>
 。前者比较简单：只有一个元素的向量的最大子向量的和就是该向量中的数（若该数为负数，则最大子向量的和为0）。零元素向量的最大子向量的和定义为0。为了计算m<span class="sub">c</span>
 ，我们通过观察发现，m<span class="sub">c</span>
 在a中的部分是a中包含右边界的最大子向量，而m<span class="sub">c</span>
 在b中的部分是b中包含左边界的最大子向量。将这些因素综合到一起就得到了下面的算法3代码：</p>
<p class="content">float maxsum3(l,u)</p>
<p class="content_5">if (l &gt; u) /* zero elements */</p>
<p class="content_7">return 0</p>
<p class="content_5">if (l == u) /* one element */</p>
<p class="content_7">return max(0,x[l])</p>
<p class="content_5">m = (l + u) / 2</p>
<p class="content_5">/* find max crossing to left */</p>
<p class="content_5">lmax = sum = 0</p>
<p class="content_5">for (i = m; i &gt;= l; i--)</p>
<p class="content_7">sum += x[i]</p>
<p class="content_7">lmax = max(lmax,sum)</p>
<p class="content_5">/* find max crossing to right */</p>
<p class="content_5">rmax = sum = 0</p>
<p class="content_5">for i = (m,u]</p>
<p class="content_7">sum += x[i]</p>
<p class="content_7">rmax = max(rmax,sum)</p>
<p class="content_5">return max(lmax+rmax,maxsum3(l,m),maxsum3(m+1,u))</p>
<p class="content">算法3的最初调用如下：</p>
<p class="content">answer = maxsum3(0,n-1)</p>
<p class="content">该程序代码比较复杂，容易出错，但是它在O(n log n)时间内解决了我们的问题。有多种方式可以证明其运行时间。一种非正式的论证是，该算法在每层递归中都执行O(n)次操作，而总计有O(logn)层递归。更精确的论证可以通过递推关系完成。若用T(n)表示解决规模为n的问题所需的时间，那么T(1)=O(1)且</p>
<p class="content_">T(n)= 2T(n/2)+O(n)</p>
<p class="content">习题15指出该递推关系的解为T(n) = O (n log n)。</p>
<h3 class="thirdtitle" id="bw65">
<a href="part0000.xhtml#toc74">8.4 扫描算法</a>
</h3>
<p class="content">我们现在采用操作数组的最简单的算法：从数组最左端（元素x[0]）开始扫描，一直到最右端（元素x[n-1]）为止，并记下所遇到的总和最大的子向量。最大总和的初始值设为0。假设我们已解决了x[0..i-1]的问题，那么如何将其扩展为包含x[i]的问题呢？我们使用类似于分治算法的原理：前i个元素中，最大总和子数组要么在前i-1个元素中（我们将其存储在 maxsofar 中），要么其结束位置为 i（我们将其存储在maxendinghere中）。</p>
<div class="bodypic_"><img alt="" src="../Images/image00209.jpeg" class="calibre3"/>
</div>
<p class="content">使用类似算法 3 那样的代码从头开始计算 maxendinghere 将得到又一个平方算法。我们可以使用导出算法2的方法来避免得到平方算法：不从头开始计算结束位置为i的最大子向量，而是利用结束位置为i-1的最大子向量进行计算。这样就得到了算法4。</p>
<p class="content">maxsofar = 0</p>
<p class="content">maxendinghere = 0</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">/* invariant: maxendinghere and maxsofar</p>
<p class="content_7">are accurate for x[0..i-1] */</p>
<p class="content_5">maxendinghere = max(maxendinghere + x[i],0)</p>
<p class="content_5">maxsofar = max(maxsofar,maxendinghere)</p>
<p class="content">理解这个程序的关键就在于变量 maxendinghere。在循环中的第一个赋值语句之前，maxendinghere是结束位置为i-1的最大子向量的和；赋值语句将其修改为结束位置为 i 的最大子向量的和。若加上 x[i]之后结果依然为正值，则该赋值语句使maxendinghere增大x[i]；若加上x[i]之后结果为负值，该赋值语句就将maxendinghere重新设为0（因为结束位置为i的最大子向量现在为空向量）。该代码比较复杂，但十分简短，运行起来也很快：其运行时间为O(n)，因此我们称之为线性算法。</p>
<h3 class="thirdtitle" id="bw66">
<a href="part0000.xhtml#toc75">8.5 实际运行时间</a>
</h3>
<p class="content">到目前为止，我们一直是简单地使用大O分析法来说明问题，现在该研究程序的运行时间了。我在主频400 MHz的PentiumⅡ计算机上，用C语言实现了前面的4个主要算法，并对其计时，然后根据观测到的运行时间进行外推，从而得到下面的表格。（算法2b的运行时间一般在算法2的10%之内，因此没有包含在表内。）</p>
<div class="pic_"><img alt="" src="../Images/image00210.jpeg" class="calibre3"/>
</div>
<p class="content">这个表说明了许多问题。其中最重要的一点是：合适的算法设计可以极大地减少运行时间，中间的几行数据突出强调了这一点。最后两行说明了问题规模的增加与运行时间的增加之间的关系。</p>
<p class="content">另一个重点是，当我们将立方算法、平方算法以及线性算法进行相互比较时，程序运行时间中的常系数并不重要。（2.4 节中有关 O(n!)算法的讨论表明，在增长速度快于多项式的函数中，常系数的影响更小。）为了强调这一点，我进行了一次实验，使两个算法的常系数的差尽可能地大。为得到一个巨大的常系数，我在 Radio Shack TRS-80 Model Ⅲ（1980年的个人电脑，使用Z-80处理器，主频为2.03 MHz）上实现了算法4。为了进一步减慢那台可怜的老古董，我使用了解释型的BASIC代码，这种BASIC代码比编译型代码慢l～2个数量级。为了得到一个很小的常系数，我在主频为533 MHz的Alpha 21164上实现了算法1。我得到了所期望的差异：立方算法的运行时间度量结果为0.58n<span class="super">3</span>
 纳秒，而线性算法的运行时间为19.5n毫秒，或者说19 500 000n纳秒（也就是说，每秒大约处理50个元素）。下表给出了这两个表达式在各种问题规模下所对应的运行时间。</p>
<div class="pic_"><img alt="" src="../Images/image00211.jpeg" class="calibre3"/>
</div>
<p class="content">3 300 万倍的常系数差异使得立方算法在刚开始快一些，但是这并不能阻止线性算法的后来居上。两种算法的平衡点在5 800附近，在这个位置上，每种算法的运行时间都还不到2分钟。</p>
<div class="bodypic_"><img alt="运行时间（纳秒）问题规模（n）微秒纳秒 毫秒月小时秒世纪运行时间（常用单位）" src="../Images/image00212.jpeg" class="calibre3"/>
</div>
<h3 class="thirdtitle" id="bw67">
<a href="part0000.xhtml#toc76">8.6 原理</a>
</h3>
<p class="content">这个问题的历史清楚地展示了算法设计技术。该问题出现在布朗大学的 Ulf Grenander所面对的一个模式匹配问题中，问题的最初形式是习题13中所描述的二维形式。在该版本的问题中，最大总和子数组是数字图像中某种特定模式的最大似然估计量。因为二维问题的求解需要太多的时间，所以Grenander将它简化为一维问题，以深入了解其结构。</p>
<p class="content">Grenander发现立方运行时间的算法1出奇地慢，于是开发出了算法2。1977年的时候，他将该问题叙述给Michael Shamos听，结果Shamos花一个通宵就设计出了算法3。过了没多久，Shamos向我介绍这个问题，我们一致认为这很可能是最好的算法了，因为研究人员刚刚证明了几个类似的问题需要正比于n log n的时间。几天之后， Shamos 在卡内基—梅隆大学研讨会上介绍了该问题及其历史，结果与会的统计学家Jay Kadane在一分钟之内就勾勒出了算法4。好在我们知道不会有更快的算法了：任何正确的算法都必须至少花费O(n)的时间（见习题6）。</p>
<p class="content">虽然一维问题得到了完满的解决，但是Grenander最初的二维问题却迟迟没有答案。（在本书第2版行将出版的时候，该问题已经提出20年了。）由于所有已知算法的计算开销过大，Grenander 不得不放弃那种解决其模式匹配问题的方法。如果读者朋友觉得一维问题的线性时间算法是“显而易见”的，那么请帮助Grenander找一找习题13的“显而易见”的算法。</p>
<p class="content">本章故事中的这些算法给出了几个重要的算法设计技术。</p>
<p class="content">保存状态，避免重复计算。算法2和算法4使用了简单的动态规划形式。通过使用一些空间来保存中间计算结果，我们避免了花时间对其重复计算。</p>
<p class="content">将信息预处理至数据结构中。算法2b中的cumarr结构允许对子向量中的总和进行快速计算。</p>
<p class="content">分治算法。算法 3 使用了简单的分治算法形式；有关算法设计的教科书介绍了更高级的分治算法形式。</p>
<p class="content">扫描算法。与数组相关的问题经常可以通过思考“如何将 x[0..i-1]的解扩展为x[0..i]的解?”来解决。算法4通过同时存储已有的答案和一些辅助数据来计算新答案。</p>
<p class="content">累加数组。算法2b使用了一个累加表，表中第i个元素的值为x中前i个值的总和；这一类表常用于处理有范围限制的问题。例如，业务分析师要确定3月份到10月份的销售额，可以从10月份的本年迄今销售额中减去2月份的本年迄今销售额。</p>
<p class="content">下界。只有在确定了自己的算法是所有可能的算法中最佳的算法以后，算法设计师才可能踏踏实实地睡个好觉。为此，他们必须证明某个相匹配的下界。</p>
<p class="content">对本问题线性下界的讨论见习题6，更复杂的下界证明可能会十分困难。</p>
<h3 class="thirdtitle" id="bw68">
<a href="part0000.xhtml#toc77">8.7 习题</a>
</h3>
<p class="content">1.算法3和算法4使用的代码比较复杂，也很容易出错。请使用第4章中的程序验证技术证明代码的正确性，指定循环不变式时请务必小心。</p>
<p class="content">2.请在你的机器上对本章中的四种算法计时，建立与8.5节相类似的表。</p>
<p class="content">3.我们对四种算法的分析仅限于大O层面。请尽可能精确地分析每种算法调用max函数的次数。本题对你分析这些程序的运行时间有何启示?每种算法需要多少空间？</p>
<p class="content">4.如果输入数组中的各个元素都是从区间[-1,1]中均匀选出的随机实数，那么最大子向量的期望值是多少？</p>
<p class="content">5.为简单起见，我们允许算法2b访问cumarr[-1]。如何使用C语言处理该问题？</p>
<p class="content">6.证明任何计算最大子向量的正确算法都必须检测所有n个输入。（有些问题的算法可以正确地忽略某些输入；请思考答案2.2中Saxe的算法，以及Boyer和Moore的子串搜索算法。）</p>
<p class="content">7.当我第一次实现这些算法时，我总是使用脚手架将各种不同算法所产生的答案和算法4所产生的答案进行比较。当看到脚手架报告算法2b和算法3中的错误时，我很烦躁。但是当我仔细研究这些数值答案时，我发现它们尽管不一样，却非常接近。这意味着什么呢?</p>
<p class="content">8.修改算法3（分治算法），使其在最坏情况下具有线性运行时间。</p>
<p class="content">9.我们将负数数组的最大子向量的和定义为0，即空向量的总和。假设我们重新定义，将最大子向量的和定义为最大元素的值，那么，应该如何修改各个程序呢？</p>
<p class="content">10.假设我们想要查找的是总和最接近0的子向量，而不是具有最大总和的子向量。你能设计出的最有效的算法是什么？可以应用哪些算法设计技术？如果我们希望查找总和最接近某一给定实数t的子向量，结果又将怎样?</p>
<p class="content">11.收费公路由n个收费站之间的n-1段公路组成，每一段公路都有相关的使用费。如果在O(n)时间内驶过两个收费站，并且仅使用一个费用数组；或在固定时间内驶过两个收费站，并且使用一个具有 O(n<span class="super">2</span>
 )个表项的表，那么给出两站之间的行驶费很容易。请描述一个数据结构，该结构仅需要O(n)的空间，却可以在固定的时间内完成任意路段的费用计算。</p>
<p class="content">12.将数组x[0..n-1]初始化为全0后，执行下面n个运算：</p>
<p class="content">for i = [l,u]</p>
<p class="content_4">x[i] += v</p>
<p class="content">其中1、u和v为每次运算的参数（1和u为满足0≤1≤u＜n的整数，v为实数)。</p>
<p class="content">完成这 n 次运算之后，x[0..n-1]中的各个值将按顺序排列。上面刚刚描述的方法需要O(n<span class="super">2</span>
 )的运行时间。你能给出一个更快的算法吗?</p>
<p class="content">13.在最大子数组问题中，给定 n×n 的实数数组，我们需要求出矩形子数组的最大总和。该问题的复杂度如何?</p>
<p class="content">14.给定整数m、n和实数向量x[n]，请找出使总和x[i]+…+x[i+m]最接近0的整数i （0≤i＜n-m）。</p>
<p class="content">15.当T(1)＝0且n为2的幂时，递推公式T(n)=2 T(n/2)+cn的解是什么?请用数学归纳法证明你的结果。如果T(1)=c，结果又怎样?</p>
<h3 class="thirdtitle" id="bw69">
<a href="part0000.xhtml#toc78">8.8 深入阅读</a>
</h3>
<p class="content">只有经过广泛的研究和实践，你才能熟练地运用算法设计技术；大多数程序员仅仅是从有关算法的课程或教科书中获得这些知识。Aho、Hopcroft 和 Ullman 的 Data Structures and Algorithms<span id="ref37">
<a href="part0008.xhtml#annot37">[11]</a>
</span>
 （Addison-Wesley出版社1983年出版）是一本很优秀的大学教材。书中的第10章是关于“算法设计技术”的，与本章内容尤为相关。</p>
<p class="content">Cormen、Leiserson和Rivest的Introduction to Algorithms<span id="ref38">
<a href="part0008.xhtml#annot38">[12]</a>
</span>
 一书由M1T出版社于1990年出版。这本上千页的巨著对这个领域进行了全方位的论述。第Ⅰ、Ⅱ和Ⅲ部分涵盖了基础知识、排序以及搜索方面的内容。第Ⅳ部分是关于“高级设计和分析技术”的，与本章主题的关系特别密切。第Ⅴ、Ⅵ和Ⅶ部分讨论了高级数据结构、图算法和其他精选的主题。</p>
<p class="content">这些书与其他7本书一起收藏在一张名为“Dr.Dobb’s Essential Books on Algori thms and Data Structures”的CD-ROM中。该CD在1999年由Miller Freeman有限公司发行。这对所有对算法和数据结构感兴趣的程序员来说都是一份无价的参考。在本书即将出版的时候，已经可以从Dr.Dobb’s的网站www.ddj.com上订购完整的一套电子版了，其价格仅相当于一本纸版书的价格。</p>
<h2 class="secondtitle" id="bw70">
<a href="part0000.xhtml#toc79">第9章 代码调优</a>
</h2>
<p class="content">有些程序员过于关注程序的效率；由于太在乎细小的“优化”，他们编写出的程序过于精妙，难以维护。而另外一些程序员很少关注程序的效率；他们编写的程序有着清晰漂亮的结构，但效率极低以至于毫无用处。优秀的程序员将程序的效率纳入整体考虑之中：效率只是软件中的众多问题之一，但有时候也很重要。</p>
<p class="content">前面各章已经讨论了提高效率的高层次方法：问题定义、系统结构、算法设计以及数据结构选择。本章讨论一个低层次方法。“代码调优”首先确定程序中开销较大的部分，然后进行少量的修改，以提高其运行速度。“代码调优”并不总是恰当的方法，也不太有趣，但是有时候它确实可以使程序的性能大为改观。</p>
<h3 class="thirdtitle" id="bw71">
<a href="part0000.xhtml#toc80">9.1 典型的故事</a>
</h3>
<p class="content">一天午后不久，我和Chris Van Wyk在一起谈论代码调优的问题，然后他就去改进一个C程序了。几小时之后，他将一个3 000行的图形程序的运行时间减少了一半。</p>
<p class="content">尽管处理常见图像的运行时间已经大大缩短了，该程序处理某些复杂的图片时仍然要花费10分钟的时间。Van Wyk所采取的第一步就是监视程序的性能，以确定每个函数需要花费的时间（下一页对一个类似但规模小一些的程序进行了性能监视）。在10幅常见测试图片上的运行结果表明，几乎70%的运行时间都用在了内存分配函数malloc上。</p>
<p class="content">Van Wyk的第二步就是研究内存分配程序。因为他的程序通过一个提供错误检测的函数来访问malloc，所以他可以修改该函数，而不必分析malloc的源代码。在插入了几行计数代码后，他发现最常见记录类型的空间分配次数是次常见记录类型的 30倍。如果你知道了程序的大部分运行时间都用于为某一类型的记录分配存储空间，你会如何进行改进程序使其运行得更快呢?</p>
<p class="content">Van Wyk应用高速缓存原理解决了这个问题：最经常访问的数据，其访问开销应该是最小的。他对程序进行了修改，将最常见类型的空闲记录缓存在一个链表中。然后，他就可以通过对该链表的快速访问来处理常见的请求，而不必调用通用的内存分配程序；这使得程序的总运行时间缩短为原先的45%（于是内存分配程序现在大约占用总运行时间的 30%）。另一个额外的好处就是修改后的分配程序减少了内存碎片，这使得我们能够更加有效地使用主存。答案2给出了该古老技术的另一种实现；在第13章中，我们将多次使用类似的方法。</p>
<p class="content">这个故事极好地展示了代码调优艺术。通过花费几小时的时间进行度量并向3 000行代码的程序中添加约20行代码，Van Wyk在不改变用户视图也不增加维护难度的前提下将程序的运行速度加快了一倍。他使用一般性的工具就取得了这种加速：通过性能监视识别出程序中的“热点”，然后使用高速缓存减少其运行时间。</p>
<p class="content">下面对一个规模小一些的常见 C 程序进行了性能监视，其形式和内容都和 Van Wyk的性能监控很类似：</p>
<div class="pic_"><img alt="" src="../Images/image00213.jpeg" class="calibre3"/>
</div>
<p class="content">该运行结果表明，大部分时间都消耗在malloc上了。习题2要求我们通过缓存结点来减少该程序的运行时间。</p>
<h3 class="thirdtitle" id="bw72">
<a href="part0000.xhtml#toc81">9.2 急救方案集锦</a>
</h3>
<p class="content">现在我们将目光从大程序转向几个小函数。每个小函数都描述了一个我曾在不同场合下遇到过的问题。这些问题占用了其所在应用程序的大部分运行时间。我们给出的解决方案也都具有一般性。</p>
<p class="content">问题1——整数取模。2.3节简要介绍了实现向量旋转的三种算法。答案2.3在内循环中使用下面的运算实现了“杂技”算法：</p>
<p class="content">k = ( j + rotdist)％n;</p>
<p class="content">附录C中的开销模型表明，C语言的模运算符%开销较大：大多数算术运算需要约10纳秒的时间，而模运算需要的运行时间接近100纳秒。使用下面的代码实现%运算或许可以减少程序的运行时间：</p>
<p class="content">k = j + rotdist;</p>
<p class="content">if (k &gt;= n)</p>
<p class="content_5">k -= n;</p>
<p class="content">该代码使用一次比较运算和一次（很少执行的）减法运算取代了高开销的模运算。但是这样做对整个函数的运行时间会有影响吗？</p>
<p class="content">我第一次运行该程序时将旋转距离rotdist设置为1，程序的运行时间从119n纳秒下降至57n纳秒，速度几乎提高了一倍。62纳秒的加速结果与开销模型中的预测很接近。</p>
<p class="content">第二次实验时，我将rotdist设置为10。我惊奇地发现这两个算法的运行时间都是206n 纳秒。通过进行与答案 2.4 中的图相似的实验，我很快找到了原因：当 rotdist=1时，算法顺序访问内存，模运算决定了程序的运行时间。而当rotdist=10时，代码在内存中每隔10个字才访问一次，因此大部分运行时间用于将RAM的内容读入高速缓存。</p>
<p class="content">在过去，程序员知道，如果程序的运行时间主要消耗在输入输出上，那么对程序中的计算进行加速是毫无意义的。在现代的体系结构中，如果对内存的访问占用了大量的运行时间，那么减少计算时间同样是毫无意义的。</p>
<p class="content">问题2——函数、宏和内联代码。在第8章中，我们多处对两个值中的最大值进行了计算。例如，在8.4节中，我们使用了类似下面的代码：</p>
<p class="content">maxendinghere = max(maxendinghere,0);</p>
<p class="content">maxsofar = max(maxsofar,maxendinghere);</p>
<p class="content">max函数返回两个参数中的最大值：</p>
<p class="content">float max(float a,float b)</p>
<p class="content">{　　return a &gt; b ? a : b; }</p>
<p class="content">这个程序的运行时间大约是89n纳秒。</p>
<p class="content">以前的C语言程序员可能会下意识地使用宏来替换max函数：</p>
<p class="content">#define max(a,b)((a)&gt;(b)?(a)：(b))</p>
<p class="content">这当然更加难看并且更容易出错。对于许多优化编译器来说，两者根本就没有什么区别（这一类编译器以内联的方式编写较小的函数）。然而，在我的系统中，这一改变将算法4的运行时间从89n纳秒减少到了47n纳秒。加速系数接近2。</p>
<p class="content">我高兴地将这一方法应用到8.3节中的算法3，却失望地发现：当n=10 000时，程序的运行时间从10毫秒增加到了100秒，减速系数达到了10 000。宏似乎使得算法3的运行时间从原来的O(n log n)增加到了近乎O(n<span class="super">2</span>
 )。我很快就发现，宏那种按名称调用的语义导致算法3对自身的递归调用超过了两次，因此增加了其渐近运行时间。习题4给出了这一类减速的一个更加极端的例子。</p>
<p class="content">C程序员经常需要在性能和正确性之间进行折中，而C++程序员却可以享受鱼与熊掌兼得的快乐。C++允许对某一函数进行内联编译，这就兼得了函数的简洁语义和宏的低廉开销。</p>
<p class="content">在好奇心的驱使下，我既不使用宏，也不使用函数，而是使用if语句实现该计算：</p>
<p class="content">if (maxendinghere &lt; 0)</p>
<p class="content_5">maxendinghere = 0;</p>
<p class="content">if (maxsofar &lt; maxendinghere)</p>
<p class="content_5">maxsofar = maxendinghere；</p>
<p class="content">运行时间基本上没有变化。</p>
<p class="content">问题3——顺序搜索。现在我们将目光转向（可能未排序的）表中的顺序搜索：</p>
<p class="content">int ssearch1(t)</p>
<p class="content_5">for i = [0,n)</p>
<p class="content_7">if x[i] == t</p>
<p class="content_8">return i</p>
<p class="content_5">return -1</p>
<p class="content">这段简洁的代码平均需要花4.06n纳秒的时间来查找数组x中的某一元素。因为在一次常见的成功搜索中，代码只需要检索数组中一半的元素，所以平均花在表中每个元素上的时间大约为8.1纳秒。</p>
<p class="content">该循环已经很简洁了，但还可以再进行少许精简。内循环中有两种测试：第一种测试检验 i 是否已到达数组末尾，第二种测试检验 x[i]是否为所需的元素。只要在该数组的末尾放置一个哨兵值，就可以把第一种测试也替换为第二种测试：</p>
<p class="content">int ssearch2(t)</p>
<p class="content_5">hold = x[n]</p>
<p class="content_5">x[n] = t</p>
<p class="content_5">for (i = 0; ; i++)</p>
<p class="content_7">if x[i] == t</p>
<p class="content_8">break</p>
<p class="content_5">x[n] = hold</p>
<p class="content_5">if i == n</p>
<p class="content_7">return -1</p>
<p class="content_5">else</p>
<p class="content_7">return i</p>
<p class="content">这一改进使运行时间降低至3.87n纳秒，大约加速了5%。上述代码假设已经为该数组分配了内存，因此 x[n]可以被临时覆盖。该代码谨慎地保存了 x[n]并在搜索之后对其进行了恢复，这在大多数应用场合中都是不必要的，所以下一个版本中将删掉该部分。</p>
<p class="content">现在最内层循环只包含一次自增、一次数组访问以及一次测试。还有办法进一步减少程序的运行时间吗？我们最终的顺序搜索程序将循环展开8次来删除自增，进一步的展开不会取得更好的加速效果。</p>
<p class="content">int ssearch3(t)</p>
<p class="content_5">x[n] = t</p>
<p class="content_5">for (i = 0; ; i += 8)</p>
<p class="content_7">if (x[i　] == t) {　　　　break }</p>
<p class="content_7">if (x[i+1] == t) {i += 1; break }</p>
<p class="content_7">if (x[i+2] == t) {i += 2; break }</p>
<p class="content_7">if (x[i+3] == t) {i += 3; break }</p>
<p class="content_7">if (x[i+4] == t) {i += 4; break }</p>
<p class="content_7">if (x[i+5] == t) {i += 5; break }</p>
<p class="content_7">if (x[i+6] == t) {i += 6; break }</p>
<p class="content_7">if (x[i+7] == t) {i += 7; break }</p>
<p class="content_5">if i == n</p>
<p class="content_7">return -1</p>
<p class="content_5">else</p>
<p class="content_7">return i</p>
<p class="content">这一修改使运行时间降低至l.70n纳秒，减少了大约56%。对老式计算机来说，降低开销可以加速10%或20%。对于现代的计算机来说，将循环展开则有助于避免管道阻塞、减少分支、增加指令级的并行性。</p>
<p class="content">问题4——计算球面距离。最后一个问题在处理地理或几何数据的应用中很常见。输入的第一部分是球面上5 000个点组成的集合S，每个点都使用经度和纬度表示。将这些点存储在我们选定的数据结构中以后，程序读取输入的第二部分：由 20 000个点组成的序列，每个点都使用经度和纬度表示。对于该序列中的每个点，程序必须指出S中哪个点最接近它。这里距离使用球体中心与两个点的连线之间的夹角来度量。</p>
<p class="content">20世纪80年代早期，Margaret Wright就碰到过类似的问题，她当时在斯坦福大学，要对地图进行计算，以总结某些特定基因特征的全球分布。她的解决方案很直观，将集合S表示成包含经度和纬度值的数组。对于序列中的每个点，通过计算它到S中每一个点的距离来确定S中和它最接近的点。计算过程中需要用到一个包含10个正弦和余弦函数的复杂三角公式。尽管该程序编码很简单，并且对小型数据集也能得到不错的结果；但是对于大型地图来说，即使在大型机上运行也需要花费几个小时，这大大超出了项目的预算。</p>
<p class="content">由于我以前处理过几何方面的问题，所以Wright请我来解决这个问题。花费近一个周末的时间之后，我开发出了几个别出心裁的算法和数据结构来解决这个问题。幸运的是（现在回过头来看），这些算法都需要好几百行的代码，所以我没有尝试去实现这几种算法。当我向Andrew Appel描述这些数据结构时，他发现了一个关键点：为什么一定要在数据结构的层面解决这个问题呢?为什么不使用简单的数据结构，将这些点保存在一个数组中，通过调优代码来降低各点之间距离的计算开销呢?如何实现他的这一思想?</p>
<p class="content">更改点的表示法可以大大地减少开销：我们不使用经度和纬度来表示点，而是使用x、y和z坐标表示球面上点的位置。这样，所用的数据结构就是一个数组，它不仅包含了每个点的经度和纬度（其他运算或许还需要这些信息），还包含了该点的三个笛卡儿坐标。当程序处理序列中的每个点时，先用一些三角函数将其经度和纬度转换成x、y和z坐标，然后计算该点到集合S中每个点的距离。它到S中某点的距离为三个维度上差值的平方和。通常这样的系统开销要比计算一个三角函数的开销少很多，更不用说10个三角函数了。（附录C中的运行时间开销模型给出了某个系统中的详细讨论。）因为两个点之间的角度随着它们欧氏距离的平方的增加而单调增加，所以此方法计算的答案是正确的。</p>
<p class="content">尽管这个方法需要额外的存储空间，但它带来了巨大的好处：Wright将该改动写入她的程序之后，处理复杂地图的运行时间由几小时降低为半分钟。在这个例子中，我们通过代码调优，只需要增加几十行的程序代码就能解决该问题；而如果更改算法和数据结构，则需要增加好几百行的代码。</p>
<h3 class="thirdtitle" id="bw73">
<a href="part0000.xhtml#toc82">9.3 大手术——二分搜索</a>
</h3>
<p class="content">现在来看看我所知道的有关代码调优的最极端的例子之一。细节问题可以从习题4.8中得知：在包含1 000个整数的表中进行二分搜索。在我们研究该问题时，请记住在二分搜索中通常不需要代码调优——二分搜索算法的效率很高，对其进行代码调优通常是多余的。因此，我们在第4章中忽略了微观效率，致力于获得一个简单、正确且可维护的程序。但是有时调优过的二分搜索可能会对整个系统的性能产生很大影响。</p>
<p class="content">下面连续开发了四个快速的二分搜索程序。它们都很复杂，但是我们有充分的理由来开发这四个程序：最终程序的运行速度通常是4.2节中的二分搜索程序的2~3倍。在继续往下阅读之前，你能指出原先这段二分搜索代码中的明显浪费吗?</p>
<p class="content">l = 0;u = n-1</p>
<p class="content">loop</p>
<p class="content_5">/* invariant: if t is present,it is in x[l..u]*/</p>
<p class="content_5">if l &gt; u</p>
<p class="content_7">p = -1; break</p>
<p class="content_5">m = (l + u)/2</p>
<p class="content_5">case</p>
<p class="content_7">x[m] &lt; t: l = m+1</p>
<p class="content_7">x[m] == t: p = m; break</p>
<p class="content_7">x[m] &gt; t: u = m-1</p>
<p class="content">首先从一个修改过的问题来开始开发我们的快速二分搜索程序：确定整数数组x[0..n-1]中整数t第一次出现的位置（在15.3节中，我们需要的就是这样的搜索）。而在t多次出现的情况下，上述代码则可能会返回其中的任意一个位置。新程序的主循环与上面的程序类似；我们仍使用下标l和u指示数组中包含t的部分，但不变式关系变为x[l]＜t≤x[u]和l＜u。此外，我们假设n≥0，x[-1] ＜t以及x[n]≥t（但是程序并不访问这两个假想的元素）。现在的二分搜索代码如下：</p>
<p class="content">l = -1; u = n</p>
<p class="content">while l+1 != u</p>
<p class="content_5">/* invariant: x[l] &lt; t &amp;&amp; x[u]&gt;= t&amp;&amp; l &lt; u */m = (l + u)/2</p>
<p class="content_5">if x[m] &lt; t</p>
<p class="content_7">l = m</p>
<p class="content_5">else</p>
<p class="content_7">u = m</p>
<p class="content">/* assert l+l = u &amp;&amp; x[l] &lt; t &amp;&amp; x[u] &gt;= t*/</p>
<p class="content">p=u</p>
<p class="content">if p &gt;= n|| x[p] !=t</p>
<p class="content_5">p = -1</p>
<p class="content">第一行代码初始化不变式。循环重复时，由if语句来保持该不变式的正确性；很容易检验出，这两个分支都保持了该不变式的正确性。循环终止时，我们知道如果t存在于数组中，那么t的第一次出现在位置u；更正式的陈述见assert注释。最后两个语句对p赋值：如果t在x中，那么将p置为t第一次出现的下标；如果t不在数组中，则将p置为-1。</p>
<p class="content">虽然这个二分搜索程序解决的问题要比原先的程序所解决的问题更难，但却可能更高效：在每次循环迭代中，它只对t和x中的元素作一次比较，而原先的程序有时必须比较两次。</p>
<p class="content">下一版本的程序将首次利用n=1 000这个已知条件。该程序使用了一个不同的范围表示方法：我们不使用l..u来表示上下限值，而是使用下限值l以及增量i来表示，使得l + i = u。程序代码将确保i总是2的幂；该性质很容易保持，但是一开始难以获得（因为数组的大小n等于1 000）。因此在程序的开始部分先使用了赋值语句和if语句，以确保初始的搜索范围大小为512，即小于1 000 的数中最大的2 的幂。这样 l和l+i一起要么表示-1..511，要么表示488..1 000。使用这个新的范围表示方法转换前面的二分搜索程序，得到下面的代码：</p>
<p class="content">i = 512</p>
<p class="content">l = -1</p>
<p class="content">if x[511] &lt; t</p>
<p class="content_5">l = 1000 - 512</p>
<p class="content">while i != 1</p>
<p class="content_5">/* invariant: x[l] &lt; t &amp;&amp; x[l+i] &gt;= t&amp;&amp; i = 2^j */nexti = i / 2</p>
<p class="content_5">if x[l+nexti] &lt; t</p>
<p class="content_7">l = l + nexti</p>
<p class="content_7">i = nexti</p>
<p class="content_5">else</p>
<p class="content_7">i = nexti</p>
<p class="content">/* assert i == l &amp;&amp; x[l] &lt; t &amp;&amp; x[l+i] &gt;= t */</p>
<p class="content">p = l+1</p>
<p class="content">if p &gt; 1000 || x[p] != t</p>
<p class="content_5">p = -1</p>
<p class="content">该程序正确性的证明和前一程序的证明完全一样。这段代码通常要比前一个程序慢一些，但它为将来的加速打开了方便之门。</p>
<p class="content">下一程序是上述程序的简化，它加入了智能编译器可能会执行的某些优化：简化了第二个if语句，删除了变量nexti，并从循环内的if语句中删除了对nexti的赋值。</p>
<p class="content">i = 512</p>
<p class="content">l = -1</p>
<p class="content">if x[511] &lt; t</p>
<p class="content_5">l = 1000 - 512</p>
<p class="content">while i != 1</p>
<p class="content_5">/* invariant: x[l] &lt; t &amp;&amp; x[l+i] &gt;= t&amp;&amp; i = 2^j */</p>
<p class="content_5">i = i / 2</p>
<p class="content_5">if x[l+i] &lt; t</p>
<p class="content_7">l = l + i</p>
<p class="content">/* assert i == l &amp;&amp; x[l] &lt; t &amp;&amp; x[l+i] &gt;= t */</p>
<p class="content">p = l+1</p>
<p class="content">if p &gt; 1000 || x[p] != t</p>
<p class="content_5">p = -1</p>
<p class="content">虽然该程序代码正确性的证明仍然与上述程序相同，但现在我们可以更直观地理解其运行。当第一个测试失败，并且l保持为0时，程序依次计算p的各个位，并且最高有效位优先计算。</p>
<p class="content">程序代码的最后一个版本需要用心研究一下。它展开了整个循环，从而消除了循环控制和i被2除的开销。因为i在程序中只有10个互不相同的值，所以我们可以将它们全部写在代码中，从而避免在运行时重复计算。</p>
<p class="content">l = -1</p>
<p class="content">if (x[511] &lt; t) l = 1000-512</p>
<p class="content_5">/* assert x[l] &lt;t &amp;&amp; x[l+512] &gt;= t */if (x[l+256] &lt; t) 1 += 256</p>
<p class="content_5">/* assert x[l] &lt;t &amp;&amp; x[l+256] &gt;= t */if (x[l+128] &lt; t) l += 128</p>
<p class="content">if (x[l+64 ] &lt; t) l += 64</p>
<p class="content">if (x[l+32 ] &lt; t) l += 32</p>
<p class="content">if (x[l+16 ] &lt; t) l += 16</p>
<p class="content">if (x[l+8 ] &lt; t) l += 8</p>
<p class="content">if (x[l+4 ] &lt; t) l += 4</p>
<p class="content">if (x[l+2 ] &lt; t) l += 2</p>
<p class="content_5">/* assert x[l] &lt;t &amp;&amp; x[l+2 ] &gt;= t */if (x[l+1 ] &lt; t) l += 1</p>
<p class="content_5">/* assert x[l] &lt;t &amp;&amp; x[l+1 ] &gt;= t */p = l+1</p>
<p class="content">if p &gt; 1000 || x[p] !=t</p>
<p class="content_5">p = -1</p>
<p class="content">我们可以通过插入与对 x[l+256]的测试之前和之后的断言类似的断言语句来理解这段程序代码。一旦完成了对该if语句作用的二元分析，所有其他的if语句也就随之迎刃而解了。</p>
<p class="content">我曾在多个不同的系统上比较过4.2节中的原始二分搜索和上述仔细调优过的二分搜索。本书的第一版给出了在四台机器、五种编程语言以及若干个优化水平下的运行时间，运行时间缩短的范围从38%到80%不等。我在现在的机器上实验时，惊喜地发现当n=1 000时，每次搜索的时间从350纳秒减少到了125纳秒（减少了64%）。</p>
<p class="content">这样的加速结果好得让人难以置信，但是事实就是这样。深入的观察表明，我的计时脚手架依次搜索每个数组元素：首先x[0]，然后x[1]，依此类推。这就给二分搜索提供了特别有利的内存访问模式以及极好的分支预测。于是我将脚手架更改为按随机顺序搜索元素。原始二分搜索的运行时间为418纳秒，而循环展开之后的程序的运行时间为266纳秒，加速了36%。</p>
<p class="content">这种推导给出了在最极端的情况下进行代码调优的理想化的理由。我们用一个非常精炼的、本质上也更快的程序替换了原先那个浅显的二分搜索程序（该程序看起来也挺简洁的）。（自从20世纪60年代早期起，此函数就已经在计算机界小有名气了。我是在20世纪80年代早期从Guy Steele<span id="ref39">
<a href="part0008.xhtml#annot39">[13]</a>
</span>
 那里学到的；而Guy Steele是在MIT学会的，该函数从20世纪60年代末期开始就在MIT出名了。Vic Vysstosky在1961年的时候在贝尔实验室使用过这段代码，他将伪代码中的每一条if语句都实现为三条IBM 7 090指令。）</p>
<p class="content">第 4 章的程序验证工具在这个过程中起到了关键的作用。正是因为使用了程序验证技术，所以我们可以相信最终的程序是正确的。在我第一次看到这个最终的代码时，它既没有推导，也没有验证，看起来就像在变魔术一样。</p>
<h3 class="thirdtitle" id="bw74">
<a href="part0000.xhtml#toc83">9.4 原理</a>
</h3>
<p class="content">代码调优的最重要原理就是尽量少用它。这一笼统的叙述可以用以下几点加以解释。</p>
<p class="content">效率的角色。软件的其他许多性质和效率一样重要，甚至更重要。Don Knuth观察发现，不成熟的优化是大量编程灾害的根源，它会危及程序的正确性、功能性以及可维护性。当可能的危害影响较大时，请考虑适当将效率放一放。</p>
<p class="content">度量工具。当效率很重要时，第一步就是对系统进行性能监视，以确定其运行时间的分布状况。对程序进行性能监视的结果通常类似：多数的时间都消耗在少量的热点代码上，而余下的代码则很少执行（例如，在6.l节中，一个函数就占用了98%的运行时间）。性能监视可以帮助我们找到程序中的关键区域；对于其他区域，我们遵循有名的格言“没有坏的话就不要修”。与附录C中的运行时间开销模型类似的模型有助于程序员理解为什么某些特定的运算和函数的时间开销比较高。</p>
<p class="content">设计层面。在第6章中我们已看到，效率问题可以由多种方法来解决。只有在确信没有更好的解决方案时才考虑进行代码调优。</p>
<p class="content">双刃剑。使用if语句替换模运算有时候可以使速度加倍，有时候却对运行时间没什么影响。将函数转换为宏可以使某个函数速度加倍，却也可能使另一个函数的速度减慢为原来的万分之一。在进行“改进”之后，用具有代表性的输入来度量程序的效果是至关重要的。这样的故事不胜枚举，因此，我们必须重视Jurg Nievergelt对代码调优人员的警告：玩火者，小心自焚。</p>
<p class="content">上述讨论考虑了是否需要以及何时进行代码调优的问题。一旦决定了需要进行代码调优，余下的问题就是如何进行调优了。附录D包含了一系列有关代码调优的通用法则。我们前面提到的所有例子都可以用这些法则来解释。下面我来示范一下，法则的名称用楷体表示。</p>
<p class="content">Van Wyk的图形程序。Van Wyk的解决方案的一般性策略就是高效处理常见情况。在那个具体例子中他高速缓存了一些最常见类型的记录。</p>
<p class="content">问题1——整数取模。该解决方案利用等价的代数表达式，使用低开销的比较取代了高开销的取模运算。</p>
<p class="content">问题2——函数、宏和内联代码。通过使用宏替换函数来打破函数层次，这样几乎可以使速度提高一倍，但是进一步将代码写成内联的形式却看不到明显的改善。</p>
<p class="content">问题3——顺序搜索。使用哨兵来合并测试条件可以获得大约5％的加速。循环展开则可以得到大约56%的额外加速。</p>
<p class="content">问题4——计算球面距离。将笛卡儿坐标和经度、纬度存储在一起是修改数据结构的一个例子；使用开销较低的欧氏距离而不是角度距离属于利用等价的代数表达式。</p>
<p class="content">二分搜索。合并测试条件将每次内循环的数组比较次数从两次减少为一次；利用等价的代数表达式使得我们能够将上下限的表示方法转换为下限与增量表示法；循环展开将程序展开以消除所有的循环开销。</p>
<p class="content">迄今为止，我们进行代码调优的目的都是减少CPU时间。我们也可以将代码调优用于其他目的，比如减少分页或增加高速缓存命中率。除了减少运行时间以外，代码调优最常见的目的或许就是减少程序所需要的空间了。下一章将探讨空间的节省问题。</p>
<h3 class="thirdtitle" id="bw75">
<a href="part0000.xhtml#toc84">9.5 习题</a>
</h3>
<p class="content">1.对你自己写的某一个程序进行性能监视，然后设法使用本章中所描述的方法减少其热点的运行时间。</p>
<p class="content">2.本书网站上提供了那个在本章开始部分进行过性能监视的C程序，它实现了第13章中一个 C++程序的一个小子集。请尝试在你的系统上对其进行性能监视。除非你有一个特别高效的 malloc 函数，否则程序的绝大部分时间可能都会消耗在malloc上。请尝试一下通过实现诸如Van Wyk那样的结点缓存来减少程序的运行时间。</p>
<p class="content">3.“杂技”旋转算法的哪些特殊性质允许我们使用if语句而不是开销更高的while语句来替换取模运算？通过实验确定在什么情况下值得使用 while 语句来替换取模运算。</p>
<p class="content">4.若n是最大为数组大小的正整数，则下面的递归C函数将返回数组x[0..n-1]中的最大值：</p>
<p class="content">float arrmax(int n)</p>
<p class="content">{ if (n == 1)</p>
<p class="content_5">return x[0];</p>
<p class="content">else</p>
<p class="content_5">return max(x[n-1],arrmax(n-1));</p>
<p class="content">}若max为函数，它就可以在几毫秒之内找出具有n=10 000个元素的向量中的最大元素。若max为如下所示的C宏：</p>
<p class="content">#define max(a,b) ((a) &gt;(b) ? (a) : (b))</p>
<p class="content">则该算法花6秒钟的时间才能找出n=27个元素中的最大值，花12秒钟的时间才能找出n=28个元素中的最大值。试给出一个可以反映该糟糕结果的输入，并从数学上分析其运行时间。</p>
<p class="content">5.如果（违反规范说明）将各种不同的二分搜索算法应用于未排序的数组，结果会如何呢？</p>
<p class="content">6.C和C++库提供了字符分类函数（如isdigit、isupper及islower）来确定字符的类型。你会如何实现这些函数呢?</p>
<p class="content">7.给定一个非常长的字节序列（假设有十亿或万亿），如何高效地统计 1 的个数呢? （也就是说，在整个序列中有多少个位的值为1？）</p>
<p class="content">8.如何在程序中使用哨兵来找出数组中的最大元素?</p>
<p class="content">9.因为顺序搜索比二分搜索简单，所以对于较小的表来说通常顺序搜索更有效。另外，二分搜索的对数次比较说明，对于较大的表来说它要比顺序搜索的线性时间快一些。其平衡点取决于每种程序的调优程度。你能找到的最高和最低平衡点分别是多少？当两种程序的调优程度相同时，在你机器上的平衡点是多少?</p>
<p class="content">10.D.B.Lomet发现，散列法解决1 000个整数的搜索问题时可能比调优过的二分搜索效率更高。请实现一个快速的散列程序，并将它和调优过的二分搜索进行比较。从速度和空间方面比较，结论如何?</p>
<p class="content">11.20世纪60年代早期，Vic Berecz发现Sikorsky飞机的仿真程序的大部分运行时间都消耗在计算三角函数上了。进一步的观察表明，只有在角度为5度的整数倍时才计算这些函数。他应该如何减少运行时间?</p>
<p class="content">12.人们在调优程序时有时会从数学的角度考虑而不是从代码的角度考虑。为了计算下面的多项式：</p>
<p class="content_">y=a<span class="sub">n</span>
 x +a<span class="sub">n−</span>
 x <span class="super">−</span>
 +L+a x +an 1 n <span class="super">1</span>
 <span class="sub">1</span>
 <span class="super">1</span>
 <span class="sub">0</span>
</p>
<p class="content">如下的代码使用了2n次乘法。请给出一个更快的函数。</p>
<p class="content_5">y=a[0]xi =1</p>
<p class="content_5">for i = [1,n]</p>
<p class="content_7">xi = x * xi</p>
<p class="content_7">y = y + a[i]*xi</p>
<h3 class="thirdtitle" id="bw76">
<a href="part0000.xhtml#toc85">9.6 深入阅读</a>
</h3>
<p class="content">3.8节提到了Steve McConnell的《代码大全》一书。其中第28章讲述了“代码调优策略”，笼统综述了性能问题，详细描述了代码调优的方法；第29章对代码调优的法则做了很好的整理。</p>
<p class="content">本书的附录D提供了相关的代码调优法则，并描述了它们在本书中的应用。</p>
<h2 class="secondtitle" id="bw77">
<a href="part0000.xhtml#toc86">第10章 节省空间</a>
</h2>
<p class="content">你可能会跟我认识的几个人一样，读到这个题目的第一印象是：“多奇怪啊！”在过去艰苦的计算年代中，程序员受限于小容量的计算机，常常需要节省空间；但那样的年代已经一去不复返了。新的理念是：“这里1 GB，那里1 GB，不够就再扩内存。”这种观点确实有些道理——许多程序员都使用大容量的计算机，很少需要考虑从程序中节省空间。</p>
<p class="content">但时常努力地考虑一下空间紧凑的程序是很有利的。有时候这种思考会带来新的启示，使程序变得更加简单。节省空间的同时，我们通常会在运行时间上得到想要的副作用：程序变小后加载更快，也更容易填入高速缓存中；此外，需要操作的数据变少通常也意味着操作时间会减少。通过网络传送数据时所需要的时间通常直接与数据的规模成正比。即便对于价格低廉的内存来说，空间也可能很关键。那些小的机器（如玩具和家电中的那些）仍然只有非常小的内存。当使用巨型机来解决巨大的问题时，我们依然需要小心地使用内存。</p>
<p class="content">对其重要性有了认识之后，我们来看看节省空间的一些重要方法。</p>
<h3 class="thirdtitle" id="bw78">
<a href="part0000.xhtml#toc87">10.1 关键在于简单</a>
</h3>
<p class="content">简单性可以衍生出功能性、健壮性以及速度和空间。Dennis Ritchie 和 Ken Thompson最初在具有8 192个18位字的机器上开发出了Unix操作系统。他们在关于该系统的论文中说到“在系统及其软件方面，总是存在着相当严重的空间约束。如果同时对合理的效率和强大的能力提出要求，那么空间约束不仅具有经济上的意义，还会使设计更优雅一些。”</p>
<p class="content">20世纪50年代中期，当Fred Brooks为一家全国性的公司编写计算薪水的程序时，他发现了简化的威力。该程序的瓶颈出在肯塔基州收入所得税的表示上。税收在该州的法律条文中使用一个二维表表示，一维是收入，另一维是免税额。显式地存储该表需要几千个字的内存，比机器的容量大。</p>
<p class="content">Brooks所尝试的第一个方法是尝试找到一个匹配整个税表的数学函数。但是，税表参差不齐，无法用简单的函数近似。在了解到这个表是由不热衷数学函数的立法者创建的之后，Brooks查阅了肯塔基州立法机构的会议纪要，试图了解这个奇特的表的来源。他发现肯塔基州的州税是扣除联邦税之后剩余收入的简单函数。因此他的程序从现有的表中计算出联邦税，然后使用扣税后的剩余收入和仅占用几十个字内存的表来确定肯塔基州的州税。</p>
<p class="content">通过研究问题产生的背景，Brooks 用一个简单一些的问题替换了原始问题。原始问题似乎需要数千个字的数据空间，但修改过的问题却只需要微不足道的内存就可以解决。</p>
<p class="content">简单性还可以减少代码的长度。第3章描述了几个大型程序，使用合适的数据结构可以将其替换成较小的程序。在那些情况下，从更简单的视角去分析程序，可以使源代码的长度从几千行降低到几百行，或许还能同时将目标代码的规模减少一个数量级。</p>
<h3 class="thirdtitle" id="bw79">
<a href="part0000.xhtml#toc88">10.2 示例问题</a>
</h3>
<p class="content">20世纪80年代早期，我查询过一个在地理数据库中存储邻居的系统。一共有两千个邻居，编号范围为0~1 999，每个邻居在地图中用一个点来描述。该系统允许用户通过触摸输入板的方式访问其中的任意一个点。程序将选定的物理位置转换为0~199范围内的一对整数x和y（输入板大约四英尺见方，该程序的分辨率为1/4英寸），然后使用(x,y)对指出用户选中了2 000个点中的哪一个点（如果有的话）。因为在同一位置(x,y)不可能存在两个点，所以程序员仅需要考虑用200×200的点标识符数组表示地图的模块（点标识符是0~1 999的整数；如果该位置没有点，点标识符置为-1）。该数组的左下角大致如下所示，空的方格表示该位置没有点。在相应的地图上，点17位于(0,2)，点538位于(0,5)，第一列中其他4个可见的位置为空。</p>
<div class="bodypic_"><img alt="" src="../Images/image00214.jpeg" class="calibre3"/>
</div>
<p class="content">该数组很容易实现，也能实现快速的访问。程序员可以选择使用16位或32位来实现每个整数。如果选择32位整数的话，200×200=40 000个元素需要160 KB的空间，因此程序员选择了较短的16位表示法。从而数组占用80 KB，或者说512 KB内存空间的六分之一。在系统生命期的早期阶段那是没有什么问题的。但是随着系统的增长，空间就不够用了。程序员问我如何减少花在这个结构上的存储空间。你会给他怎样的建议呢?</p>
<p class="content">这是一个使用稀疏数据结构的绝好机会。这个例子很老，但我最近却遇到了一个相同的例子：在一台具有上百兆字节内存的计算机上表示一个具有100万个活跃项的10 000×10 000的矩阵。</p>
<p class="content">稀疏矩阵的一种浅显的表示法就是使用数组表示所有的列，同时使用链表来表示给定列中的活跃元素。为了使版面更美观，下图顺时针旋转了90°：</p>
<div class="bodypic_"><img alt="" src="../Images/image00215.jpeg" class="calibre3"/>
</div>
<p class="content">此图显示了第一列中的三个点：点17位于(0,2)，点538位于(0,5)，点1053位于(0,126)。第二列有两个点，第三列没有点。我们使用如下的代码搜索点(i,j)：</p>
<p class="content">for (p = colhead[i]; p != NULL; p = p-&gt;next) if p-&gt;row == j</p>
<p class="content_5">return p-&gt;pointnum</p>
<p class="content">return -1</p>
<p class="content">在最坏情况下查找某一数组元素要访问200个结点，但平均只要访问大约10个结点。</p>
<p class="content">这个结构使用了一个具有200个指针以及2 000条记录的数组，每条记录都有一个整数和两个指针。附录C中的空间开销模型告诉我们，这些指针将占用800个字节。如果我们为这些记录分配一个2 000元的数组，那么每条记录将占用12个字节，总计需要24 800个字节。（不过，如果我们使用该附录中所描述的默认malloc，那么每条记录将消耗48个字节，从而整个结构占用的空间将从最初的80 KB增加到96.8 KB。）</p>
<p class="content">程序员需要在一个不支持指针和结构的 Fortran 版本中实现该结构。因此，我们使用一个201元的数组来表示这些列，并用两个2 000元的并行数组表示这些点。下面给出了这三个数组，并用箭头表示出了最底部数组中的整数索引。（为与本书中的其他数组保持一致，Fortran数组以1为基数的下标已经改为使用以0为基数了。）</p>
<div class="bodypic_"><img alt="" src="../Images/image00216.jpeg" class="calibre3"/>
</div>
<p class="content">第i列中的点由数组row和pointnum中位于firstincol[i]和firstincol[i+1]-1之间的元素表示；虽然一共只有200个列，我们仍定义了firstincol[200]以满足上述条件。下面的伪代码用于确定位置(i,j)处的点：</p>
<p class="content">for k = [firstincol[i],firstincol[i+1])</p>
<p class="content_5">if row[k] == j</p>
<p class="content_7">return pointnum[k]</p>
<p class="content">return -1</p>
<p class="content">这个版本使用了两个2 000元的数组和一个201元的数组。程序员使用16位整数（总计8 402字节）准确地实现了这个结构。它要比使用完整的矩阵稍微慢些（平均来说大约需要访问结点10次）。即便如此，该程序依然可以很好地满足用户的需求。由于系统具有良好的模块结构，通过更改一些函数，该方法几小时之后就成功合并到了系统中。我们观察到运行时间没有明显变化，同时节省了非常宝贵的70 KB空间。</p>
<p class="content">该结构仍然很浪费空间，我们可以进一步节省空间。因为row数组的元素全部都小于200，所以其中的每个元素都可存储在一个单字节无符号char中，这使得空间压缩到了6 400个字节。如果点本身已经存储了行信息，我们甚至可以完全删除row数组：</p>
<p class="content">for k = [firstincol[i],firstincol[i+1])</p>
<p class="content_5">if point[pointnum[k]].row == j</p>
<p class="content_7">return pointnum[k]</p>
<p class="content">return -1</p>
<p class="content">这使得空间压缩为4 400个字节。</p>
<p class="content">在真实系统中，快速的查找时间非常关键，一方面是为了满足用户交互的需求，另一方面是因为其他函数需要通过同一个界面来查找点。如果运行时间不重要，并且这些点具有row和col字段，那么我们可以通过顺序搜索数组中的点，将最终的存储空间减少为0个字节。即使这些点没有那两个字段，该结构的空间也可以通过“关键字索引”压缩到4 000个字节：我们扫描一个数组，数组中的第i个元素包含有两个单字节的字段，用于提供点i的row和col值。</p>
<p class="content">此问题举例说明了数据结构方面的几个通用问题。该问题很经典：稀疏数组表示（所谓稀疏数组是指其中大多数项都具有同一值（通常为 0）的数组）。问题的解决方案在概念上很简单，实现起来也很容易。我们使用了许多节省空间的方法。我们不需要lastincol数组和firstincol配对，而是利用下面的事实：此列中的最后一个点刚好在下一列的第一个点之前，中间没有其他点。这是一个重新计算而非存储的普通例子。类似地，也不需要和row配对的col数组，因为我们只在firstincol数组中访问row，所以我们总是知道当前列。尽管row一开始是32位，但是我们不断地压缩其表示，先减少为16位并最终减少为8位。我们最初从记录着手，但最终还是转向了数组，以充分节省空间。</p>
<h3 class="thirdtitle" id="bw80">
<a href="part0000.xhtml#toc89">10.3 数据空间技术</a>
</h3>
<p class="content">尽管简化通常是解决问题的最容易的方法，但是对某些难一些的问题它就无能为力了。在本节中，我们将研究各种减少程序所需数据的存储空间的技术。在下一节中，我们将考虑减少执行期间保存程序时所用的内存。</p>
<p class="content">不存储，重新计算。如果我们在需要某一给定对象的任何时候，都对其进行重新计算而不保存，那么保存该对象所需的空间就可以急剧地减少。这跟取消点阵并每次重新执行顺序搜索的思想是完全一致的。质数表可以用一个检索质数性的函数来替代。此方法牺牲更多的运行时间来换取更少的空间。这种方法只适用于需要“存储”的对象可以根据其描述重新计算得到的情况。</p>
<p class="content">这一类“生成器程序”常用于在相同的随机输入上执行若干程序，其目的是比较程序的性能或者对正确性进行回归测试。取决于应用场合的不同，随机对象可能是具有随机生成的文本行的文件，也可能是具有随机产生的边缘的图形。我们不保存整个对象，只保存其生成器程序以及定义了该特定对象的随机种子。只需在访问它们时稍微多花点时间，庞大的对象就可以用较少的几个字节表示出来。</p>
<p class="content">PC软件的用户从CD-ROM或DVD-ROM中安装软件时，可能会面对这一类选择。“典型安装”可能会在可以快速读取的系统硬盘中保存几百兆字节的数据；而“最小化安装”将把那些文件保留在慢一些的设备中，但是不会占用磁盘空间。后一类安装在每次调用程序时，会花费更多的时间来读取数据，从而节省磁盘空间。</p>
<p class="content">对于许多跨网络运行的程序来说，在数据规模方面我们最关心的是传输数据需要花费的时间。有时我们会采纳“保存、不进行重新传输”的建议，通过本地缓存的方式减少需要传输的数据量。</p>
<p class="content">稀疏数据结构。10.2节曾介绍过这些结构。在3.1节中，我们将一个参差不齐的三维表保存在一个二维数组中，从而节省了空间。如果我们使用的关键字将作为索引存储到表中，那么就不需要存储关键字本身，而只需要存储其相关的属性，例如它被查看的次数。附录A的算法分类中给出了关键字索引技术的一些应用。在上述稀疏矩阵例子中，利用了firstincol数组的关键字索引技术允许我们在没有col数组的情况下进行索引。</p>
<p class="content">使用指针来共享大型对象（如长文本字符串）可以消除存储同一对象的众多副本所需的开销，但是程序员在修改共享对象时必须小心谨慎地确保该对象的所有拥有者都希望修改。我桌上的年鉴就使用了这种方法，它提供了从1821年到2080年的日历。年鉴没有列出260个不同的日历，而是给出了14个标准日历（对于任意一年而言，1月1日是星期几有7种可能，闰年还是非闰年有两种可能，两数相乘得到14）以及一个为260年中的每一年提供日历编号的表。</p>
<p class="content">一些电话系统将语音会话看作为稀疏结构以节省通信带宽。当某一方向上的音量下降到临界水平时，采用简洁的表示法来发送静音；节省下来的带宽可以用来传送其他的会话。</p>
<p class="content">数据压缩。信息理论告诉我们，可以通过压缩的方式对对象进行编码，以减少存储空间。例如，在稀疏矩阵的例子中，我们将表示行号的空间从32位压缩至16位，继而再压缩至8位。在个人电脑的早期阶段，我编写的一个程序在读写较长的十进制数字串时需要花费很多的时间。我利用整数 c=10×a＋b 对其进行了修改，将两个十进制数字a和b编码在一个字节（而不是直观上的两个字节）中。该信息可以通过以下两条语句进行解码：</p>
<p class="content">a = c ／ 10</p>
<p class="content">b = c ％ 10</p>
<p class="content">这个简单的方案将输入输出时间减少了一半，同时也将数值数据文件压缩到了一张软盘而不是两张软盘中。这一类编码可以减少存储单个记录所需要的空间，但是那些小的记录在编码和解码时可能要花费更多的时间（见习题6）。</p>
<p class="content">信息理论还指出，我们可以压缩通过某一通道（比如磁盘文件或网络）发送的记录流。可以以16位的精度和44 100Hz的采样频率来记录两个通道（立体声），从而实现CD质量的录音。使用这种表示方法时，一秒的声音需要176 400个字节。MP3标准能够将常见的声音文件（尤其是音乐）压缩到比这个值小很多的大小。习题10.10要求你度量一下表示文本、图像、声音等内容的几种常见格式的有效性。有些程序员为他们的软件构建了专用的压缩算法：13.8节概述了如何将一个具有75 000个英语单词的文件压缩到52 KB。</p>
<p class="content">分配策略。有时空间的使用方式比使用量更重要。例如，假设你的程序使用了大小相同的三个不同类型的记录x、y和z。在某些语言中，你的第一反应可能是为每种类型声明10 000个对象。但是如果你使用了10 001个x对象，而没有使用y和z，结果会如何呢? 虽然其他20 000个对象完全未使用，程序在用到第10 001个记录之后还是会溢出。动态分配通过在需要时才对记录进行分配的方式，避免了这一类明显的浪费。</p>
<p class="content">动态分配是说，只有在需要的时候才进行分配；可变长记录的策略是说，当确实需要请求某样东西时，我们应该根据需要量来请求。在以前 80 列记录的穿孔卡片时代，磁盘上有一半以上的字节空着是很常见的。可变长文件使用换行符来指示一行的结束，因此加倍了这一类磁盘的存储量。我曾经使用可变长记录使一个具有输入/输出瓶颈的程序的运行速度变为原来的三倍：最大记录长度是250，但平均只使用大约80个字节。</p>
<p class="content">垃圾回收。对废弃的存储空间进行回收再利用，从而那些不用的位就可以重新使用了。14.4节中的堆排序算法在两个逻辑数据结构上使用了共享空间技术，它们在不同的时间使用，但存储在相同的物理位置上。</p>
<p class="content">20世纪70年代早期，Brian Kernighan编写了一个旅行商程序，给出了另一种共享存储空间的方法：用两个150×150的矩阵（分别称为a和b）来表示点与点之间的距离，从而Kernighan知道它们的对角线上都是0值（a[i,i]=0），并且矩阵是对称的（a[i,j]=a[j,i]）。因此他让两个三角矩阵共享某一方阵c的空间，下图是其中的一个角落：</p>
<div class="bodypic_"><img alt="" src="../Images/image00217.jpeg" class="calibre3"/>
</div>
<p class="content">这样一来，Kernighan可以通过下面的代码引用a[i,j]：</p>
<p class="content">c[max(i,j),min(i,j)]</p>
<p class="content">类似地可以求出b，但是应该将min和max进行对调。从那时起，该表示法就已经在各种不同的程序中得到使用了。该技术使Kernighan的程序在一定程度上编写起来更困难，运行也稍微慢些，但是在一台具有30 000个字的机器上，将两个22 500个字的矩阵减少成一个是非常有意义的。如果矩阵是30 000×30 000的话，那么在今天具有1 GB内存的机器上，同样的改动可以取得相同的效果。</p>
<p class="content">在现代计算系统中，使用对高速缓存敏感的内存布局非常重要。虽然我研究这个理论已有许多年了，但是当我第一次使用某个多碟CD软件时，我仍然表现出了发自内心的赞赏。全国电话号码簿和全国地图使用起来非常方便，我很少需要替换 CD，除非我已从国家的一部分浏览到另一部分了。但是当我第一次使用两张盘的百科全书时，我发现交换CD太频繁了，于是转而使用老版本的只有一张CD的百科全书；内存布局对我的访问模式不敏感。答案2.4图示了三个具有截然不同的内存访问模式的算法的性能。我们将在13.2节看到一个应用，其中即使数组接触的数据比链表要多，它们也会比链表更快一些，这是因为它们的顺序内存访问和系统的高速缓存之间交互作用时效率很高。</p>
<h3 class="thirdtitle" id="bw81">
<a href="part0000.xhtml#toc90">10.4 代码空间技术</a>
</h3>
<p class="content">有时候空间的瓶颈不在于数据，而在于程序本身的规模。在过去的艰苦年代，我见到的图形程序通篇都是类似下面的代码：</p>
<p class="content">for i = [17,43] set(i,68)</p>
<p class="content">for i = [18,42] set(i,69)</p>
<p class="content">for j = [81,91] set(30,j)</p>
<p class="content">for j = [82,92] set(31,j)</p>
<p class="content">其中set(i,j)“点亮”屏幕位置(i,j)处的图形元素。使用适当的函数，例如用于绘制水平线的 hor 函数和绘制垂直线的 ver 函数，就可以使用如下所示的代码替换上面的代码：</p>
<p class="content">hor(17,43,68)</p>
<p class="content">hor(18,42,69)</p>
<p class="content">vert(81,91,30)</p>
<p class="content">vert(82,92,31)</p>
<p class="content">上述代码又可以用一个解释程序来替换，这个解释程序从类似下面的数组中读取命令：</p>
<p class="content">h 17 43 68</p>
<p class="content">h 18 42 69</p>
<p class="content">v 81 91 30</p>
<p class="content">v 82 92 31</p>
<p class="content">如果上面的代码仍然占用太多的空间，那么可以为命令（h、v或两个其他命令）分配两个位，并为后面的三个数（这些数是范围0~1023内的整数）各分配10个位。于是，上面的每一行都可以用一个32位的字来表示（当然，这种转换应该由程序来进行）。这种假设的情况揭示了用于节省代码空间的几种通用技术。</p>
<p class="content">函数定义。通过用函数替换代码中的常见模式可以简化上述程序，相应地也就减少了它的空间需求，并增加了其清晰性。这是一个“自底向上”设计的普通例子。尽管我们不能忽视自顶向下的方法，但是由良好的原始对象、组件和函数所给出的均一的视图可以使系统维护起来更加简单，同时也节省了空间。</p>
<p class="content">微软删除了很少使用的函数，将它的整个 Windows 系统压缩为更加紧凑的Windows CE，使其能在具有更小内存的“移动计算平台”上运行。更小的用户界面（UI）在窄屏幕的小型机器（范围从嵌入式系统到掌上电脑）上运行得很好，熟悉的界面对用户来说非常方便。更小的应用编程接口（API）使得系统对于Windows API程序员来说很熟悉（并且对于许多程序来说，即使不兼容，也非常接近）。</p>
<p class="content">解释程序。在图形程序中，我们用4字节的解释程序命令替换了一长行的程序文本。3.2 节描述了一个用于格式信函编程的解释程序，尽管它的主要目的是使编程和维护更加简单，但是它同时也减少了程序的空间。</p>
<p class="content">Kernighan和Pike在他们Practice of Programming一书（本书5.9节介绍过）的9.4节介绍了“解释程序、编译器和虚拟机”。他们列举了许多例子来支撑他们的结论：“虚拟机是以前的一个有趣想法，最近借助于Java和Java虚拟机（Java Virtual Machine,JVM）又重新流行起来了；对于高级语言编写的程序来说，它们很容易提供可移植的、高效的表示。”</p>
<p class="content">翻译成机器语言。在节省空间方面，大多数程序员都较少控制的是将源语言转换成机器语言。对编译器进行一些微小更改可以将Unix系统早期版本的代码空间减少5个百分点。作为最后的手段，程序员可能会考虑到将大型系统中的关键部分用汇编语言进行手工编码。这个高开销、易出错的过程仅能带来一点点好处；不过，该方法还是常常用于一些内存宝贵的系统，比如数字信号处理器。</p>
<p class="content">Apple Macintosh于1984年诞生，当时是一款令人称奇的机器。这款小小的计算机（128 KB RAM）具有令人震惊的用户界面和功能强大的软件集。设计小组预期将制造好几百万台这样的机器，并且只提供64 KB的ROM。通过谨慎的函数定义（包括泛化运算符、归并函数和删除功能特性）并使用汇编语言手工编码整个ROM程序，该小组将令人难以置信的众多系统功能集成到了一个极微小的ROM上。他们估计那些经过极度调优的代码（具有谨慎的寄存器分配和指令选择）的规模只有从高级语言编译过来的等价代码的一半（尽管那时编译器已经有了很大的改进）。紧凑的汇编代码运行起来也非常快。</p>
<h3 class="thirdtitle" id="bw82">
<a href="part0000.xhtml#toc91">10.5 原理</a>
</h3>
<p class="content">空间开销。如果程序使用的内存增加 10%，结果会怎样呢?在某些系统中，这一类增加不会产生什么开销：先前浪费的位现在又可以使用了。在一些非常小的系统中，程序可能根本就不能运行了：内存溢出。如果数据正在通过网络进行传输，那么传送所需的时间可能会增加10%。在一些缓存和分页系统中，运行时间可能会急剧增加，因为先前与CPU较接近的数据现在已经逆行到二级高速缓存、RAM或磁盘中了（见13.2节和答案2.4）。在着手降低空间开销之前，应该首先了解空间开销。</p>
<p class="content">空间的“热点”。9.4节描述了程序的运行时间通常如何聚集在某些热点上：少部分的代码却经常要占用大部分的运行时问。对于代码所需的内存来说则相反：无论一条指令执行了 10 亿次还是根本就没有执行，它需要的存储空间都一样（除非大部分的代码从来就没有交换到内存或小的高速缓存中）。事实上数据也可以具有热点：少数常见类型的记录经常要占用大部分的内存。例如，在稀疏矩阵的例子中，在512 KB内存的机器中，单个数据结构就要占用 15%的内存。如果使用一个只有 1/10 大小的结构替换它，会对系统产生重大的影响；而如果把一个只有l KB的结构缩小为原来的1%，所产生的影响基本可以忽略不计。</p>
<p class="content">空间度量。大多数系统都提供了性能监视器，它允许程序员观察程序运行时内存的使用情况。附录C描述了一个用C++语言编写的空间开销模型，该模型在与性能监视器结合使用时尤其有帮助。各种专用工具有时也会有所帮助。当程序开始变得不可思议的庞大时，Doug McIlroy将连接程序（linker）的输出和源文件合并显示，以确定每一行耗费了多少个字节（有些宏会扩展成几百行的代码）；这样他就可以裁减目标代码了。有一次我通过观看由内存分配程序返回的内存块电影（“算法动画”），发现了程序中的内存泄漏。</p>
<p class="content">折中。有时程序员必须牺牲程序的性能、功能或可维护性以获得内存，这样的工程决策应该在所有可选办法都研究过之后才能做出。本章中的几个例子介绍了减少空间是如何对其他因素产生积极影响的。在1.4节中，位图数据结构允许一组记录保存在内存中而不是磁盘中，从而将运行时间从几分钟减少到几秒钟，代码也从几百行减少为几十行。出现这种情况的唯一原因是原先的解决方案远非最佳。但是我们这些技术还不够精湛的程序员常常会发现自己的代码就处于这种状态。在放弃任何希望得到的特性之前，我们应该努力寻找能够改善解决方案各方面性能的方法。</p>
<p class="content">与环境协作。编程环境对于程序的空间效率具有重要影响。重要的环境因素包括编译器和运行时系统所使用的表示方式、内存分配策略以及分页策略。类似附录C的空间开销模型有助于确保我们不会向相反的方向努力。</p>
<p class="content">使用适合任务的正确工具。我们已经学习过四种节省数据空间的技术（重新计算、稀疏结构、信息理论以及分配策略）、三种节省代码空间的技术（函数定义、解释程序以及翻译）和一条最重要的原则（简单性）。当内存很关键时，请务必考虑所有可能的选项。</p>
<h3 class="thirdtitle" id="bw83">
<a href="part0000.xhtml#toc92">10.6 习题</a>
</h3>
<p class="content">1.20世纪70年代末期，Stuart Feldmen<span id="ref40">
<a href="part0008.xhtml#annot40">[14]</a>
</span>
 构建了一个Fortran 77编译器，它刚好能装入64 KB的代码空间。为了节省空间，他将一些关键记录中的整数压缩存储到4位的字段中。在去除该处理并将这些字段保存到 8 位中时，他发现尽管数据空间增加了数百个字节，但是整个程序的大小却下降了好几千个字节。为什么?</p>
<p class="content">2.如何编写程序来构建10.2节中所描述的稀疏矩阵数据结构？你能够为该任务找出简单但空间效率很高的其他数据结构吗?</p>
<p class="content">3.你的系统总共有多大的磁盘空间？当前可用的有多少？RAM 有多大？RAM 中一般有多少是可用的？你可以度量一下系统中各个高速缓存的大小吗？</p>
<p class="content">4.请研究一下非计算机应用（比如年鉴以及其他参考书）中的数据，说明如何进行空间节省。</p>
<p class="content">5.在早期的编程生活中，Fred Brooks还面临着另外一个问题：在小型计算机中表示一个大型的表（不在本书10.1节的讨论范围内）。他无法在数组中存储整个表，因为那样的话每一个表项只能分配到很少的几个位的空间（实际上，每个表项只能使用一个十进制数字——前面已经交代过这是在早些年的时候！）。他采用的第二种方法是利用数值分析找出匹配该表的函数。他得到了一个非常接近于真实表的函数（每一项都和真实的表项相差无几），并且该函数需要的内存总量也可忽略不计。但是合法的约束意味着这样的近似还不够好。Brooks 如何在有限的空间内获得所需要的精度呢?</p>
<p class="content">6.在10.3节中对数据压缩的讨论曾提及使用／和%运算解码10×a＋b的问题。试探讨使用逻辑运算或查表来替换那些运算时所涉及的时间和空间折中。</p>
<p class="content">7.在常见类型的性能监视工具中，程序计数器的值是按常规的方式采样的，譬如9.1节中的例子。请设计一个存储这些值的数据结构，要求该结构的时间和空间效率都比较高并且能够提供有用的输出。</p>
<p class="content">8.浅显的数据表示方法为日期（MMDDYYYY）分配了 8 个字节的空间，为社会保障号（DDD-DD-DDDD）分配了9个字节的空间，为名字分配了25个字节（其中姓14个字节、名10个字节、中间名1个字节）的空间。如果空间紧缺，你该如何减少这些需求呢？</p>
<p class="content">9.将在线英语字典压缩得尽可能小。统计空间时，请同时度量数据文件以及解释该数据的程序。</p>
<p class="content">10.原始声音文件（如.wav）可以压缩成.mp3文件，原始图像文件（如.bmp）可以压缩成.gif或.jpg文件，原始视频文件（如.avi）可以压缩成.mpg文件。试针对这些文件格式进行实验，以评估其压缩效果。这些专用的压缩格式与通用的方案 （如gzip）相比效果如何?</p>
<p class="content">11.一位读者发现：“对于现代程序，庞大的常常不是你所编写的代码，而是你所使用的代码”。请研究一下你的程序，看看连接之后程序有多大。如何节省其空间?</p>
<h3 class="thirdtitle" id="bw84">
<a href="part0000.xhtml#toc93">10.7 深入阅读</a>
</h3>
<p class="content">Fred Brooks所著的《人月神话》一书的20周年纪念版于1995年由Addison-Wesley出版。它重印了原书中一些令人赏心悦目的短文，同时也添加了几篇新的短文，其中包括比较有影响力的“没有银弹——软件工程中的根本和次要问题”。该书第 9 章的标题是“削足适履”，它侧重强调在大型项目中对空间进行管理控制。他提出了一些重要的问题，如规模预算、功能说明以及用空间换取功能或时间。</p>
<p class="content">本书8.8节所引用的图书中，许多都描述了以空间有效性算法和数据结构为基础的科学技术。</p>
<h3 class="thirdtitle" id="bw85">
<a href="part0000.xhtml#toc94">10.8 巨大的节省（边栏）</a>
</h3>
<p class="content">在20世纪80年代早期，Ken Thompson构建了一个两阶段的程序，用于解决给定条件下国际象棋的残局问题，比如一个王和两个象对一个王和一个马（此程序与Thompson和Joe Condon开发的前世界计算机冠军Belle截然不同）。该程序的学习阶段通过从所有可能的“将死”状态向前回溯来计算所有可能的走法的距离，计算机科学家将这种方法称为动态规划，而国际象棋专家则称之为回溯分析。由此得到的数据库使程序对于给定的局面无所不晓。所以在游戏阶段，它对残局下得非常出色。国际象棋专家用下面的词汇来描绘它所玩的游戏：“复杂、流畅、漫长且困难”以及“难以忍受的缓慢和神秘”，它颠覆了既定的国际象棋信仰。</p>
<p class="content">显式地存储所有可能的棋盘在空间上的开销是惊人的。因此Thompson将棋盘的编码用作关键字，对存储棋盘信息的磁盘文件进行索引；文件中的每一条记录都包含了12位，包括从该位置开始到将死的距离。因为棋盘上有64个格子，因此五个固定的棋子位置可以编码为0~63的5个整数，这些整数给出了每个棋子的位置。由此得到的关键字具有30位，这就意味着数据库中的表有2<span class="super">30</span>
 （或者说大约10.7亿）个12位的记录，这已经超过了当时可用的磁盘容量。</p>
<p class="content">Thompson 的关键发现在于：下图中关于任何虚线对称的棋盘具有相同的值，没有必要在数据库中进行重复。</p>
<div class="bodypic_"><img alt="" src="../Images/image00218.jpeg" class="calibre3"/>
</div>
<p class="content">因此他的程序假设白王位于十个已编号方格中的一个；对于任意的棋盘，至多连续三次镜像就可以摆放成这种形式。这一标准化使得磁盘文件的大小减小到10×64<span class="super">4</span>
 或10 ×2<span class="super">24</span>
 个12位的记录。Thompson进一步观察发现：因为黑王不能和白王相邻，因此对于两个王来说只有454种合法的棋盘位置，其中白王位于上述已标记的十个方格中的一个。利用这一事实，他的数据库缩小到了454×64<span class="super">3</span>
 或大约12 100万条12位的记录，这样就可以保存到一张（专用的）磁盘中了。</p>
<p class="content">尽管 Thompson 知道他的程序只会有一个副本，他还是将文件压缩到了一张磁盘上。Thompson利用数据结构的对称性使所需磁盘空间减少为原来的八分之一，这对整个系统的成功而言是很关键的。节省空间的同时也减少了程序的运行时间：通过减少在残局程序中需要分析的位置数，将学习阶段的时间从好多个月减少到了几周的时间。</p>
<hr class="calibre2"/>
<p class="noindent" id="annot27">
<a href="part0008.xhtml#ref27">[1].</a>
 Andrew Appel，计算机科学家，ACM会士，普林斯顿大学教授。他在编译理论方面有较深造诣。著有“虎书”之称的《现代编译原理：C语言描述》（人民邮电出版社，2006）。——编者注</p>
<p class="noindent" id="annot28">
<a href="part0008.xhtml#ref28">[2].</a>
 “大O”表示法O(n<span class="super">2</span>
 )可以理解为“正比于n<span class="super">2</span>
 ”，15n<span class="super">2</span>
 +100n和n<span class="super">2</span>
 /2-10都是O(n<span class="super">2</span>
 )。更形式化一些， f(n)=O(g(n))意味着对某个常数c和足够大的n，有 f(n)&lt;cg(n)成立。该表示法的形式化定义可以在算法设计或者离散数学的教科书上找到。8.5节说明了该表示法与程序设计的相关性。</p>
<p class="noindent" id="annot29">
<a href="part0008.xhtml#ref29">[3].</a>
 本章讨论的主题我是从Raj Reddy和Allen Newell的论文“Multiplicative speedup of systems”中学到的。（该论文发表于Perspectives on Computer Science，由A.K.Jones编辑并由Acadamic出版社于1977年出版。）他们的论文描述了不同设计层面上的加速，对硬件和系统软件上的加速描述得尤其详细。（Raj Reddy为1994年图灵奖得主，李开复的导师。Allen Newell为1975年图灵奖得主。——编者注）</p>
<p class="noindent" id="annot30">
<a href="part0008.xhtml#ref30">[4].</a>
 Gordon Bell（1934—），著名计算机科学家，美国科学院、工程院院士，ACM和IEEE会士。他为DEC公司设计了PDP计算机的多个版本，并领导开发了VAX计算机。冯·诺依曼奖得主。——编者注</p>
<p class="noindent" id="annot31">
<a href="part0008.xhtml#ref31">[5].</a>
 Butler Lampson（1943—），著名计算机科学家，1992年图灵奖得主，ACM会士，现为微软件研究院院士和MIT兼职教授。他是Xerox PARC创始人之一，参与开发了激光打印机、以太网等革命性技术。——编者注</p>
<p class="noindent" id="annot32">
<a href="part0008.xhtml#ref32">[6].</a>
 Robert Martin，著名软件工程师和技术顾问。ObjectMentor公司创始人和总裁。曾任C++ Report杂志的主编。撰写了名著《敏捷软件开发：原则、模式与实践》（有Java及C#版，人民邮电出版社， 2007）。——编者注</p>
<p class="noindent" id="annot33">
<a href="part0008.xhtml#ref33">[7].</a>
 Peter Weinberger，著名计算机科学家，现在Google任职。他是Awk语言的设计者之一（Awk中的w），曾任贝尔实验室计算机科学研究部主任。——编者注</p>
<p class="noindent" id="annot34">
<a href="part0008.xhtml#ref34">[8].</a>
 1纳秒=10<span class="super">-9</span>
 秒，1纳世纪=10<span class="super">-9</span>
 ×100年=10<span class="super">-7</span>
 年。——审校者注</p>
<p class="noindent" id="annot35">
<a href="part0008.xhtml#ref35">[9].</a>
 Andrey Kolmogorov（1903—1987），20世纪最伟大的前苏联数学家之一，享有世界声誉，在概率、拓朴、计算复杂性、力学等诸多领域都有重要贡献。1980年获沃尔夫奖。——编者注</p>
<p class="noindent" id="annot36">
<a href="part0008.xhtml#ref36">[10].</a>
 该书中译版已由上海财经大学出版社出版，中文书名《统计陷阱》。——编者注</p>
<p class="noindent" id="annot37">
<a href="part0008.xhtml#ref37">[11].</a>
 该书英文影印版已由清华大学出版社引进出版，中文书名为《数据结构与算法》。——编者注</p>
<p class="noindent" id="annot38">
<a href="part0008.xhtml#ref38">[12].</a>
 该书第2版英文影印版已由高等教育出版社引进出版，中文书名为《算法导论》。——编者注</p>
<p class="noindent" id="annot39">
<a href="part0008.xhtml#ref39">[13].</a>
 Guy Steele，著名计算机科学家，ACM会士，美国工程院院士，现为Sun研究院院士。他与Sussman合作设计了Scheme语言，参与设计了Java语言，也是ECMAScript、Fortran、Common Lisp标准委员会的成员。他还与Richard Stallman 合作开发了Emacs。——编者注</p>
<p class="noindent" id="annot40">
<a href="part0008.xhtml#ref40">[14].</a>
 Stuart Feldmen，著名程序员，IEEE和ACM会士。现为Google工程副总裁。他是make的开发者，也是第一个Fortran 77编译器的作者。2007年曾任ACM主席。——编者注</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0007.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0009.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
