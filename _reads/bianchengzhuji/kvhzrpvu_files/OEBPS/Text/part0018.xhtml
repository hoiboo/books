<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>部分习题答案</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc142">部分习题答案</a>
</h1>
<p class="content_1">第1章答案</p>
<p class="content">1.下面的C程序使用C标准库函数qsort来排序一个整数文件。</p>
<p class="content">int intcomp(int *x,int *y)</p>
<p class="content">{ return *x - *y; }</p>
<p class="content">int a[1000000];</p>
<p class="content">int main(void)</p>
<p class="content">{ int i,n=0;</p>
<p class="content_4">while (scanf("%d",&amp;a[n]) != EOF)</p>
<p class="content_5">n++;</p>
<p class="content_4">qsort(a,n,sizeof(int),intcomp);</p>
<p class="content_4">for (i = 0; i &lt; n; i++)</p>
<p class="content_5">printf("%d\n",a[i]);</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">下面这个C++程序使用C++标准模板库中的set容器完成相同的任务。</p>
<p class="content">int main(void)</p>
<p class="content">{ set&lt;int&gt; S;</p>
<p class="content_4">int i;</p>
<p class="content_4">set&lt;int&gt;::iterator j;</p>
<p class="content_4">while (cin &gt;&gt; i)</p>
<p class="content_5">S.insert(i);</p>
<p class="content_4">for (j = S.begin(); j != S.end(); ++j)</p>
<p class="content_5">cout &lt;&lt; *j &lt;&lt; "\n";</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">答案3概述了上面两个程序的性能。</p>
<p class="content">2.下面的函数使用常量来设置、清除以及测试位值：</p>
<p class="content">#define BITSPERWORD 32</p>
<p class="content">#define SHIFT 5</p>
<p class="content">#define MASK 0x1F</p>
<p class="content">#define N 10000000</p>
<p class="content">int a[1 + N/BITSPERWORD];</p>
<p class="content">void set(int i) {　　　　　　a[i&gt;&gt;SHIFT] |=　(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">void clr(int i) {　　　　　　a[i&gt;&gt;SHIFT] &amp;= ～(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">int test(int i){ return a[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">3.下面的C代码使用答案2 中定义的函数来实现排序算法。</p>
<p class="content">int main(void)</p>
<p class="content">{ int i;</p>
<p class="content_5">for (i = 0; i &lt; N; i++)</p>
<p class="content_7">clr(i);</p>
<p class="content_5">while (scanf("%d",&amp;i) != EOF)</p>
<p class="content_7">set(i);</p>
<p class="content_5">for (i = 0; i &lt; N; i++)</p>
<p class="content_7">if (test(i))</p>
<p class="content_8">printf("%d\n",i);</p>
<p class="content_5">return 0;</p>
<p class="content">}</p>
<p class="content">我使用答案4中的程序生成了一个包含100万个不同正整数的文件，其中每个正整数都小于1 000万。下表列出了使用系统命令行排序、答案1中的C++和C程序以及位图代码对这些整数进行排序的开销：</p>
<div class="pic_"><img alt="" src="../Images/image00253.jpeg" class="calibre3"/>
</div>
<p class="content">第一行是总时间，第二行减去了读写文件所需的10.2秒输入/输出时间。尽管通用C++程序所需的内存和CPU时间是专用C程序的50倍，但是代码量仅有专用C程序的一半，而且扩展到其他问题也容易得多。</p>
<p class="content">4.见第12章，尤其是习题12.8。下面的代码假定randint(l,u)返回l..u中的一个随机整数。</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">x[i] = i</p>
<p class="content">for i = [0,k)</p>
<p class="content_5">swap(i,randint(i,n-1))</p>
<p class="content_5">print x[i]</p>
<p class="content">其中swap函数的作用是交换x中的两个元素。有关randint函数的详细讨论见12.1节。</p>
<p class="content">5.使用位图表示1 000万个数需要1 000万个位，或者说125万字节。考虑到没有以数字0或1打头的电话号码，我们可以将内存需求降低为100万字节。另一种做法是采用两趟算法，首先使用5 000 000/8=625 000个字的存储空间来排序0~4 999 999之间的整数，然后在第二趟排序5 000 000~9 999 999的整数。k趟算法可以在kn的时间开销和n/k的空间开销内完成对最多n个小于n的无重复正整数的排序。</p>
<p class="content">6.如果每个整数最多出现 10 次，那么我们就可以使用 4 位的半字节来统计它出现的次数。利用习题5的答案，我们可以使用10 000 000/2个字节在1趟内完成对整个文件的排序，或使用10 000 000/2k个字节在k趟内完成对整个文件的排序。</p>
<p class="content">9.借助于两个额外的n元向量from、to和一个整数top，我们就可以使用标识来初始化向量data[0..n-l]。如果元素data[i]已初始化，那么from[i]&lt;top并且to[from[i]] = i。因此，from是一个简单的标识，to和top一起确保了from中不会被写入内存里的随机内容。下图中data的空白项未被初始化：</p>
<div class="bodypic_"><img alt="" src="../Images/image00254.jpeg" class="calibre3"/>
</div>
<p class="content">变量top初始为0，下面的代码实现对数组元素i的首次访问：</p>
<p class="content">from[i] = top</p>
<p class="content">to[top] = i</p>
<p class="content">data[i] = 0</p>
<p class="content">top++</p>
<p class="content">本习题和答案来自 Aho、Hopcroft 和 Ullman 编写的 Design and Analysis of Computer Algorithms<span id="ref63">
<a href="part0018.xhtml#annot63">[1]</a>
</span>
 （Addison-Wesley出版社1974年出版）中的习题2.12。该习题结合了关键字索引和巧妙的标识方法，适用于矩阵和向量。</p>
<p class="content">10.商店将纸质订单表格放在10×10的箱数组中，使用客户电话号码的最后两位作为散列索引。当客户打电话下订单时，将订单放到适当的箱中。当客户来取商品时，销售人员顺序搜索对应箱中的订单——这就是经典的“用顺序搜索来解决冲突的开放散列”。电话号码的最后两位数字非常接近于随机，因此是非常理想的散列函数，而最前面的两位数字则很不理想——为什么？一些市政机关使用类似的方案在记事本中记录信息。</p>
<p class="content">11.两地的计算机原先是通过微波连接的，但是当时测试站打印图纸所需的打印机却非常昂贵。因此，该团队在主厂绘制图纸，然后拍摄下来并通过信鸽把35 毫米的底片送到测试站，在测试站进行放大并打印成图片。鸽子来回一次需要45分钟，是汽车所需时间的一半，并且每天只需要花费几美元。在项目开发的16个月中，信鸽传送了几百卷底片，仅丢失了两卷（当地有鹰，因此没有让信鸽传送机密数据）。由于现在打印机比较便宜，因此可以使用微波链路解决该问题。</p>
<p class="content">12.根据该传闻，前苏联人用铅笔解决了这个问题。有关这个真实故事的背景请查看www.spacepen.com。Fisher Space Pen公司成立于1948年，其书写设备被俄国航天局、水底探测人员和喜马拉雅登山探险队使用过。</p>
<p class="content_1">第2章答案</p>
<p class="content">A.我们从表示每个整数的32位的视角来考虑二分搜索。算法的第一趟（最多）读取40亿个输入整数，并把起始位为0的整数写入一个顺序文件，把起始位为1的整数写入另一个顺序文件。</p>
<div class="bodypic_"><img alt="为0的位当前输入 0/1探测为1的位" src="../Images/image00255.jpeg" class="calibre3"/>
</div>
<p class="content">这两个文件中，有一个文件最多包含20亿个整数,我们接下来将该文件用作当前输入并重复探测过程，但这次探测的是第二个位。如果原始的输入文件包含 n 个元素，那么第一趟将读取 n 个整数，第二趟最多读取 n/2 个整数，第三趟最多读取n/4个整数，依此类推，所以总的运行时间正比于n。通过排序文件并扫描，我们也能够找到缺失的整数，但是这样做会导致运行时间正比于n log n。本习题是伊利诺伊大学的Ed Reingold给出的一道测验题。</p>
<p class="content">B.见2.3节。</p>
<p class="content">C.见2.4节。</p>
<p class="content">1.为了找出给定单词的所有变位词，我们首先计算它的标识。如果不允许进行预处理，那么我们只能顺序读取整个字典，计算每个单词的标识并比较两个标识。如果允许进行预处理，我们可以在一个预先计算好的结构中执行二分搜索，该结构中包含按标识排序的（标识，单词）对。Musser和 Saini在他们的STL Tutorial and Reference Guide<span id="ref64">
<a href="part0018.xhtml#annot64">[2]</a>
</span>
 （Addison-Wesley出版社1996年出版）一书的第12章~第15章实现了几个变位词程序。</p>
<p class="content">2.二分搜索通过递归搜索包含半数以上整数的子区间来查找至少出现两次的单词。</p>
<p class="content">我最初的解决方案不能保证每次迭代都将整数数目减半，所以log<span class="sub">2</span>
 n趟的最坏情况运行时间正比于n log n。Jim Saxe经过观察发现，该搜索用不着考虑过多的重复元素，从而可以把运行时间缩短为线性时间。如果他的搜索程序知道当前范围内的m个整数中一定有重复元素，那么程序只会在当前工作磁带上存储m+1个整数，此后过来的整数将会被丢弃。虽然他的方法经常会忽略输入变量，但其策略却足以确保至少能找到一个重复元素。</p>
<p class="content">3.下面的“杂技”代码将x[n]向左旋转rotdist个位置。</p>
<p class="content">for i = [0,gcd(rotdist,n))</p>
<p class="content_5">/* move i-th values of blocks */</p>
<p class="content_5">t = x[i]</p>
<p class="content_5">j = i</p>
<p class="content_5">loop</p>
<p class="content_7">k = j + rotdist</p>
<p class="content_7">if k &gt;= n</p>
<p class="content_8">k -= n</p>
<p class="content_7">if k == i</p>
<p class="content_8">break</p>
<p class="content_7">x[j] = x[k]</p>
<p class="content_7">j = k</p>
<p class="content_5">x[j] = t</p>
<p class="content">rotdist 和 n 的最大公约数是所需的置换次数（用近世代数术语来说，也就是旋转产生的置换群的陪集个数）。</p>
<p class="content">下一个程序来自Gries的Science of Programming一书的18.1节，它假设函数swap (a,b,m)的功能是交换x[a..a+m-1]和x[b..b+m-l]。</p>
<p class="content">if rotdist == 0 || rotdist == n</p>
<p class="content_5">return</p>
<p class="content">i = p = rotdist</p>
<p class="content">j = n - p</p>
<p class="content">while i != j</p>
<p class="content_5">/* invariant:</p>
<p class="content_7">x[0..p-i ] in final position</p>
<p class="content_7">x[p-i..p-1 ] = a (to be swapped with b)</p>
<p class="content_7">x[p..p+j-1] = b (to be swapped with a)</p>
<p class="content_7">x[p+j..n-1 ] in final position</p>
<p class="content_5">*/</p>
<p class="content_5">if i &gt; j</p>
<p class="content_7">swap(p-i,p,j)</p>
<p class="content_7">i -= j</p>
<p class="content_5">else</p>
<p class="content_7">swap(p-i,p+j-i,i)</p>
<p class="content_7">j -= i</p>
<p class="content">swap(p-i,p,i)</p>
<p class="content">有关循环不变式的描述见第4章。</p>
<p class="content">该代码跟下面这段（虽然慢但是正确的）计算i和j的最大公约数的欧几里得算法是同构的（代码假设输入都不为零）。</p>
<p class="content">int gcd(int i,int j)</p>
<p class="content_5">while i != j</p>
<p class="content_7">if i &gt; j</p>
<p class="content_8">i -= j</p>
<p class="content_7">else</p>
<p class="content_8">j -= i</p>
<p class="content_5">return i</p>
<p class="content">Gries和Mills在康奈尔大学计算机科学技术报告81-452的“交换部分”研究了所有三种旋转算法。</p>
<p class="content">4.我在400 MHz的Pentium Ⅱ机器上运行了所有三种算法，运行时把n固定为1 000 000，并使旋转距离从1变化到50。下图绘制了在每个数据集上50次运行的平均时间：</p>
<div class="bodypic_"><img alt="杂技算法平均每个元素所需的时间（以纳秒为单位） 求逆算法块交换算法旋转距离" src="../Images/image00256.jpeg" class="calibre3"/>
</div>
<p class="content">求逆代码的运行时间比较一致，约为每个元素58纳秒,仅当旋转距离模8余4时跳到约66纳秒（这可能跟32字节的缓存大小有关）。块交换算法开始时开销最高（可能是由交换单元素块的函数调用引起的），但是良好的高速缓存性能使得旋转距离大于 2 时该算法是最快的算法。杂技算法开始时开销最低，但是由于其高速缓存性能很差（从每一个32字节的高速缓存线中访问单个元素），当旋转距离为8时所需时间将近200纳秒。杂技算法的时间在190纳秒左右浮动，偶尔会有所下降（当旋转距离为1 000时，它的运行时间会降到105纳秒，然后马上又恢复到190）。20世纪80年代中期，当旋转距离设置为页面大小时，这一代码使得页面的性能不稳定。</p>
<p class="content">6.名字的标识是其按键编码，所以“LESK*M*”的标识是“5375*6*”。为了在字典中找出错误的匹配，我们用按键编码标识每个名字，并根据标识排序（当标识相同时根据名字排序），然后顺序读取排序后的文件并输出具有不同名字的相同标识。为了检索出给定按钮编码的名字，我们可以使用一种包含标识和其他数据的结构。尽管我们可以对该结构排序，然后用二分搜索查询按键编码；实际系统往往使用散列技术或数据库系统。</p>
<p class="content">7.为了转置行矩阵，Vyssotsky为每条记录插入列号和行号，然后调用系统的磁带排序程序先按列排序再按行排序，最后使用另一个程序删除列号和行号。</p>
<p class="content">8.该问题的啊哈!灵机一动是：当且仅当包含k个最小元素的子集之和不超过t时，总和不超过t的k元子集是存在的。可以通过排序原始集合，在正比于n log n的时间内找到该子集；也可以使用选择算法（见答案11.9），在正比于n的时间内找到该子集。当Ullman将这道题作为课堂作业布置时，学生们不仅设计出了上述运行时间的算法，还设计出了时间复杂度为O(n log k)、O(nk)、O(n <span class="super">2</span>
 )和O(n<span class="super">k</span>
 )的算法。</p>
<p class="content">你能否给出对应于这些运行时间的自然算法?</p>
<p class="content">10.爱迪生在灯泡壳中灌满了水，然后将这些水倒入一个具有刻度的圆柱体中。（如果你注意提示可能就会发现，阿基米德也使用水来计算体积；他在获得啊哈！灵机一动后大喊“我发现了！”来庆祝。）</p>
<p class="content_1">第3章答案</p>
<p class="content">1.税收表格中的每一项都包含三个值：该等级的下界、基本税收以及超出下界的税率。通过在表中增加一个具有“无限”下界的最终哨兵项，我们可以使顺序搜索代码更易编写、速度更快（见9.2节）；当然也可以使用二分搜索。这些方法能够用于任何分段线性函数。</p>
<p class="content">3.印刷体字母“I”</p>
<p class="content">XXXXXXXXX</p>
<p class="content">XXXXXXXXX</p>
<p class="content">XXXXXXXXX</p>
<p class="content">XXX</p>
<p class="content">XXX</p>
<p class="content">XXX</p>
<p class="content">XXX</p>
<p class="content">XXX</p>
<p class="content">XXX</p>
<p class="content">XXXXXXXXX</p>
<p class="content">XXXXXXXXX</p>
<p class="content">XXXXXXXXX</p>
<p class="content">可以编码为</p>
<p class="content">3 lines 9 x</p>
<p class="content">6 lines 3 blank 3 x 3 blank</p>
<p class="content">3 lines 9 x</p>
<p class="content">或者更为紧凑的格式</p>
<p class="content">3 9 x</p>
<p class="content">6 3 b 3 x 3 b</p>
<p class="content">3 9 x</p>
<p class="content">4.为了求出两个日期之间的天数，我们需要计算这两个日期在相应年份中的编号，用后者减去前者（可能需要借助于具体的年份），然后加上年份之差的365倍，最后再为每个闰年加上1。为了求出给定的日期是周几，我们需要计算给定日期和一个已知的周日之间的天数，然后用模运算将其转化为周几。为了生成给定年份中某个月的日历，我们需要知道该月有多少天（注意要正确处理二月份）以及该月的第一天是周几。Dershowitz和Reingold专门写了一本Calendrical Calculation（s 剑桥大学出版社1997年出版）。</p>
<p class="content">5.由于对单词的比较是从右向左进行的，所以将单词按相反顺序（从右到左）存储可能需要付出一些代价。为了表示后缀序列，我们可以使用二维字符数组（通常比较浪费）或者用终止字符分隔后缀的一维字符数组，也可以使用带有单词指针数组的字符数组。</p>
<p class="content">6.Aho、Kernighan和Weinberger在AWK Programming Language（Addison-Wesley出版社1988年出版）一书的第101页给出了一个9行的程序来生成格式信函。</p>
<p class="content_1">第4章答案</p>
<p class="content">1.为了证明程序不会出现溢出错误，我们在不变式中添加条件0≤l≤n和-1≤u&lt;n，这样我们就可以限定 l+u 的范围了。这两个条件还可以用于证明不会访问数组边界之外的元素。如果像9.3节一样定义假想的边界元素x[-1]和x[n]，那么我们就能将mustbe (l,u)形式化地定义为x[l-1]&lt;t和x[u+1]&gt;t。</p>
<p class="content">2.见9.3节。</p>
<p class="content">5.有关这个著名的未解决数学问题的介绍可参考B.Hayes在1984年1月《科学美国人》的计算机娱乐专栏中发表的“On the ups and downs of hailstone numbers”一文。如果想进一步讨论技术问题，请参考J.C.Lagarias在1985年1月的《美国数学月刊》上发表的“The 3x+1 problem and its generalizations”一文。在本书出版之际， Lagarias在www.research.att.com/~jcl/3x+1.html上给出了长达30页的参考文献，其中大约有100篇提到了该问题。</p>
<p class="content">6.由于每一步都使得罐中的豆子减少 1 粒，所以该过程能够终止。我们每一步都从咖啡罐中拿掉零个或两个白豆，所以白豆个数的奇偶性保持不变。因此，当且仅当罐中最初的白豆个数为奇数时，最后留下的豆子才可能是白色的。</p>
<p class="content">7.构成梯级的线段在 y 方向上是递增的，因此我们可以通过二分搜索来找到包含给定点的两条线段。搜索中的基本比较说明了点在给定线段的下方、里面还是上方。应该如何编写该函数呢?</p>
<p class="content">8.见9.3节。</p>
<p class="content_1">第5章答案</p>
<p class="content">1.编写大型程序时，我为全局变量使用较长的名字（10个或20个字符）。本章使用了像x、n和t这样的短变量名。在大多数软件项目中，最短的合理名称可能类似于 elem、nelems 和 target。我发现建立脚手架的时候使用短名字比较方便，在类似4.3节的数学证明中使用短名字也是很必要的。数学上也有类似的法则：对数学不熟悉的人可能希望听到“直角三角形斜边的平方等于两条直角边的平方和”，而处理该问题的人通常会说“a<span class="super">2</span>
 + b<span class="super">2</span>
 = c<span class="super">2</span>
 ”。</p>
<p class="content">我尽可能地保持了Kernighan和Ritchie的C编码风格，但是我把函数的左花括号放在了第一行代码中，并删除了其他空行以节省版面（对于本书中的小函数而言，空行占了很大的百分比）。</p>
<p class="content">如果目标值不存在，那么5.1节的二分搜索返回整数-1；如果目标值存在，那么二分搜索就定位到该值。Steve McConnell建议搜索应该返回两个值：一个是布尔值，用于表示目标值是否存在；另一个是下标索引，仅当布尔值为真时使用：</p>
<p class="content">boolean BinarySearch(DataType TargetValue,int *TargetIndex)</p>
<p class="content">/* precondition: Element[0] &lt;= Element[1] &lt;=</p>
<p class="content_7">...&lt;= Element[NumElements-1]</p>
<p class="content_5">postcondition:</p>
<p class="content_7">result == false =&gt;</p>
<p class="content_8">TargetValue not in Element[0..NumElements-1]</p>
<p class="content_7">result == true =&gt;</p>
<p class="content_8">Element[*TargetIndex] == TargetValue</p>
<p class="content">*/</p>
<p class="content">McConnell的《代码大全》一书的第402页的程序清单18.3是一个Pascal插入排序，占了（很大的）一页；代码和注释加起来总共41行。该代码风格比较适合于大型软件项目。本书的11.1节仅用5行代码就表示出了同样的算法。</p>
<p class="content">只有很少的程序具有错误检查功能。一些函数从文件中将数据读入到大小为MAX的数组中，由于scanf调用很容易使缓冲区溢出，因此，作为scanf函数形参的数组实参是全局变量。</p>
<p class="content">本书采用了适合于教科书和脚手架的简短名字，但是这种做法不适用于大型软件项目。Kernighan和Pike在Practice of Programming一书的1.1节指出，“清晰往往来自简短”。即便如此，本书的大多数代码还是避免了 14.3 节的 C++代码所体现出来的难以置信的密集风格。</p>
<p class="content">7.当n=1 000时，按照排好的顺序搜索整个数组每次需要351纳秒，而按随机顺序搜索会使平均开销提高到418纳秒（大约减慢20%）。当n=10<span class="super">6</span>
 时，实验中甚至连二级缓存都会溢出，并且减速因子为 2.7。对于 8.3 节中高度调优过的二分搜索，有序搜索能够在125纳秒内搜索包含n=1000个元素的表，而随机搜索则需要266纳秒的时间，减速因子超过2。</p>
<p class="content_1">第6章答案</p>
<p class="content">4.希望自己的系统可靠吗？在设计初期就应该建立可靠性，否则以后很难加上。在设计数据结构时，应该使其能够在部分受损时恢复信息。通过仔细的察看和简单的运行来检查代码，并进行广泛的测试。在可靠的操作系统上、在使用错误校正内存的冗余硬件系统中运行您的软件。制订一个计划，以便在系统崩溃（一定会崩溃）时能够快速恢复。仔细记录每次崩溃以便学习。</p>
<p class="content">6.“在提高效率之前先确保正确性”通常是一个好建议。不过，Bill Wulf只花了几分钟就让我觉得这一古训并没有我以前想象得那么正确。他举了一个文档生成系统的例子，该系统需要几个小时才能生成一本书。Wulf 的评论如下：“这个程序跟其他任何大型系统一样，今天有10个已知的小错误，下个月又将出现10个新的错误。如果让你在纠正当前的10个错误和使程序提速10倍之间选择，你会选择哪一个？”</p>
<p class="content_1">第7章答案</p>
<p class="content">在本书付诸出版时，下面这些答案所猜测的数与正确值的偏差因子可能会达到2，但是不会差得太多。</p>
<p class="content">1.即便当帕塞伊克河在新泽西州帕特森市的美丽的大瀑布处从80英尺的高度落下来时，其流速也达不到每小时200英里。我怀疑该工程师跟记者说的是：该河的流速为每天200英里，是每天40英里的常见速度的5倍；常见流速比较慢，不到每小时两英里。</p>
<p class="content">2.老式的可移动磁盘容量为100 MB。ISDN线每秒能传输112 Kbit，或者说每小时能传输50 MB。这就相当于在骑自行车的人的口袋中放一个磁盘，然后让他骑两小时或绕半径15英里的圆一周。为了使比较更有趣，我们将100张DVD放入骑车人的背包，这样他的带宽就变成了原来的17 000倍；把ISDN线更新为ATM可以使带宽变为原来的1 400倍，每秒能传输155 Mbit。这样骑车的人又得到了一个系数12，或要说需要骑一天。（写完这段文字的第二天，我发现同事的办公桌上堆着200张5 GB的一次写入唱片。在1999年，拥有这么多的媒体数据是很惊人的。） 3.软盘的容量为1.44 MB。我全速打字的速度约为每分钟50个单词（300字节），因此可以在4 800分钟或80小时内填满一张软盘。（本书的输入文本仅有0.5 MB，但是我却花了超过三天的时间才完成录入）。</p>
<p class="content">4.我原本希望得到的答案是：以前只需要10纳秒的指令执行现在需要1/100秒，以前只需要11毫秒的磁盘旋转（5 400转/分钟）现在需要3小时，以前只需要20毫秒的磁盘臂搜索现在需要 6 个小时，以前只需要两秒钟的名字键入现在大约需要一个月。一位聪明的读者写道：“需要多长时间？如果时钟也同样变慢，则所需的时间跟以前完全一样。”</p>
<p class="content">5.增长速率介于5%和10%之间时，“72法则”估算的误差在1%以内。</p>
<p class="content">6.由于72/1.33约为54，因此到2052年人口将翻倍（令人欣喜的是，联合国的估算使得人口增长率有了显著的降低）。</p>
<p class="content">9.忽略由于排队而导致的减速，如果每次磁盘操作需要20毫秒（磁盘臂搜索时间）的话，那么处理每个事务需要2秒，也就是说每小时可以处理1 800个事务。</p>
<p class="content">10.可以通过统计报纸上的死亡通告并估算本地人口来估算本地的死亡率。一种更简单的方法是利用Little定律以及对平均寿命的估算。例如，如果平均寿命为70年，那么每年有1/70或1.4%的人口死亡。</p>
<p class="content">11.Peter Denning对Little定律的证明可以分为两部分。“首先，定义λ=A/T为到达速率，其中A是在长度为T的观察时间内到达的数目。定义X=C/T为输出速率，其中C是在长度为T的观察时间内的完成数。用n(t)表示在[0,T]内的时间t上系统中的数目。令W是n(t)下的区域（单位为“项—秒”），表示观察期间系统中所有元素的等待时间总和。每个元素完成的平均响应时间定义为R=W/C，单位为“(项—秒)/项”。系统中的平均数是n(t)的平均高度，即L=W/T，单位为“(项—秒)/秒”。现在很明显L=RX。这个公式仅就输出速率而言。没有必要进行“流平衡”，即具有相同的输出流量（用符号表示为λ=X）。如果你添加了这个假设条件，公式就变成L=λ× R，这是排队论和系统论中遇到的公式。”</p>
<p class="content">12.当读到一枚25美分硬币的“平均寿命是30年”时，我觉得这个数太大了，我记得自己没看到过多少古老的硬币。因此，我把手伸进口袋，找出了12枚25美分的硬币。它们的年龄如下（以年为单位）：</p>
<p class="content">3 4 5 7 9 9 12 17 17 19 20 34平均年龄为13年，这和25美分硬币的平均寿命约为（年龄分布相当均匀情况下）寿命的两倍非常一致。如果能找到大量年龄都少于5年的硬币，我就可以进一步研究这个问题。然而，这次我认为这篇文章的结论是正确的。该文章还说“至少制造了7.5亿枚新泽西州的25美分硬币”，还说每10周就会发行一种新的25美分的州硬币。这乘起来就得出如下结论：每年大约发行40亿枚25美分硬币，或者说每个美国居民每年能得到12枚新的25美分硬币。每枚25美分硬币具有30年的寿命就意味着每个美国居民拥有360枚25美分硬币。这些硬币放在口袋里太多了，但是如果加上家里和汽车里的零钱，以及收银机、投币式自动售货机和银行里的硬币，那就差不多了。</p>
<p class="content_1">第8章答案</p>
<p class="content">1.David Gries在1982年第2期的Science of Computer Programming第207页～第214页的“A Note on the Standard Strategy for Developing Loop Invariants and Loops”一文中系统地推导并验证了算法4。</p>
<p class="content">3.算法1大约对函数max进行了n<span class="super">3</span>
 /6次调用，算法2大约进行了n<span class="super">2</span>
 /2次调用，算法4大约进行了2n次调用。算法2b为累加数组使用了线性的额外空间，算法3为栈使用了对数的额外空间。其他算法仅使用了常数的额外空间。算法 4 是实时的：一趟输入完毕它就计算出答案，这特别适用于处理磁盘文件。</p>
<p class="content">5.如果将cumarr声明成</p>
<p class="content">float *cumarr;</p>
<p class="content">那么赋值</p>
<p class="content">cumarr = realarray+1</p>
<p class="content">将意味着cumarr[-1]指向realarray[0]。</p>
<p class="content">9.使用赋值maxsofar =-∞替换maxsofar = 0。如果-∞的使用让你迷惑，也可以使用maxsofar = x[0],为什么？</p>
<p class="content">10.初始化累加数组cum，使得cum[i]=x[0]+L+x[i]。如果cum[l−1]=cum[u],那么子向量x[l..u]之和就为0。因此，可以通过定位cum中最接近的两个元素来找出和最接近零的子向量；这可以通过排序数组，在O(n log n)时间内完成。这样得到的运行时间不超过最优时间的常数倍，因为任何能够解决这个问题的算法都能够用于解决“元素唯一性”问题（判断数组中是否包含重复元素。Dobkin和Lipton证明“元素唯一性”问题所需的时间跟最坏情况下决策树模型的计算所需的时间差不多）。</p>
<p class="content">11.假设收费公路是笔直的，则收费站i和收费站j之间的总费用为cum[j]-cum[i-l],其中cum是类似上题的累加数组。</p>
<p class="content">12.本答案使用另一个累加数组。可以使用赋值语句：</p>
<p class="content">for i = [l,u]</p>
<p class="content_5">x[i] += v</p>
<p class="content">替代循环</p>
<p class="content">cum[u] += v</p>
<p class="content">cum[l-1] -= v</p>
<p class="content">上面的两个赋值语句先对x[0..u]加上v，然后再从x[0..l-1]中减去v。这些和都计算完毕后，我们用下面的语句计算数组x：</p>
<p class="content">for (i = n-1; i &gt;= 0; i--)</p>
<p class="content_5">x[i] = x[i+1] + cum[i]</p>
<p class="content">这样就把n次求和的最坏情况运行时间从O(n<span class="super">2</span>
 )降到了O(n)。在6.1节描述的Appel的n体程序中，收集统计数的时候出现了这个问题。使用上述解决方案后，统计函数的运行时间从4小时降到了20分钟。当程序的执行需要一年时，这样的加速不是很重要；但是如果程序的执行只需要一天，这样的加速就非常重要了。</p>
<p class="content">13.为了在O(m<span class="super">2</span>
 n)时间内找出m×n的数组中总和最大的子数组，可以在长度为m的维度上使用算法2的方法，在长度为n的维度上使用算法4的方法。这样就可以在O(n<span class="super">3</span>
 )时间内解决n×n问题，这个结果在长达20年的时间内一直是最佳的。在1998年的Symposium on Discrete Algorithms（第446页～第452页）上，Tamaki和Tokuyama提出了一种稍快一些的算法，运行时间为O(n<span class="super">3</span>
 [(log log n)/(log n)<span class="super">1/2</span>
 ] )。他们还给出了一种用于找出总和至少为最大值一半的子数组的O( <span class="super">2</span>
 n log n)近似算法，并介绍了其在数据挖掘中的应用。最理想的下界仍然正比于n<span class="super">2</span>
 。</p>
<p class="content_1">第9章答案</p>
<p class="content">2.下面这些变量有助于实现Van Wyk方法的一个变体。我们的方法使用nodesleft跟踪freenode所指向的结点的个数NODESIZE。当nodesleft变为零时，重新分配数目为NODEGROUP的一组结点。</p>
<p class="content">#define NODESIZE 8</p>
<p class="content">#define NODEGROUP 1000</p>
<p class="content">int nodesleft = 0;</p>
<p class="content">char *freenode;</p>
<p class="content">对malloc的调用可以替换为对如下函数的调用：</p>
<p class="content">void *pmalloc(int size)</p>
<p class="content">{ void *p;</p>
<p class="content_4">if (size != NODESIZE)</p>
<p class="content_5">return malloc(size);</p>
<p class="content_4">if (nodesleft == 0) {</p>
<p class="content_5">freenode = malloc(NODEGROUP*NODESIZE);</p>
<p class="content_5">nodesleft = NODEGROUP;</p>
<p class="content_4">}</p>
<p class="content_4">nodesleft--;</p>
<p class="content_4">p = (void *) freenode;</p>
<p class="content_4">freenode += NODESIZE;</p>
<p class="content_4">return p;</p>
<p class="content">}</p>
<p class="content">如果参数不等于NODESIZE，则立即调用系统的malloc。当nodesleft为0时，另外分配一组结点。使用与9.1节相同的输入，总的运行时间从2.67秒降至1.55秒，其中花在malloc上面的时间由1.41秒降至0.31秒（新运行时间的19.7%）。</p>
<p class="content">如果程序还需要释放结点，可以用一个新变量指向一个空闲结点的单向链表。释放一个结点时，将其放到该链表的最前面。当链表为空时，算法分配一组结点，并通过链表将它们连接起来。</p>
<p class="content">4.一组按降序排列的值就可以使算法的时间开销约为2<span class="super">n</span>
 。</p>
<p class="content">5.如果二分搜索算法声称找到了值t，那么该值一定在数组中。不过，应用于未排序数组时，算法有时会在 t 实际存在时报告说该值不存在。在这种情况，算法需要定位一对相邻的元素，以确定在数组有序时t不存在。</p>
<p class="content">6.例如，可以使用下面的测试来判断一个字符是否为数字：</p>
<p class="content">if c &gt;= '0' &amp;&amp; c &lt;= '9'</p>
<p class="content">若要判断一个字符是否为字母数字，则需要进行很复杂的一系列比较。如果性能很重要，那么我们应该把最有可能成功的测试条件放在前面。通常，使用一个256元的表更简单也更快：</p>
<p class="content">#define isupper(c) (uppertable[c])</p>
<p class="content">大多数系统为表中的每个元素存储几个位，并通过逻辑与操作来提取：</p>
<p class="content">#define isupper(c) (bigtable[c] &amp; UPPER)</p>
<p class="content">#define isalnum(c) (bigtable[c] &amp; (DIGIT|LOWER|UPPER))</p>
<p class="content">C和C++程序员可以通过查看ctype.h文件来了解自己所用的系统如何解决这个问题。</p>
<p class="content">7.第一种方法是计算每个输入单元（可能是一个8位的字符或32位的整数）中为1的位数，然后将它们相加。为了找出16位整数中为1的位数，我们可以按顺序观察每一位，或者（使用类似b &amp;= (b-l)的语句）对为1的位进行迭代，或者查表（例如查询一个2<span class="super">16</span>
 =65 536元的表）。高速缓存的大小对输入单元的选择有何影响？</p>
<p class="content">第二种方法是计算输入中每个输入单元的个数，然后将该个数乘以相应输入单元中为1的位数，最后再对各个输入单元求总和。</p>
<p class="content">8.R.G.Dromey使用x[n]作为哨兵，用下面的代码来计算数组x[0..n-1]中的最大元素：</p>
<p class="content">i = 0</p>
<p class="content">while i &lt; n</p>
<p class="content_4">max = x[i]</p>
<p class="content_4">x[n] = max</p>
<p class="content_4">i++</p>
<p class="content_4">while x[i] &lt; max</p>
<p class="content_5">i++</p>
<p class="content">11.使用几个72元的表格来取代函数计算，这样可以使该程序在IBM 7090上的运行时间从半小时降至1分钟。对直升飞机的旋翼叶片进行计算大约需要运行该程序300次，因此我们增加的这少数几百个额外的内存字使得CPU时间从一周降至几个小时。</p>
<p class="content">12.Horner使用下面的方法对多项式求值：</p>
<p class="content">y = a[n]</p>
<p class="content">for (i = n-1; i &gt;= 0; i--)</p>
<p class="content_4">y = x*y + a[i]</p>
<p class="content">他使用了n次乘法，运行速度通常是以前那个代码的两倍。</p>
<p class="content_1">第10章答案</p>
<p class="content">1.每一条访问压缩字段的高级语言指令会被编译为许多条机器指令，而访问未压缩字段所需要的机器指令则少一些。Feldman对记录解压之后，数据空间稍微增加了一些，但代码空间和运行时间却大大减少了。</p>
<p class="content">2.一些读者建议在存储三元组(x,y,pointnum)时，如果x相同则根据y排序，这样就可以使用二分搜索来查找给定的(x,y)对。一旦输入已经根据x的值排好了序（并且如上所述，在x相同的情况下根据y排好了序），文中描述的数据结构就很容易建立了。在row数组的firstincol[i]和firstincol[i+l]-l之间进行二分搜索可以使该结构的搜索更快。注意，这些 y 值按升序排列，并且二分搜索必须能够正确处理搜索空子数组的情况。</p>
<p class="content">4.Almanacs 使用表格将城市间的距离存储为三角数组，这可以使所需的空间减少一半。有时，数学表格仅存储函数的最低有效位，最高有效位只给出一次（比如，对于每一行来说）。电视节目表可以通过仅说明节目的开始时间来节省空间（不需要按照给定的30分钟时间间隔列出所有的节目）。</p>
<p class="content">5.Brooks 结合了两种表示方法来表示该表格。函数与真实答案相差无几，存储在数组中的单个十进制数字给出了它们之间的区别。阅读了本习题和答案之后，本版的两位审稿人评论说，最近他们也通过为近似函数补充一个表格，成功地解决了一些问题。</p>
<p class="content">6.原始文件需要300 KB的磁盘空间。将两个数字压缩到一个字节中能够将所需的磁盘空间减小到150 KB，但是会增加读文件所需的时间（那时候“单面双密度”的5.25英寸软盘的容量为184 KB）。使用表查找来替代高开销的/和%运算需要消耗200个字节的主存空间，但却可以使读取时间降低到几乎跟原来一样。因此我们相当于用200字节的主存换取了150 KB的磁盘空间。一些读者建议用c = (a&lt;&lt;4)|b的方式编码，解码时可以使用a=c&gt;&gt;4和b=c&amp;0 xF这两个语句。John Linderman通过观察指出“移位和掩码通常比乘除法快，而且十六进制转储等常用工具能够以可读的形式显示解码后的数据”。</p>
<p class="content_1">第11章答案</p>
<p class="content">1.通过排序来查找n个浮点数中的最小值或最大值通常属于过度使用。答案9告诉我们，不使用排序也可以更快地求出中值；但是在某些系统上，可能使用排序更容易一些。排序对于求众数很有效，但散列的速度可能更快。求均值的算法的运行时间通常正比于 n，但如果先进行一轮排序可能有助于提高数值精度，见习题14.4.b。</p>
<p class="content">2.Bob Sedgewick发现，可以使用下面的不变式，将Lomuto的划分方案修改为从右向左进行。</p>
<div class="bodypic_"><img alt="" src="../Images/image00257.jpeg" class="calibre3"/>
</div>
<p class="content">从而划分代码可写为：</p>
<p class="content">m = u+1</p>
<p class="content">for(i = u; i &gt;= l; i--)<span id="ref65">
<a href="part0018.xhtml#annot65">[3]</a>
</span>
</p>
<p class="content_4">if x[i] &gt;= t</p>
<p class="content_5">swap(--m,i)</p>
<p class="content">由于循环终止时x[m] = t，所以可以直接使用参数(l,m-1)和(m+1,u)进行递归，不再需要swap操作。Sedgewick还用x[l]作为哨兵省去了内循环中的一次测试：</p>
<p class="content">m = i = u+1</p>
<p class="content">do</p>
<p class="content_4">while x[--i] &lt; t</p>
<p class="content_5">;</p>
<p class="content_4">swap(--m,i)</p>
<p class="content">while i != l</p>
<p class="content">3.为了确定cutoff的最佳值，我将n固定为1 000 000，然后对cutoff在[1,100]上的每个可能取值都运行了一遍程序，结果如下图所示。</p>
<div class="bodypic_"><img alt="运行时间（秒） cutoff取值" src="../Images/image00258.jpeg" class="calibre3"/>
</div>
<p class="content">不难看出，50 是一个比较理想的取值。cutoff 在 30～70 取值时，运行时间与取50的情况相比只相差几个百分点。</p>
<p class="content">4.参见11.6节引用的参考书。</p>
<p class="content">5.McIlroy的程序运行时间正比于待排序的数据量，这在最坏情况下是最好的。该程序假定x[0..n-1]中的每一项都包含一个整数length和一个指向数组bit[0..length-1]的指针。</p>
<p class="content">void bsort(l,u,depth)</p>
<p class="content_4">if l &gt;= u</p>
<p class="content_5">return</p>
<p class="content_4">for i = [l,u]</p>
<p class="content_5">if x[i].length &lt; depth</p>
<p class="content_6">swap(i,l++)</p>
<p class="content_4">m = l</p>
<p class="content_4">for i = [l,u]</p>
<p class="content_5">if x[i].bit[depth] == 0</p>
<p class="content_6">swap(i,m++)</p>
<p class="content_4">bsort(l,m-1,depth+1)</p>
<p class="content_4">bsort(m,u,depth+1)</p>
<p class="content">一开始用bsort(0,n-1,1)调用该函数。注意，程序中为参数和定义for循环的变量赋值了。线性运行时间很大程度上得益于 swap 操作移动的是指向位字符串的指针，而不是位字符串本身。</p>
<p class="content">6.选择排序的实现代码如下：</p>
<p class="content">void selsort()</p>
<p class="content_4">for i = （0,n-1）</p>
<p class="content_5">for j = （i,n）</p>
<p class="content_6">if x[j] &lt; x[i]</p>
<p class="content_7">swap(i,j)</p>
<p class="content">希尔排序的实现代码如下：</p>
<p class="content">void shellsort()</p>
<p class="content_4">for (h = 1 ; h &lt; n ; h = 3*h + 1)</p>
<p class="content_5">;</p>
<p class="content_4">loop</p>
<p class="content_5">h /= 3</p>
<p class="content_5">if (h &lt; 1)</p>
<p class="content_6">break</p>
<p class="content_5">for i = （h,n）</p>
<p class="content_7">for (j = i; j &gt;= h; j -= h)</p>
<p class="content_8">if (x[j-h] &lt; x[j])</p>
<p class="content_14">break</p>
<p class="content_8">swap(j-h,j)</p>
<p class="content">9.下面的选择算法来自C.A.R.Hoare，代码由qsort4稍作修改而得。</p>
<p class="content">void select1(l,u,k)</p>
<p class="content_4">pre l &lt;= k &lt;= u</p>
<p class="content_4">post x[l..k-1] &lt;= x[k] &lt;= x[k+1..u]</p>
<p class="content">if l &gt;= u</p>
<p class="content_4">return</p>
<p class="content">swap(l,randint(l,u))</p>
<p class="content">t = x[l]; i = l; j = u+1</p>
<p class="content">loop</p>
<p class="content_4">do i++; while i &lt;= u &amp;&amp; x[i] &lt; t</p>
<p class="content_4">do j--; while x[j] &gt; t</p>
<p class="content_4">if i &gt; j</p>
<p class="content_5">break</p>
<p class="content">temp = x[i]; x[i] = x[j]; x[j] = temp swap(l,j)</p>
<p class="content">if j &lt; k</p>
<p class="content_4">select1(j+1,u,k)</p>
<p class="content">else if j &gt; k</p>
<p class="content_4">select1(l,j-1,k)</p>
<p class="content">由于递归是函数的最后一个操作，因此可以将其转换成一个while循环。在The Art of Computer Pragramming Volume 3：Sorting and Searching一书的习题5.2.2-32中， Knuth证明该程序平均需要3.4n次比较来求出n个元素的中值；证明方法本质上类似于答案2.A中的最坏情况证明。</p>
<p class="content">14.这一版本的快速排序需要用到指向数组的指针。由于只使用x和n两个参数，只要读者能够理解 x+j+1 表示的是从位置 x[j+1]开始的数组，它甚至可以比 qsort1还简单。</p>
<p class="content">void qsort5(int x[],int n)</p>
<p class="content">{ int i,j ;</p>
<p class="content_4">if (n &lt;= 1)</p>
<p class="content_5">return ;</p>
<p class="content_4">for (i = 1,j = 0 ; i &lt; n ; i++)</p>
<p class="content_4">if (x[i] &lt; x[0])</p>
<p class="content_5">swap(++j,i,x);</p>
<p class="content_4">swap(0,j,x);</p>
<p class="content_4">qsort5(x,j);</p>
<p class="content_4">qsort5(x+j+1,n-j-1);</p>
<p class="content">}</p>
<p class="content">由于该函数用到了指向数组的指针，因此它可以用C或C++实现，但不能用Java实现。我们还必须将数组名（即指向数组的指针）传递给swap函数。</p>
<p class="content_1">第12章答案</p>
<p class="content">1.下面两个函数分别返回一个较大的随机数（通常30位）和指定范围内的一个随机数：</p>
<p class="content">int bigrand()</p>
<p class="content">{ return RAND_MAX*rand() + rand(); }</p>
<p class="content">int randint(int l,int u)</p>
<p class="content">{ return l + bigrand() % (u-l+1); }</p>
<p class="content">2.为了从0～n-1范围内选择m个整数，可以先在该范围内随机选择一个数i，然后输出i,i+1,…,i+m-1（有可能绕回到0）。这一方法选中每个整数的概率都是m/n，但特定子集的选中概率明显偏大。</p>
<p class="content">3.如果已被选中的整数少于 n/2 个，那么对一个已被随机选中的整数来说，其不被再次选中的概率大于1/2。由于我们平均必须抛两次硬币才能得到正面，因此获得未被选中的整数的平均抽签次数小于2。</p>
<p class="content">4．我们将集合S视为n个初始为空的坛子的集合。每调用一次randint，我们就选中一个坛子往里面扔一个球；如果该坛子中已经有球了，则成员测试为真。需要多少个球来确保每个坛子中至少有一个球，这是统计学上著名的“赠券收集问题”（我必须收集多少张棒球卡才能确保拥有所有的n？），答案大概为nlnn。如果每个球都进入了不同的坛子，算法需要m次测试；而判断何时可能会有两个球进入同一个坛子，可以用“生日悖论”（如果一群人的人数达到 23 或更多，则很可能有两个人的生日是同一天）。一般说来，如果有<img alt="" class="h-pic" src="../Images/image00259.jpeg"/>
 个球，则很可能会有两个球共享n个坛子中的某一个。</p>
<p class="content">7.为了按升序输出，可以把print语句放到递归调用之后。</p>
<p class="content">8.为了按随机顺序输出不同的整数，在第一次生成每个整数时就将其输出，另见答案1.4。为了按序输出重复的整数，删除判断整数是否已在集合中的测试。为了按随机顺序输出重复的整数，使用下面的程序：</p>
<p class="content">for i = [0,m）</p>
<p class="content_4">print bigrand() % n</p>
<p class="content">9.Bob Floyd在研究基于集合的算法时发现，该算法会丢掉其生成的一些随机数。因此他提出了另一个基于集合的算法，用C++实现如下：</p>
<p class="content">void genfloyd(int m,int n)</p>
<p class="content">{ set&lt;int&gt; S;</p>
<p class="content_4">set&lt;int&gt;::iterator i;</p>
<p class="content_4">for (int j = n-m; j &lt; n; j++) {</p>
<p class="content_5">int t = bigrand() % (j+1);</p>
<p class="content_5">if (S.find(t) == S.end())</p>
<p class="content_6">S.insert(t); // t not in S</p>
<p class="content_5">else</p>
<p class="content_6">S.insert(j); // t in S</p>
<p class="content_4">}</p>
<p class="content_4">for (i = S.begin(); i != S.end(); ++i)</p>
<p class="content_5">cout &lt;&lt; *i &lt;&lt; "\n";</p>
<p class="content">}</p>
<p class="content">答案 13.1 用不同的集合接口实现这一算法。Floyd 的算法最早出现于 1986 年 8月《ACM通讯》的“编程珠玑”专栏，随后在我1988年的《编程珠玑II》一书的第13章再次出现，以上两处都提供了对其正确性的简单证明。</p>
<p class="content">10.我们总选择第1行，并以概率1/2选择第2行，以概率1/3选择第3行，依此类推。在这一过程结束时，每一行的选中概率是相等的（都是 1/n，其中 n 是文件的总行数）：</p>
<p class="content">i = 0</p>
<p class="content">while more input lines</p>
<p class="content_4">with probability 1.0/++i</p>
<p class="content_5">choice = this input line</p>
<p class="content">print choice</p>
<p class="content">11.我在“应用算法设计”课程的家庭作业中布置过完全一样的题目。如果学生给出了只需要几分钟的 CPU 时间就能计算出答案的方法，我会给他们零分；如果答案是“我需要和统计学教授讨论”，可以得到一半的分数；最佳答案应该像这样：</p>
<p class="content">数字4～16对游戏没有影响，可以忽略。如果1和2都出现（顺序不限）在3之前，则玩家获胜。这种情况发生在3最后选中时，概率为1/3。因此，随机选择覆盖点的顺序就能够获胜的概率精确地等于1/3。</p>
<p class="content">不要受问题陈述的误导，我们没必要仅仅因为可以使用CPU时间而去使用CPU时间。</p>
<p class="content">12.5.9节介绍了Kernighan和Pike的Practice of Programming。该书的6.8节描述了他们如何测试概率程序（我们在15.3节将看到另一个完成同一任务的程序）。</p>
<p class="content_1">第13章答案</p>
<p class="content">1.答案12.9的Floyd算法可以用IntSet类实现如下：</p>
<p class="content">void genfloyd(int m,int maxval)</p>
<p class="content">{ int *v = new int[m];</p>
<p class="content_5">IntSetSTL S(m,maxval);</p>
<p class="content_5">for (int j = maxval-m; j &lt; maxval; j++) {</p>
<p class="content_7">int t = bigrand() % (j+1);</p>
<p class="content_7">int oldsize = S.size();</p>
<p class="content_7">S.insert(t);</p>
<p class="content_7">if (S.size() == oldsize) // t already in S</p>
<p class="content_8">S.insert(j);</p>
<p class="content_7">}</p>
<p class="content_7">S.report(v);</p>
<p class="content_7">for (int i = 0; i &lt; m; i++)</p>
<p class="content_8">cout &lt;&lt; v[i] &lt;&lt; "\n";</p>
<p class="content">}</p>
<p class="content">当m和maxval相等时，元素按升序插入，这正是二分搜索树的最坏情况。</p>
<p class="content">4.下面的链表迭代插入算法比对应的递归算法长一些，因为它把在head后面插入结点和后来在链表中插入结点的实例分析各写了一遍：</p>
<p class="content">void insert(t)</p>
<p class="content_4">if head-&gt;val == t</p>
<p class="content_5">return</p>
<p class="content">if head-&gt;val &gt; t</p>
<p class="content_4">head = new node(t,head)</p>
<p class="content_4">n++</p>
<p class="content_4">return</p>
<p class="content">for (p = head; p-&gt;next-&gt;val &lt; t; p = p-&gt;next)</p>
<p class="content_4">;</p>
<p class="content">if p-&gt;next-&gt;val == t</p>
<p class="content_4">return</p>
<p class="content">p-&gt;next = new node(t,p-&gt;next)</p>
<p class="content">n++</p>
<p class="content">下面的简化代码通过使用指向指针的指针来去除重复：</p>
<p class="content">void insert(t)</p>
<p class="content_4">for (p = &amp;head; (*p)-&gt;val &lt; t; p = &amp;((*p)-&gt;next))</p>
<p class="content_5">;</p>
<p class="content_4">if (*p)-&gt;val == t</p>
<p class="content_5">return</p>
<p class="content_4">*p = new node(t,*p)</p>
<p class="content_4">n++</p>
<p class="content">这段代码的速度跟前一版本一样快。只要对其稍作修改即可用于箱。答案 7 将这一方法用到了二分搜索树上。</p>
<p class="content">5.为了用一次存储分配来取代多次分配，我们需要有一个指向下一个可用结点的指针：</p>
<p class="content">node *freenode;</p>
<p class="content">在构造类的时候就分配出足够的空间：</p>
<p class="content">freenode = new node[maxelms]</p>
<p class="content">然后在插入函数中根据需要加以使用：</p>
<p class="content">if (p == 0)</p>
<p class="content_4">p = freenode++</p>
<p class="content_4">p-&gt;val = t</p>
<p class="content_4">p-&gt;left = p-&gt;right = 0</p>
<p class="content_4">n++</p>
<p class="content">else if...</p>
<p class="content">同样的方法可以应用到箱中。答案7将其用到了二分搜索树上。</p>
<p class="content">6.按升序插入结点可以度量数组和链表的搜索开销，而且只会引入很小的插入开销。</p>
<p class="content">而对于箱和二分搜索树，该代码会导致最坏情况。</p>
<p class="content">7.把以前的null指针都指向哨兵结点，哨兵在构造函数中进行初始化：</p>
<p class="content">root = sentinel = new node</p>
<p class="content">插入代码先将目标值t放入哨兵结点，然后用一个指向指针的指针（见答案4）来自顶向下遍历树直至找到t。接着使用答案5的方法插入一个新结点。</p>
<p class="content">void insert(t)</p>
<p class="content_4">sentinel-&gt;val = t</p>
<p class="content_4">p = &amp;root</p>
<p class="content_4">while (*p)-&gt;val != t</p>
<p class="content_5">if t &lt; (*p)-&gt;val</p>
<p class="content_6">p = &amp;((*p)-&gt;left)</p>
<p class="content_5">else</p>
<p class="content_6">p = &amp;((*p)-&gt;right)</p>
<p class="content_4">if *p == sentinel</p>
<p class="content_5">*p = freenode++</p>
<p class="content_5">(*p)-&gt;val = t</p>
<p class="content_5">(*p)-&gt;left = (*p)-&gt;right = sentinel</p>
<p class="content_5">n++</p>
<p class="content">其中结点变量声明并初始化如下：</p>
<p class="content">node **p = &amp;root;</p>
<p class="content">9.为了用移位取代除法，我们用类似下面的伪代码对变量进行初始化：</p>
<p class="content">goal = n/m</p>
<p class="content">binshift = 1</p>
<p class="content">for (i = 2; i &lt; goal; i *= 2)</p>
<p class="content_4">binshift++</p>
<p class="content">nbins = 1 + (n &gt;&gt; binshift)</p>
<p class="content">插入函数从该结点开始：</p>
<p class="content">p = &amp;(bin[t &gt;&gt; binshift])</p>
<p class="content">10.可以通过混合并匹配多种数据结构来表示随机集合。例如，由于我们很清楚每个箱中将包含多少项，因此可以用13.2节的知识，使用小数组来表示大多数箱中的项（当箱太满时可以将剩下的元素放到一个链表中）。Don Knuth在1986年5月《ACM通讯》的“编程珠玑”专栏中描述了一种“有序散列表”来解决这一问题，以展示他的文档化Pascal程序Web系统。该论文也是他1992年出版的Literate Programming一书的第5章。</p>
<p class="content_1">第14章答案</p>
<p class="content">1.把swap函数中与临时变量相关的赋值移到循环之外，就可以使siftdown运行得更快。为使siftup运行得更快，除了可以这样做之外，还可以在x[0]中放一个哨兵元素，省去测试if i == 1。</p>
<p class="content">2.修改后的siftdown函数与本书的siftdown函数差别不大。赋值语句i = 1替换为了i=l，与n的比较替换为了与u的比较。修改后函数的运行时间为O(logu–logl)。</p>
<p class="content">下面的代码可以在O(n)时间内构造一个堆：</p>
<p class="content">for (i = n-1; i &gt;= 1; i--)</p>
<p class="content_4">/* invariant: maxheap(i+1,n) */</p>
<p class="content_4">siftdown(i,n)</p>
<p class="content_4">/* maxheap(i,n) */</p>
<p class="content">由于maxheap(l,n)对所有l &gt; n/2的整数都为真，因此for循环的边界n-1可以改为n/2。</p>
<p class="content">3.使用答案1和答案2中的函数，堆排序如下：</p>
<p class="content">for (i = n/2; i &gt;= 1; i--)</p>
<p class="content_4">siftdown1(i,n)</p>
<p class="content">for (i = n; i &gt;= 2; i--)</p>
<p class="content_4">swap(1,i)</p>
<p class="content_4">siftdown1(1,i-1)</p>
<p class="content">其运行时间仍为O(n log n)，但是常系数比以前的堆排序要小一些。本书网站上的排序程序提供了几种堆排序实现。</p>
<p class="content">4.堆实现使得下面4个问题中的O(n)过程变成了O(log n)过程。</p>
<p class="content">a.构建赫夫曼码的迭代步骤选择集合中的两个最小结点，将其归并为一个新结点。这是通过两次extractmin调用和一次insert调用来实现的。如果输入的各频率是有序的，那么就可以在线性时间内计算出赫夫曼码，细节留作练习。</p>
<p class="content">b.简单地把较小的浮点数和较大的浮点数相加可能会丢失精度。一种较好的算法每次都把集合中最小的两个数相加，类似于上面提到的构建赫夫曼码的算法。</p>
<p class="content">c.用一个百万元堆（最小的元素在顶部）来表示目前所看到的最大的100万个数。</p>
<p class="content">d.可以用堆表示每个文件中的下一个元素，从而实现对有序文件的归并。迭代步骤从堆中选出最小的元素，并将其后继插入堆中。n个文件中下一个待输出的元素可以在O(log n)时间内选出。</p>
<p class="content">5.把箱序列组织成一种类似于堆的结构，堆的每个结点说明其后代中最不满的箱的剩余空间。在决定往哪里放新权值时，搜索尽可能地往左进行（只要左边最不满的箱有足够的空间放该权值），只有在迫不得已时才往右进行。这样所需的时间正比于堆的深度O(log n)。当权值插入后，向上重新遍历该路径以调整堆中的权值。</p>
<p class="content">6.磁盘上顺序文件的常见实现使得块i指向块i + 1。Ed McCreight发现，如果同时让结点i指向结点2i，那么最多访存O(log n)次就能找到任意一个结点n。下面的递归函数输出了访问的路径。</p>
<p class="content">void path(n)</p>
<p class="content_7">pre n &gt;= 0</p>
<p class="content_7">post path to n is printed if n == 0</p>
<p class="content_7">print "start at 0"</p>
<p class="content_5">else if even(n)</p>
<p class="content_7">path(n/2)</p>
<p class="content_7">print "double to ",n</p>
<p class="content_5">else</p>
<p class="content_7">path(n-1)</p>
<p class="content_7">print "increment to ",n</p>
<p class="content">注意，这和习题4.9中在O(log n)时间内计算x<span class="super">n</span>
 的程序是类似的。</p>
<p class="content">7.修改后的二分搜索从i = 1开始，每次迭代将i设置为2i或2i + 1。元素x[1]包含中值，x[2]包含第一个四分位值，x[3]包含第三个四分位值，依此类推。S.R.Mahaney和J.I.Munro发现了一种能在O(n)时间内将n元有序数组调整为“堆搜索”顺序的算法。作为该方法的先驱，考虑把一个2<span class="super">k</span>
 – 1元的有序数组a拷贝到一个“堆搜索”数组b中：a中奇数位的元素按顺序放到b的后半部分，模4余2位置的元素按顺序放到b中剩余部分的后半部分，依此类推。</p>
<p class="content">11.C++标准模板库中支持堆的操作有make_heap、push_heap、pop_heap和sort_heap等。结合这些操作可以得到像下面这样简单的堆排序：</p>
<p class="content">make_heap(a,a+n);</p>
<p class="content">sort_heap(a,a+n);</p>
<p class="content">标准模板库也提供了priority_queue支持。</p>
<p class="content_1">第15章答案</p>
<p class="content">1.许多文档系统都提供了去除所有格式命令并查看输入的原始文本表示的方法。我在长文本上运行15.2节的字符串重复程序时发现，该程序对文本的格式非常敏感。程序处理詹姆斯一世钦定版《圣经》中的4 460 056个字符需要36秒，且最长的重复子字符串为 269 个字符。如果删除每行的行号以标准化输入文本，那么长字符串就可以跨越行边界，从而最长的重复子字符串达到了 563 个字符，但是程序找到它的时间几乎没有变。</p>
<p class="content">3.由于该程序每次插入都需要执行很多次搜索，因此只有很少的时间用于内存分配。采用专用的存储分配器能使处理时间减少约 0.06 秒，能使插入程序的速度提高10%，但是对整个程序的提速只有2%。</p>
<p class="content">5.可以在C++程序中添加另一个映射，将一组单词跟它们的计数联系起来。在C程序中我们可以根据计数对数组排序，然后对其迭代（由于一些单词的计数会比较大，数组应该比输入文件小得多）。对于常见的文档，我们可以用关键字索引，并保存一个在一定范围（如1～1 000）内计数的链表数组。</p>
<p class="content">7.算法教材多次提醒我们注意类似于“aaaaaaaa”的输入。我发现对由换行符组成的文件计时要更容易一些。程序处理5 000个换行符需要2.09秒，处理10 000个换行符需要8.90秒，处理20 000个换行符需要37.90秒。这一增长速度要比平方快一些，也许正比于大约n log<span class="sub">2</span>
 n次比较，其中每次比较的平均开销都正比于n。把一个大输入文件的两份拷贝拼接在一起产生的不良输入可能更接近实际生活。</p>
<p class="content">8.子数组a[i..i + M]表示M + 1个字符串。由于数组是有序的，我们可以通过调用在第一个和最后一个字符串上调用comlen函数来快速确定这M + 1个字符串共有的字符数：</p>
<p class="content">comlen(a[i],a[i+M])</p>
<p class="content">本书网站提供了实现这一算法的代码。</p>
<p class="content">9.把第一个字符串读入数组c，记录其结束的位置并在其最后填入空字符；然后读入第二个字符串并进行同样的处理。跟以前一样进行排序。扫描数组时，使用“异或”操作来确保恰有一个字符串是从过渡点前面开始的。</p>
<p class="content">14.下面的函数对k个单词组成的序列进行了散列，其中每个单词都以空字符结束：</p>
<p class="content">unsigned int hash(char *p)</p>
<p class="content_4">unsigned int h = 0</p>
<p class="content_4">int n</p>
<p class="content_4">for (n = k; n &gt; 0; p++)</p>
<p class="content_5">h = MULT * h + *p</p>
<p class="content_5">if (*p == 0)</p>
<p class="content_6">n—</p>
<p class="content_4">return h % NHASH</p>
<p class="content">本书网站上的一个程序使用这个散列函数取代了马尔可夫文本生成算法中的二分搜索，使平均运行时间从O(n log n)降到了O(n)。该程序在散列表中为元素使用了链表表示法，只增加了nwords个32位整数的额外空间，其中nwords是输入中的单词个数。</p>
<hr class="calibre2"/>
<p class="noindent" id="annot63">
<a href="part0018.xhtml#ref63">[1].</a>
 该书英文影印版已先后由中国电力出版社和机械工业出版社出版，中文书名分别为《算法设计与分计》和《计算机算法的设计与分析》，中译版已由机械工业出版社出版，书名为《计算机算法的设计与分析》。——编者注</p>
<p class="noindent" id="annot64">
<a href="part0018.xhtml#ref64">[2].</a>
 该书第2版中译版已由科学出版社出版，中文书名为《标准模板库自修教程与参考手册——STL进行C++编程》。——编者注</p>
<p class="noindent" id="annot65">
<a href="part0018.xhtml#ref65">[3].</a>
 原书为i++，有误。——译者注</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0017.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0019.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
