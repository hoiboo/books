<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>附录E 用于搜索的C++类</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc140">附录E 用于搜索的C++类</a>
</h1>
<p class="content">下面给出了第 13 章所讨论的 C++整数集合表示类的完整清单，本书网站上提供了完整的源代码。</p>
<p class="content">class IntSetSTL {</p>
<p class="content">private:</p>
<p class="content_5">set&lt;int&gt; S;</p>
<p class="content">public:</p>
<p class="content_5">IntSetSTL(int maxelms,int maxval) { }</p>
<p class="content_5">int size() { return S.size(); }</p>
<p class="content_5">void insert(int t) { S.insert(t);}</p>
<p class="content_5">void report(int *v)</p>
<p class="content_5">{ int j = 0;</p>
<p class="content_7">set&lt;int&gt;::iterator i;</p>
<p class="content_7">for (i = S.begin(); i != S.end(); ++i)</p>
<p class="content_8">v[j++] = *i;</p>
<p class="content_5">}</p>
<p class="content">};</p>
<p class="content">class IntSetArray {</p>
<p class="content">private:</p>
<p class="content_5">int n,*x;</p>
<p class="content">public:</p>
<p class="content_5">IntSetArray(int maxelms,int maxval)</p>
<p class="content_5">{ x = new int[1 + maxelms];</p>
<p class="content_7">n = 0;</p>
<p class="content_7">x[0] = maxval;</p>
<p class="content_5">}</p>
<p class="content_5">int size() { return n; }</p>
<p class="content_5">void insert(int t)</p>
<p class="content_5">{ for(int i = 0; x[i] &lt; t; i++)</p>
<p class="content_7">;</p>
<p class="content_6">if (x[i] == t)</p>
<p class="content_7">return;</p>
<p class="content_6">for (int j = n; j &gt;= i; j--)</p>
<p class="content_7">x[j+1] = x[j];</p>
<p class="content_6">x[i] = t;</p>
<p class="content_6">n++;</p>
<p class="content_5">}</p>
<p class="content_5">void report(int *v)</p>
<p class="content_5">{ for (int i = 0; i &lt; n; i++)</p>
<p class="content_7">v[i] = x[i];</p>
<p class="content_5">}</p>
<p class="content">};</p>
<p class="content">class IntSetList {</p>
<p class="content">private:</p>
<p class="content_5">int n;</p>
<p class="content_5">struct node {</p>
<p class="content_7">int val;</p>
<p class="content_7">node *next;</p>
<p class="content_7">node(int v,node *p) { val = v; next = p; }</p>
<p class="content_5">};</p>
<p class="content_5">node *head,*sentinel;</p>
<p class="content_5">node *rinsert(node *p,int t)</p>
<p class="content_5">{ if (p-&gt;val &lt; t) {</p>
<p class="content_7">p-&gt;next = rinsert(p-&gt;next,t);</p>
<p class="content_6">} else if (p-&gt;val &gt; t) {</p>
<p class="content_7">p = new node(t,p);</p>
<p class="content_7">n++;</p>
<p class="content_6">}</p>
<p class="content_6">return p;</p>
<p class="content_5">}</p>
<p class="content">public:</p>
<p class="content_5">IntSetList(int maxelms,int maxval)</p>
<p class="content_5">{ sentinel = head = new node(maxval,0);</p>
<p class="content_6">n = 0;</p>
<p class="content_5">}</p>
<p class="content_5">int size() { return n; }</p>
<p class="content_5">void insert(int t) { head = rinsert(head,t); }</p>
<p class="content_5">void report(int *v)</p>
<p class="content_5">{　int j = 0;</p>
<p class="content_6">for (node *p = head; p != sentinel; p = p-&gt;next)</p>
<p class="content_9">v[j++] = p-&gt;val;</p>
<p class="content_5">}</p>
<p class="content">};</p>
<p class="content">class IntSetBST {</p>
<p class="content">private:</p>
<p class="content_5">int n,*v,vn;</p>
<p class="content_5">struct node {</p>
<p class="content_7">int val;</p>
<p class="content_7">node *left,*right;</p>
<p class="content_7">node(int v) { val = v; left = right = 0; }</p>
<p class="content_5">};</p>
<p class="content_5">node *root;</p>
<p class="content_5">node *rinsert(node *p,int t)</p>
<p class="content_5">{ if(p == 0) {</p>
<p class="content_8">p = new node(t);</p>
<p class="content_8">n++;</p>
<p class="content_7">} else if (t &lt; p-&gt;val) {</p>
<p class="content_8">p-&gt;left = rinsert(p-&gt;left,t);</p>
<p class="content_7">} else if (t &gt; p-&gt;val) {</p>
<p class="content_8">p-&gt;right = rinsert(p-&gt;right,t);</p>
<p class="content_7">} // do nothing if p-&gt;val == t</p>
<p class="content_7">return p;</p>
<p class="content_5">}</p>
<p class="content_5">void traverse(node *p)</p>
<p class="content_5">{ if (p == 0)</p>
<p class="content_8">return;</p>
<p class="content_7">traverse(p-&gt;left);</p>
<p class="content_7">v[vn++] = p-&gt;val;</p>
<p class="content_7">traverse(p-&gt;right);</p>
<p class="content_5">}</p>
<p class="content">public:</p>
<p class="content_5">IntSetBST(int maxelms,int maxval) { root = 0; n = 0; }</p>
<p class="content_5">int size() { return n; }</p>
<p class="content_5">void insert(int t) { root = rinsert(root,t); }</p>
<p class="content_5">void report(int *x) { v = x; vn = 0; traverse(root); }</p>
<p class="content">};</p>
<p class="content">class IntSetBitVec {</p>
<p class="content">private:</p>
<p class="content_5">enum { BITSPERWORD = 32,SHIFT = 5,MASK = 0x1F };</p>
<p class="content_5">int n,hi,*x;</p>
<p class="content_5">void set(int i)　{　　　　x[i&gt;&gt;SHIFT] |=　(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content_5">void clr(int i)　{　　　　x[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content_5">int test(int i) { return x[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">public:</p>
<p class="content_5">IntSetBitVec(int maxelms,int maxval)</p>
<p class="content_5">{ hi = maxval;</p>
<p class="content_7">x = new int[1 + hi/BITSPERWORD];</p>
<p class="content_7">for (int i = 0; i &lt; hi; i++)</p>
<p class="content_8">clr(i);</p>
<p class="content_7">n = 0;</p>
<p class="content_5">}</p>
<p class="content_5">int size() { return n; }</p>
<p class="content_5">void insert(int t)</p>
<p class="content_5">{ if (test(t))</p>
<p class="content_8">return;</p>
<p class="content_7">set(t);</p>
<p class="content_7">n++;</p>
<p class="content_5">}</p>
<p class="content_5">void report(int *v)</p>
<p class="content_5">{ int j=0;</p>
<p class="content_7">for (int i = 0; i &lt; hi; i++)</p>
<p class="content_8">if (test(i))</p>
<p class="content_14">v[j++] = i;</p>
<p class="content_5">}</p>
<p class="content">};</p>
<p class="content">class IntSetBins {</p>
<p class="content">private:</p>
<p class="content_5">int n,bins,maxval;</p>
<p class="content_5">struct node {</p>
<p class="content_7">int val;</p>
<p class="content_7">node *next;</p>
<p class="content_7">node(int v,node *p) { val = v; next = p; }</p>
<p class="content_5">};</p>
<p class="content_5">node **bin,*sentinel;</p>
<p class="content_5">node *rinsert(node *p,int t)</p>
<p class="content_5">{ if (p-&gt;val &lt; t) {</p>
<p class="content_8">p-&gt;next = rinsert(p-&gt;next,t);</p>
<p class="content_7">} else if (p-&gt;val &gt; t) {</p>
<p class="content_8">p = new node(t,p);</p>
<p class="content_8">n++;</p>
<p class="content_7">}</p>
<p class="content_7">return p;</p>
<p class="content_5">}</p>
<p class="content">public:</p>
<p class="content_5">IntSetBins(int maxelms,int pmaxval)</p>
<p class="content_5">{ bins = maxelms;</p>
<p class="content_7">maxval = pmaxval;</p>
<p class="content_7">bin = new node*[bins];</p>
<p class="content_7">sentinel = new node(maxval,0);</p>
<p class="content_7">for (int i = 0; i &lt; bins; i++)</p>
<p class="content_8">bin[i] = sentinel;</p>
<p class="content_7">n = 0;</p>
<p class="content_5">}</p>
<p class="content_5">int size() { return n; }</p>
<p class="content_5">void insert(int t)</p>
<p class="content_5">{ int i = t / (1 + maxval/bins);</p>
<p class="content_7">bin[i] = rinsert(bin[i],t);</p>
<p class="content_5">}</p>
<p class="content_5">void report(int *v)</p>
<p class="content_5">{ int j = 0;</p>
<p class="content_7">for (int i = 0; i &lt; bins; i++)</p>
<p class="content_8">for (node *p = bin[i]; p != sentinel; p = p-&gt;next)</p>
<p class="content_14">v[j++] = p-&gt;val;</p>
<p class="content_5">}</p>
<p class="content">};</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0015.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0017.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
