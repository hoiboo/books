<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>第一部分 基础</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc8">第一部分 基础</a>
</h1>
<p class="content">这一部分的5章回顾程序设计的基础知识。第1章介绍一个问题的历史，我们把仔细的问题定义和直接的程序设计技术结合起来，得到优美的解决方案。这一章揭示了本书的中心思想：对实例研究的深入思考不仅很有趣，而且可以获得实际的益处。</p>
<p class="content">第2章讨论3个问题，其中重点强调了如何由算法的融会贯通获得简单而高效的代码。第3章总结数据结构在软件设计中所起到的关键作用。</p>
<p class="content">第4章介绍一个编写正确代码的工具——程序验证。在第9章、第11章和第14章中生成复杂（且快速）的函数时，大量使用了程序验证技术。第5章讲述如何把这些抽象的程序变成实际代码：使用脚手架程序来探测函数，用测试用例来测试函数并度量函数的性能。</p>
<p class="content">本部分内容</p>
<p class="content_">第1章 开篇</p>
<p class="content_">第2章 啊哈! 算法</p>
<p class="content_">第3章 数据决定程序结构</p>
<p class="content_">第4章 编写正确的程序</p>
<p class="content_">第5章 编程小事</p>
<h2 class="secondtitle" id="bw1">
<a href="part0000.xhtml#toc9">第1章 开篇</a>
</h2>
<p class="content">一位程序员曾问我一个很简单的问题：“怎样给一个磁盘文件排序？”想当年我是一上来就犯了错误，现在，在讲这个故事之前，先给大家一个机会，看看能否比我当年做得更好。你会怎样回答上述问题呢？</p>
<h3 class="thirdtitle" id="bw2">
<a href="part0000.xhtml#toc10">1.1 一次友好的对话</a>
</h3>
<p class="content">我错就错在马上回答了这个问题。我告诉他一些有关如何在磁盘上实现归并排序的简要思路。我建议他深入研究算法教材，他似乎不太感冒。他更关心如何解决这个问题，而不是深入学习。于是我告诉他在一本流行的程序设计书里有磁盘排序的程序。那个程序有大约200行代码和十几个函数，我估计他最多需要一周时间来实现和测试该代码。</p>
<p class="content">我以为已经解决了他的问题，但是他的踌躇使我返回到了正确的轨道上。其后就有了下面的对话，楷体部分是我的问题。</p>
<p class="content">为什么非要自己编写排序程序呢？为什么不用系统提供的排序功能呢？</p>
<p class="content">我需要在一个大系统中排序。由于不明的技术原因，我不能使用系统中的文件排序程序。</p>
<p class="content">需要排序的内容是什么？文件中有多少条记录？每条记录的格式是什么？</p>
<p class="content">文件最多包含1千万条记录，每条记录都是7位的整数。</p>
<p class="content">等一下，既然文件这么小，何必非要在磁盘上进行排序呢？为什么不在内存里进行排序呢？</p>
<p class="content">尽管机器有许多兆字节的内存，但排序功能只是大系统中的一部分，所以，估计到时只有1 MB的内存可用。</p>
<p class="content">你还能告诉我其他一些与记录相关的信息吗？</p>
<p class="content">每条记录都是7位的正整数，再无其他相关数据。每个整数最多只出现一次。</p>
<p class="content">这番对话让问题更明确了。在美国，电话号码由3位“区号”后再跟7位数字组成。拨打含“免费”区号800（当时只有这一个号码）的电话是不收费的。实际的免费电话号码数据库包含大量的信息：免费电话号码、呼叫实际中转到的号码（有时是几个号码，这时需要一些规则来决定哪些呼叫在什么时间中转到哪里）、主叫用户的姓名和地址等。</p>
<p class="content">这位程序员正在开发这类数据库的处理系统的一小部分，需要排序的整数就是免费电话号码。输入文件是电话号码的列表（已删除所有其他信息），号码重复出现算出错。期望的输出文件是以升序排列的电话号码列表。应用背景同时定义了相应的性能需求。当与系统的会话时间较长时，用户大约每小时请求一次有序文件，并且在排序未完成之前什么都干不了。因此，排序最多只允许执行几分钟，10秒钟是比较理想的运行时间。</p>
<h3 class="thirdtitle" id="bw3">
<a href="part0000.xhtml#toc11">1.2 准确的问题描述</a>
</h3>
<p class="content">对程序员来说，这些需求加起来就是：“如何给磁盘文件排序？”在试图解决这个问题之前，先将已知条件组织成一种更客观、更易用的形式。</p>
<p class="content">输入：一个最多包含 n 个正整数的文件，每个数都小于 n，其中 n=10<span class="super">7</span>
 。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。</p>
<p class="content">输出：按升序排列的输入整数的列表。</p>
<p class="content">约束：最多有（大约）1 MB的内存空间可用，有充足的磁盘存储空间可用。运行时间最多几分钟，运行时间为10秒就不需要进一步优化了。</p>
<p class="content">请花上一分钟思考一下该问题的规范说明。现在你打算给程序员什么样的建议呢？</p>
<h3 class="thirdtitle" id="bw4">
<a href="part0000.xhtml#toc12">1.3 程序设计</a>
</h3>
<p class="content">显而易见的方法是以一般的基于磁盘的归并排序程序为起点，但是要对其进行调整，因为我们是对整数进行排序。这样就可以将原来的200行程序减少为几十行，同时也使得程序运行得更快，但是完成程序并使之运行可能仍然需要几天的时间。</p>
<p class="content">另一种解决方案更多地利用了该排序问题的特殊性。如果每个号码都使用7个字节来存储，那么在可用的1 MB存储空间里大约可以存143 000个号码。如果每个号码都使用32位整数来表示的话，在1 MB存储空间里就可以存储250 000个号码。因此，可以使用遍历输入文件40趟的程序来完成排序。在第一趟遍历中，将0至249 999之间的任何整数都读入内存，并对这（最多）250 000 个整数进行排序，然后写到输出文件中。第二趟遍历排序250 000至499 999之间的整数，依此类推，到第40趟遍历的时候对9 750 000至9 999 999之间的整数进行排序。对内存中的排序来说，快速排序会相当高效，而且仅仅需要20 行代码（见第11章）。于是，整个程序就可以通过一两页纸的代码实现。该程序拥有所期望的特性——不必考虑使用中间磁盘文件；但是，为此所付出的代价是要读取输入文件40次。</p>
<p class="content">归并排序读入输入文件一次，然后在工作文件的帮助下完成排序并写入输出文件一次。工作文件需要多次读写。</p>
<div class="bodypic_"><img alt="工作文件多次输入文件 归并排序 输出文件" src="../Images/image00180.jpeg" class="calibre3"/>
</div>
<p class="content">40趟算法读入输入文件多次，写输出文件仅一次，不使用中间文件。</p>
<div class="bodypic_"><img alt="输入文件 多趟排序 输出文件" src="../Images/image00181.jpeg" class="calibre3"/>
</div>
<p class="content">下图所示的方案更可取。我们结合上述两种方法的优点，读输入文件仅一次，且不使用中间文件。</p>
<div class="bodypic_"><img alt="输入文件 神奇排序 输出文件" src="../Images/image00182.jpeg" class="calibre3"/>
</div>
<p class="content">只有在输入文件中的所有整数都可以在可用的1 MB内存中表示的时候才能够实现该方案。于是问题就归结为是否能够用大约800万个可用位来表示最多1 000万个互异的整数。考虑一种合适的表示方式。</p>
<h3 class="thirdtitle" id="bw5">
<a href="part0000.xhtml#toc13">1.4 实现概要</a>
</h3>
<p class="content">由是观之，应该用位图或位向量表示集合。可用一个 20 位长的字符串来表示一个所有元素都小于 20 的简单的非负整数集合。例如，可以用如下字符串来表示集合{1,2,3,5,8,13}：</p>
<p class="content">0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0</p>
<p class="content">代表集合中数值的位都置为1，其他所有的位都置为0。</p>
<p class="content">在我们的实际问题中，每个7位十进制整数表示一个小于1 000万的整数。我们使用一个具有1 000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1。（那个程序员后来找到了200万个稀疏位，习题5研究了最大存储空间严格限制为1 MB的情况。）这种表示利用了该问题的三个在排序问题中不常见的属性：输入数据限制在相对较小的范围内；数据没有重复；而且对于每条记录而言，除了单一整数外，没有任何其他关联数据。</p>
<p class="content">若给定表示文件中整数集合的位图数据结构，则可以分三个自然阶段来编写程序。第一阶段将所有的位都置为 0，从而将集合初始化为空。第二阶段通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。第三阶段检验每一位，如果该位为1，就输出对应的整数，由此产生有序的输出文件。令n为位向量中的位数（在本例中为10 000 000），程序可以使用伪代码表示如下：</p>
<p class="content">/* phase 1: initialize set to empty */</p>
<p class="content_4">for i = [0,n)</p>
<p class="content_5">bit[i] = 0</p>
<p class="content">/* phase 2: insert present elements into the set */</p>
<p class="content_4">for each i in the input file</p>
<p class="content_5">bit[i] = 1</p>
<p class="content">/* phase 3: write sorted output */</p>
<p class="content_4">for i = [0,n)</p>
<p class="content_5">if bit[i] == 1</p>
<p class="content_6">write i on the output file</p>
<p class="content">（回想在前言中所提到的，for i=[0,n)表示在从0至n-1的范围内对i进行迭代。）</p>
<p class="content">这个实现概要已经足以解决那个程序员的问题了。习题2、习题5和习题7描述了他会遇到的一些实现细节。</p>
<h3 class="thirdtitle" id="bw6">
<a href="part0000.xhtml#toc14">1.5 原理</a>
</h3>
<p class="content">那个程序员打电话把他的问题告诉我，然后我们花了大约一刻钟时间明确了问题所在，并找到了位图解决方案。他花了几个小时来实现这个几十行代码的程序。该程序远远优于我们在电话刚开始时所担心的需要花费一周时间编写的几百行代码的那个程序。而且程序执行得很快：磁盘上的归并排序可能需要许多分钟的时间，该程序所需的时间只比读取输入和写入输出所需的时间多一点点——大约 10 秒钟。答案 3包含了对完成该任务的几种不同程序的计时细节。</p>
<p class="content">从这些事实中可以总结出该实例研究所得到的第一个结论：对小问题的仔细分析有时可以得到明显的实际益处。在该实例中，几分钟的仔细研究可以大幅削减代码的长度、程序员时间和程序运行时间。Chuck Yeager将军（第一个超音速飞行的人）赞扬一架飞机的机械系统时用的词是“结构简单、部件很少、易于维护、非常坚固”，该程序拥有同样的属性。然而，当规范说明的某些因素发生改变时，该程序的特殊结构将很难修改。除了需要精巧的编程以外，该实例阐明了如下一般原理。</p>
<p class="content">正确的问题。明确问题，这场战役就成功了90%——我很庆幸程序员没有满足于我给出的第一个程序。一旦正确理解了问题，习题10、习题11和习题12的答案都会很优雅。在查看提示和答案以前，请努力思考这些问题。</p>
<p class="content">位图数据结构。该数据结构描述了一个有限定义域内的稠密集合，其中的每一个元素最多出现一次并且没有其他任何数据与该元素相关联。即使这些条件没有完全满足（例如，存在重复元素或额外的数据），也可以用有限定义域内的键作为一个表项更复杂的表格的索引，见习题6和习题8。</p>
<p class="content">多趟算法。这些算法多趟读入其输入数据，每次完成一步。在1.3节已经见到了一个40趟算法，习题5鼓励读者去完成一个两趟算法。</p>
<p class="content">时间—空间折中与双赢。编程文献和理论中充斥着时间—空间的折中：通过使用更多的时间，可以减少程序所需的空间。例如，答案5中的两趟算法让程序运行时间加倍从而使空间减半。但我的经验常常是这样的：减少程序的空间需求也会减少其运行时间。<span id="ref3">
<a href="part0007.xhtml#annot3">[1]</a>
</span>
 空间上高效的位图结构显著地减少了排序的运行时间。空间需求的减少之所以会导致运行时间的减少，有两个原因：需要处理的数据变少了，意味着处理这些数据所需的时间也变少了；同时将这些数据保存在内存中而不是磁盘上，进一步避免了磁盘访问的时间。当然了，只有在原始的设计远非最佳方案时，才有可能时空双赢。</p>
<p class="content">简单的设计。Antoine de Saint-Exupéry是法国作家兼飞机设计师，他曾经说过：“设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。”更多的程序员应该使用该标准来检验自己完成的程序。简单的程序通常比具有相同功能的复杂的程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。</p>
<p class="content">程序设计的阶段。这个实例揭示了12.4节详细描述的设计过程。</p>
<h3 class="thirdtitle" id="bw7">
<a href="part0000.xhtml#toc15">1.6 习题</a>
</h3>
<p class="content">部分习题的提示和答案可以在本书后面找到。</p>
<p class="content">1.如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</p>
<p class="content">2.如何使用位逻辑运算（如与、或、移位）来实现位向量？</p>
<p class="content">3.运行时效率是设计目标的一个重要组成部分，所得到的程序需要足够高效。在你自己的系统上实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题1中排序的运行时间相比如何？假设n为10 000 000，且输入文件包含1 000 000个整数。</p>
<p class="content">4.如果认真考虑了习题3，你将会面对生成小于n且没有重复的k个整数的问题。最简单的方法就是使用前k个正整数。这个极端的数据集合将不会明显地改变位图方法的运行时间，但是可能会歪曲系统排序的运行时间。如何生成位于0至n-1之间的k个不同的随机顺序的随机整数？尽量使你的程序简短且高效。</p>
<p class="content">5.那个程序员说他有1 MB的可用存储空间，但是我们概要描述的代码需要1.25 MB的空间。他可以不费力气地索取到额外的空间。如果1 MB空间是严格的边界，你会推荐如何处理呢？你的算法的运行时间又是多少？</p>
<p class="content">6.如果那个程序员说的不是每个整数最多出现一次，而是每个整数最多出现10次，你又如何建议他呢？你的解决方案如何随着可用存储空间总量的变化而变化？</p>
<p class="content">7.[R.Weil]本书1.4节中描述的程序存在一些缺陷。首先是假定在输入中没有出现两次的整数。如果某个数出现超过一次的话，会发生什么？在这种情况下，如何修改程序来调用错误处理函数？当输入整数小于零或大于等于n时，又会发生什么？如果某个输入不是数值又如何？在这些情况下，程序该如何处理？程序还应该包含哪些明智的检查？描述一些用以测试程序的小型数据集合，并说明如何正确处理上述以及其他的不良情况。</p>
<p class="content">8.当那个程序员解决该问题的时候，美国所有免费电话的区号都是800。现在免费电话的区号包括800、877和888，而且还在增多。如何在1 MB空间内完成对所有这些免费电话号码的排序？如何将免费电话号码存储在一个集合中，要求可以实现非常快速的查找以判定一个给定的免费电话号码是否可用或者已经存在？</p>
<p class="content">9.使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。说明如何设计一种技术，在第一次访问向量的项时将其初始化为0。你的方案应该使用常量时间进行初始化和向量访问，使用的额外空间应正比于向量的大小。因为该方法通过进一步增加空间来减少初始化的时间，所以仅在空间很廉价、时间很宝贵且向量很稀疏的情况下才考虑使用。</p>
<p class="content">10.在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的主关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？</p>
<p class="content">11.在20世纪80年代早期，洛克希德公司加利福尼亚州桑尼维尔市工厂的工程师们每天都要将许多由计算机辅助设计（CAD）系统生成的图纸从工厂送到位于圣克鲁斯市的测试站。虽然仅有40公里远，但使用汽车快递服务每天都需要一个多小时的时间（由于交通阻塞和山路崎岖），花费100美元。请给出新的数据传输方案并估计每一种方案的费用。</p>
<p class="content">12.载人航天的先驱们很快就意识到需要在外太空的极端环境下实现顺利书写。民间盛传美国国家宇航局（NASA）花费100万美元研发出了一种特殊的钢笔来解决这个问题。那么，前苏联又会如何解决相同的问题呢？</p>
<h3 class="thirdtitle" id="bw8">
<a href="part0000.xhtml#toc16">1.7 深入阅读</a>
</h3>
<p class="content">这个小练习仅仅是令人痴迷的程序说明问题的冰山一角。要深入研究这个重要的课题，参见 Michael Jackson <span id="ref4">
<a href="part0007.xhtml#annot4">[2]</a>
</span>
 的 Software Requirements &amp; Specifications 一书（Addison-Wesley 出版社 1995 年出版）。该书用一组独立成章却又相辅相成的短文，以令人愉悦的方式阐述了这个艰涩的课题。</p>
<p class="content">在本章所描述的实例研究中，程序员的主要问题与其说是技术问题，还不如说是心理问题：他不能解决问题，是因为他企图解决错误的问题。问题的最终解决，是通过打破他的概念壁垒，进而去解决一个较简单的问题而实现的。James L.Adams所著的Conceptuel Blockbusting一书（第3版由Perseus出版社于1986年出版）研究了这类跳跃，该书通常是触发创新性思维的理想选择。虽然该书不是专为程序员而写的，其中的许多内容却特别适用于编程问题。Adams将概念壁垒定义为“阻碍解题者正确理解问题或取得答案的心智壁垒”。习题10、习题11和习题12激励读者去打破一些这样的壁垒。</p>
<h2 class="secondtitle" id="bw9">
<a href="part0000.xhtml#toc17">第2章 啊哈！算法</a>
</h2>
<p class="content">研究算法给实际编程的程序员带来许多好处。算法课教给学生完成重要任务的方法和解决新问题的技术。在后续的章节中将会看到，先进的算法工具有时候对软件系统影响很大——减少开发时间，同时使执行速度更快。</p>
<p class="content">算法与其他那些深奥的思想一样重要，但在更一般的编程层面上具有更重要的影响。在《啊哈!灵机一动》一书中（本章的标题就借鉴了它），Martin Gardner<span id="ref5">
<a href="part0007.xhtml#annot5">[3]</a>
</span>
 描述了深得我心的一个思想：“看起来很困难的问题也可以有一个简单的、意想不到的答案。”与高级的方法不同，算法的啊哈！灵机一动并非只有在大量的研究以后才能出现；任何愿意在编程之前、之中和之后进行认真思考的程序员都有机会捕捉到这灵机一动。</p>
<h3 class="thirdtitle" id="bw10">
<a href="part0000.xhtml#toc18">2.1 三个问题</a>
</h3>
<p class="content">好了，泛泛的话讲得够多啦。本章将围绕三个小问题展开。在继续阅读以前，请先试着解决它们。</p>
<p class="content">A.给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数（在文件中至少缺失一个这样的数——为什么？）。在具有足够内存的情况下，如何解决该问题？如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题？</p>
<p class="content">B.将一个n元一维向量向左旋转<span id="ref6">
<a href="part0007.xhtml#annot6">[4]</a>
</span>
 i个位置。例如，当n=8且i=3时，向量abcdefgh旋转为defghabc。简单的代码使用一个n元的中间向量在n步内完成该工作。你能否仅使用数十个额外字节的存储空间，在正比于n的时间内完成向量的旋转?</p>
<p class="content">C.给定一个英语字典，找出其中的所有变位词集合。例如，“pots”、“stop”和“tops”互为变位词，因为每一个单词都可以通过改变其他单词中字母的顺序来得到。</p>
<h3 class="thirdtitle" id="bw11">
<a href="part0000.xhtml#toc19">2.2 无处不在的二分搜索</a>
</h3>
<p class="content">我想到的一个数在1到100之间，你来猜猜看。50？太小了。75？太大了。如此，游戏进行下去，直到你猜中我想到的数为止。如果我的整数位于1到n之间，那么你可以在log<span class="sub">2</span>
 n次之内猜中。如果n是1 000，10次就可以完成；如果n是100万，则最多20次就可以完成。</p>
<p class="content">这个例子引出了一项可以解决众多编程问题的技术：二分搜索。初始条件是已知一个对象存在于一个给定的范围内，而一次探测操作可以告诉我们该对象是否低于、等于或高于给定的位置。二分搜索通过重复探测当前范围的中点来定位对象。如果一次探测没有找到该对象，那么我们将当前范围减半，然后继续下一次探测。当找到所需要的对象或范围为空时停止。</p>
<p class="content">在程序设计中二分搜索最常见的应用是在有序数组中搜索元素。在查找项50时，算法进行如下探测。</p>
<div class="bodypic_"><img alt="" src="../Images/image00183.jpeg" class="calibre3"/>
</div>
<p class="content">众所周知，二分搜索程序要正确运行很困难。在第4章中我们将详细研究其代码。</p>
<p class="content">顺序搜索在搜索一个具有n个元素的表时，平均需要进行n/2次比较，而二分搜索仅仅进行不超过log<span class="sub">2</span>
 n次的比较就可以完成。这在系统性能上会造成巨大的差异。下面的故事来自于《ACM通讯》的实例研究“TWA Reservation System”。</p>
<p class="content">我们有一个执行线性搜索的程序，可以在1秒钟内对一块非常巨大的内存块完成100次搜索。随着网络的增长，处理每条消息所需的平均CPU时间上升了0.3毫秒，这对我们来说是巨大的变化。我们发现问题的根源是线性搜索。把程序改为使用二分搜索以后，该问题消失了。</p>
<p class="content">我在许多系统中也遇到过相同的问题。程序员在开始的时候使用简单的顺序搜索数据结构，这在开始的时候通常都足够快。当搜索变得太慢的时候，对表进行排序并使用二分搜索通常可以消除瓶颈。</p>
<p class="content">但是二分搜索的故事并没有在快速搜索有序数组这里终止。Roy Weil将该技术应用于清理一个约 1000 行的输入文件，其中仅包含一个错误行。很不幸，肉眼看不出错误行。只能通过在程序中运行文件的一个（起始）部分并且观察到离奇错误的答案来辨别，这将会花费几分钟的时间。他的前任调试人员试图通过每次运行整个程序中的少数几行程序来找出错误行，但只在取得解决方案的道路上前进了一点点。Weil是如何仅仅运行10次程序就找到罪魁祸首的呢？</p>
<p class="content">经过前面的热身，我们现在来攻克问题 A。输入为顺序文件（考虑磁带或磁盘——虽然磁盘可以随机读写，但是从头至尾读取文件通常会快得多）。文件包含最多40亿个随机排列的32位整数，而我们需要找出一个不存在于该文件中的32位整数。（至少缺少一个整数，因为一共有232也就是4 294 967 296个这样的整数。）如果有足够的内存，可以采用第1章中介绍的位图技术，使用536 870 912个8位字节形成位图来表示已看到的整数。然而，该问题还问到在仅有几百个字节内存和几个稀疏顺序文件的情况下如何找到缺失的整数？为了采用二分搜索技术，就必须定义一个范围、在该范围内表示元素的方式以及用来确定哪一半范围存在缺失整数的探测方法。如何来实现呢？</p>
<p class="content">我们采用已知包含至少一个缺失元素的一系列整数作为范围，并使用包含所有这些整数在内的文件表示这个范围。灵机一动的结果是通过统计中间点之上和之下的元素来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此我们所需的那一半范围中必然也包含缺失的元素。这些就是解决该问题的二分搜索算法所需要的主要想法。在翻阅答案查看Ed Reingold是如何做的以前，请尝试将这些想法组织起来。</p>
<p class="content">对于二分搜索技术在程序设计中的应用来说，这些应用仅仅是皮毛而已。求根程序使用二分搜索技术，通过连续地对分区间来求解单变量方程式（数值分析家称之为对分法）。当答案11.9中的选择算法区分出一个随机元素以后，就对该元素一侧的所有元素递归地调用自身（这是一种随机二分搜索）。其他使用二分搜索的地方包括树数据结构和程序调试（当程序没有任何提示就意外中止时，你会从源代码中哪一部分开始探测来定位错误语句呢？）。在上述的每个例子中，分析程序并对二分搜索算法做些许修改，可以带给程序员功能强大的啊哈！灵机一动。</p>
<h3 class="thirdtitle" id="bw12">
<a href="part0000.xhtml#toc20">2.3 基本操作的威力</a>
</h3>
<p class="content">二分搜索是许多问题的解决方案，下面研究一个有几种解决方案的问题。问题B仅使用几十个字节的额外空间将一个n元向量x在正比于n的时间内向左旋转i个位置。该问题在应用程序中以各种不同的伪装出现。在一些编程语言中，该功能是向量的一个基本操作。更重要地，旋转操作对应于交换相邻的不同大小的内存块：每当拖动文件中的一块文字到其他地方时，就要求程序交换两块内存中的内容。在许多应用场合下，运行时间和存储空间的约束会很严格。</p>
<p class="content">可以通过如下方式解决该问题：首先将x的前i个元素复制到一个临时数组中，然后将余下的n－i个元素向左移动i个位置，最后将最初的i个元素从临时数组中复制到x中余下的位置。但是，这种办法使用的i个额外的位置产生了过大的存储空间的消耗。另一种方法是定义一个函数将x向左旋转一个位置（其时间正比于n）然后调用该函数i次。但该方法又产生了过多的运行时间消耗。</p>
<p class="content">要在有限的资源内解决该问题，显然需要更复杂的程序。有一个成功的方法有点像精巧的杂技动作：移动x[0]到临时变量t，然后移动x[i]至x[0]，x[2i]至x[i]，依此类推（将x中的所有下标对n取模），直至返回到取x[0]中的元素，此时改为从t取值然后终止过程。当i为3且n为12时，元素按如下顺序移动。</p>
<div class="bodypic_"><img alt="" src="../Images/image00184.jpeg" class="calibre3"/>
</div>
<p class="content">如果该过程没有移动全部元素，就从x[1]开始再次进行移动，直到所有的元素都已经移动为止。习题3要求读者将该思想还原为代码，务必小心。</p>
<p class="content">从另外一面考察这个问题，可以得到一个不同的算法：旋转向量x其实就是交换向量ab的两段，得到向量ba。这里a代表x中的前i个元素。假设a比b短，将b分为b<span class="sub">l</span>
 和b<span class="sub">r</span>
 ，使得b<span class="sub">r</span>
 具有与a相同的长度。交换a和b<span class="sub">r</span>
 ，也就将ab<span class="sub">l</span>
 b<span class="sub">r</span>
 转换为b<span class="sub">r</span>
 b<span class="sub">l</span>
 a。序列a此时已处于其最终的位置，因此现在的问题就集中到交换b的两部分。由于新问题与原来的问题具有相同的形式，我们可以递归地解决之。使用该算法可以得到优雅的程序（答案3描述了Gries和Mills的迭代解决方案），但是需要巧妙的代码，并且要进行一些思考才能看出它的效率足够高。</p>
<p class="content">问题看起来很难，除非最终获得了啊哈！灵机一动：我们将问题看做是把数组ab转换成ba，同时假定我们拥有一个函数可以将数组中特定部分的元素求逆。从ab开始，首先对a求逆，得到a<span class="super">r</span>
 b，然后对b求逆，得到a<span class="super">r</span>
 b<span class="super">r</span>
 。最后整体求逆，得到(a<span class="super">r</span>
 b<span class="super">r</span>
 )<span class="super">r</span>
 。此时就恰好是ba。于是，我们得到了如下用于旋转的代码，其中注释部分表示abcdefgh向左旋转三个位置以后的结果。</p>
<p class="content">reverse(0,i-1)　　/* cbadefgh */</p>
<p class="content">reverse(i,n-1)　　/* cbahgfed */</p>
<p class="content">reverse(0,n-1)　　/* defghabc */</p>
<p class="content">Doug McIlroy<span id="ref7">
<a href="part0007.xhtml#annot7">[5]</a>
</span>
 给出了将十元数组向上旋转5个位置的翻手例子。初始时掌心对着我们的脸，左手在右手上面。</p>
<div class="bodypic_"><img alt="翻转左手 翻转右手 翻转双手" src="../Images/image00185.jpeg" class="calibre3"/>
</div>
<p class="content">翻转代码在时间和空间上都很高效，而且代码非常简短，很难出错。Brian Kernighan<span id="ref8">
<a href="part0007.xhtml#annot8">[6]</a>
</span>
 和P.J.Plauger<span id="ref9">
<a href="part0007.xhtml#annot9">[7]</a>
</span>
 在其1981年出版的Software Tools in Pascal一书中，就使用该代码在文本编辑器中实现了行的移动。Kernighan 报告称在第一次执行的时候程序就正确运行了，而他们先前基于链表的处理相似任务的代码则包含几个错误。该代码用在几个文本处理系统中，其中包括我最初用于录入本章内容的文本编辑器。Ken Thompson<span id="ref10">
<a href="part0007.xhtml#annot10">[8]</a>
</span>
 在1971年编写了编辑器和这种求逆代码，甚至在那时就主张把该代码当作一种常识。</p>
<h3 class="thirdtitle" id="bw13">
<a href="part0000.xhtml#toc21">2.4 排序</a>
</h3>
<p class="content">现在我们来讨论问题C。给定一本英语单词字典（每个输入行是一个由小写字母组成的单词），要求找出所有的变位词分类。研究这个问题可以举出许多理由。首先是技术上的：获得这个问题的解决方案需要既具有正确的视角又能使用正确的工具。第二个理由更具有说服力：你总不想成为聚会中唯一一个不知道“deposit”、“dopiest”、“posited”和“topside”是变位词的人吧？如果这些理由还嫌不够，可以看一下习题6描述的现实系统中的一个相似的问题。</p>
<p class="content">解决这个问题的许多方法都出奇地低效和复杂。任何一种考虑单词中所有字母的排列的方法都注定了要失败。单词“cholecystoduodenostomy”（我的字典中单词“duodenocholecystostomy”的一个变位词）有22！种排列，少量的乘法运算表明22! ≈1.124 × 10<span class="super">21</span>
 。即使假设以闪电一样的速度每百亿分之一秒执行一种排列，这也要消耗1.1 × 10<span class="super">9</span>
 秒。经验法则“π秒就是一个纳世纪”（见7.1节）指出1.1 × 10<span class="super">9</span>
 是数十年。而比较所有单词对的任何方法在我的机器上运行至少要花费一整夜的时间——在我使用的字典里有大约230 000个单词，而即使是一个简单的变位词比较也将花费至少1 微秒的时间，因此，总时间估算起来就是</p>
<p class="content">230 000单词× 230 000比较/单词× 1微秒/比较=52 900× 10<span class="super">6</span>
 微秒=52 900秒≈14.7小时</p>
<p class="content">你能够找到同时避免上述缺陷的方法吗？</p>
<p class="content">我们获得的啊哈！灵机一动就是标识字典中的每一个词，使得在相同变位词类中的单词具有相同的标识。然后，将所有具有相同标识的单词集中在一起。这将原始的变位词问题简化为两个子问题：选择标识和集中具有相同标识的单词。在进一步阅读之前，先好好想想这些问题。</p>
<p class="content">对第一个问题，我们可以使用基于排序的标识<span id="ref11">
<a href="part0007.xhtml#annot11">[9]</a>
</span>
 ：将单词中的字母按照字母表顺序排列。“deposit”的标识就是“deiopst”，这也是“dopiest”和其他任何在该类中的单词的标识。要解决第二个问题，我们将所有的单词按照其标识的顺序排序。我所知道的关于该算法的最好描述就是Tom Cargill的翻手表示：先用一种方式排序（水平翻手），再用另一种方式排序（垂直翻手）。2.8节描述了该算法的一个实现。</p>
<h3 class="thirdtitle" id="bw14">
<a href="part0000.xhtml#toc22">2.5 原理</a>
</h3>
<p class="content">排序。排序最显而易见的用处是产生有序的输出，该输出既可以是系统规范要求的一部分，也可以是另一个程序（也许是一个二分搜索程序）的前期准备工作。但是在变位词问题中，排序并不是关注的焦点。排序是为了将相等的元素（本例中为标识）集中到一起。这些标识产生了另外一个排序应用：将单词内字母排序使得同一个变位词类中的单词具有标准型。通过给每条记录添加一个额外的键，并按照这些键进行排序，排序函数可以用于重新排列磁盘文件中的数据。在第三部分，我们还会多次回顾排序这个主题。</p>
<p class="content">二分搜索。该算法在有序表中查找元素时极为高效，并且可用于内存排序或磁盘排序。唯一的缺陷就是整个表必须已知并且事先排好序。基于该简单算法的思想在许多应用程序中都有应用。</p>
<p class="content">标识。当使用等价关系来定义类时，定义一种标识使得类中的每一项都具有相同的标识，而该类以外的其他项则没有该标识，这是很有用的。对单词中的字母排序可以产生一个用于变位词类的标识。其他标识通过排序给出。然后使用一个计数来代表重复的次数（于是标识“mississippi”可以写成“i4m1p2s4”或将1省略——“i4mp2s4”）。也可以使用一个包含 26 个整数的数组来标识每个字母出现的次数。标识的其他应用包括：美国联邦调查局用来索引指纹的方法，以及用来识别读音相同但是拼写不同的名字的Soundex启发式方法：</p>
<div class="bodypic_"><img alt="名字Smith Smythe Schultz Shultz Soundex标识s530 s530 s243 s432" src="../Images/image00186.jpeg" class="calibre3"/>
</div>
<p class="content">Knuth<span id="ref12">
<a href="part0007.xhtml#annot12">[10]</a>
</span>
 在其The Art of Computer Programming,Volume 3:Sorting and Sear ching<span id="ref13">
<a href="part0007.xhtml#annot13">[11]</a>
</span>
 一书的第6章描述了Soundex方法。</p>
<p class="content">问题定义。第1章指出确定用户的真实需求是程序设计的根本。本章的中心思想是问题定义的下一步：使用哪些基本操作来解决问题？在本章的每个例子中，啊哈！灵机一动都定义了一个新的基本操作使得问题得到简化。</p>
<p class="content">问题解决者的观点。优秀程序员都有点懒：他们坐下来并等待灵机一动的出现而不急于使用最开始的想法编程。当然，这必须通过在适当的时候开始写代码来加以平衡。真正的技能就在于对这个适当时候的把握，这只能来源于解决问题和反思答案所获得的经验。</p>
<h3 class="thirdtitle" id="bw15">
<a href="part0000.xhtml#toc23">2.6 习题</a>
</h3>
<p class="content">1.考虑查找给定输入单词的所有变位词问题。仅给定单词和字典的情况下，如何解决该问题？如果有一些时间和空间可以在响应任何查询之前预先处理字典，又会如何？</p>
<p class="content">2.给定包含4 300 000 000个32位整数的顺序文件，如何找出一个出现至少两次的整数？</p>
<p class="content">3.前面涉及了两个需要精巧代码来实现的向量旋转算法。将其分别作为独立的程序实现。在每个程序中，i和n的最大公约数如何出现？</p>
<p class="content">4.几位读者指出，既然所有的三个旋转算法需要的运行时间都正比于n，杂技算法的运行速度显然是求逆算法的两倍。杂技算法对数组中的每个元素仅存储和读取一次，而求逆算法需要两次。在实际的计算机上进行实验以比较两者的速度差异，特别注意内存引用位置附近的问题。</p>
<p class="content">5.向量旋转函数将向量ab变为ba。如何将向量abc变为cba？（这对交换非相邻内存块的问题进行了建模）。</p>
<p class="content">6.20世纪70年代末期，贝尔实验室开发出了“用户操作的电话号码簿辅助程序”，该程序允许雇员使用标准的按键电话在公司电话号码簿中查找电话号码。</p>
<div class="bodypic_"><img alt="" src="../Images/image00187.jpeg" class="calibre3"/>
</div>
<p class="content">要查找该系统设计者的名字Mike Lesk<span id="ref14">
<a href="part0007.xhtml#annot14">[12]</a>
</span>
 ，可以按“LESK*M*”（也就是“5375*6*”），随后，系统会输出他的电话号码。这样的服务现在随处可见。该系统中出现的一个问题是，不同的名字有可能具有相同的按键编码。在 Lesk 的系统中发生这种情况时，系统会询问用户更多的信息。给定一个大的名字文件（例如标准的大城市电话号码簿），如何定位这些“错误匹配”呢？（当Lesk在这种规模的电话号码簿上做实验时，他发现错误匹配发生的概率仅仅是0.2%。）如何实现一个以名字的按键编码为参数，并返回所有可能的匹配名字的函数？</p>
<p class="content">7.在20世纪60年代早期，Vic Vyssotsky与一个程序员一起工作，该程序员需要转置一个存储在磁带上的4 000×4 000的矩阵（每条记录的格式相同，为数十个字节）。他的同事最初提出的程序需要运行50个小时。Vyssotsky如何将运行时间减少到半小时呢？</p>
<p class="content">8.[J.Ullman]给定一个n元实数集合、一个实数t和一个整数k，如何快速确定是否存在一个k元子集，其元素之和不超过t？</p>
<p class="content">9.顺序搜索和二分搜索代表了搜索时间和预处理时间之间的折中。处理一个n元表格时，需要执行多少次二分搜索才能弥补对表进行排序所消耗的预处理时间？</p>
<p class="content">10.某一天，一个新研究员向托马斯·爱迪生报到。爱迪生要求他计算出一个空灯泡壳的容积。在使用测径仪和微积分进行数小时的计算后，这个新员工给出了自己的答案——150 cm<span class="super">3</span>
 。而爱迪生在几秒钟之内就计算完毕并给出了结果“更接近155”。他是如何实现的呢？</p>
<h3 class="thirdtitle" id="bw16">
<a href="part0000.xhtml#toc24">2.7 深入阅读</a>
</h3>
<p class="content">8.8节列出了算法方面的几本好书。</p>
<h3 class="thirdtitle" id="bw17">
<a href="part0000.xhtml#toc25">2.8 变位词程序的实现（边栏）</a>
</h3>
<p class="content">
<span id="ref15">
<a href="part0007.xhtml#annot15">[13]</a>
</span>
</p>
<p class="content">我的变位词程序按三个阶段的“管道”组织，其中一个程序的输出文件作为下一个程序的输入文件。第一个程序标识单词，第二个程序排序标识后的文件，而第三个程序将这些单词压缩为每个变位词类一行的形式。下面是一个仅有6个单词的字典的处理过程。</p>
<div class="bodypic_"><img alt="" src="../Images/image00188.jpeg" class="calibre3"/>
</div>
<p class="content">输出包括三个变位词类。</p>
<p class="content">下面的C语言sign程序假定没有超过100个字母的单词，并且输入文件仅包含小写字母和换行符。（因此我使用了一个一行的命令对字典进行预处理，将其中的大写字母改为小写字母。）</p>
<p class="content">int charcomp(char *x,char *y) { return *x - *y;}</p>
<p class="content">#define WORDMAX 100</p>
<p class="content">int main(void)</p>
<p class="content">{ char word[WORDMAX],sig[WORDMAX];</p>
<p class="content_4">while (scanf("%s",word) !=EOF) {</p>
<p class="content_5">strcpy(sig,word);</p>
<p class="content_5">qsort(sig,strlen(sig),sizeof(char),charcomp);</p>
<p class="content_5">printf("%s %s\n",sig,word);</p>
<p class="content_4">}</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">while循环每次读取一个字符串到word中，直至文件末尾为止。strcpy函数复制输入单词到单词sig中，然后调用C标准库函数qsort对单词sig中的字母进行排序（参数是待排序的数组、数组的长度、每个待排序项的字节数以及比较两个项的函数名。在本例中，待比较项为单词中的字母）。最后，printf语句依次打印标识、单词本身和换行符。</p>
<p class="content">系统sort程序将所有具有相同标识的单词归拢到一起。squash程序在同一行中将其打印出来。</p>
<p class="content">int main(void)</p>
<p class="content">{ char word[WORDMAX],sig[WORDMAX],oldsig[WORDMAX];</p>
<p class="content_4">int linenum = 0;</p>
<p class="content_4">strcpy(oldsig,"");</p>
<p class="content_4">while (scanf("%s %s",sig,word) != EOF) {</p>
<p class="content_5">if (strcmp(oldsig,sig) !=0 &amp;&amp; linenum &gt;0)</p>
<p class="content_6">printf("\n");</p>
<p class="content_5">strcpy(oldsig,sig);</p>
<p class="content_5">linenum++;</p>
<p class="content_5">printf("%s ",word);</p>
<p class="content_4">}</p>
<p class="content_4">printf("\n");</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">大部分工作都是使用第二个printf语句来完成的。对每一个输入行，该语句输出第二个字段，后面跟一个空格。if语句捕捉标识之间的差异。如果sig与oldsig（其上一次的值）不同，那么就打印换行符（文件中的第一条记录除外）。最后一个printf输出最后一个换行符。</p>
<p class="content">在使用小输入文件对这些简单部分进行测试后，我通过下面的命令构建了变位词列表：</p>
<p class="content">sign &lt;dictionary | sort | squash &gt;gramlist</p>
<p class="content">该命令将文件dictionary输入到程序sign，连接sign的输出至sort，连接sort的输出至squash，并将squash的输出写入文件gramlist。程序的运行时间为18秒：sign用时4秒、sort用时11秒而squash用时3秒。</p>
<p class="content">我在一个包含230 000个单词的字典上运行了该程序。然而，不包括众多的-s和-ed后缀。以下是一些很有趣的变位词类。</p>
<p class="content">subessential suitableness</p>
<p class="content">canter creant cretan nectar recant tanrec trance</p>
<p class="content">caret carte cater crate creat creta react recta trace</p>
<p class="content">destain instead sainted satined</p>
<p class="content">adroitly dilatory idolatry</p>
<p class="content">least setal slate stale steal stela tales</p>
<p class="content">reins resin rinse risen serin siren</p>
<p class="content">constitutionalism misconstitutional</p>
<h2 class="secondtitle" id="bw18">
<a href="part0000.xhtml#toc26">第3章 数据决定程序结构</a>
</h2>
<p class="content">
<span id="ref16">
<a href="part0007.xhtml#annot16">[14]</a>
</span>
</p>
<p class="content">多数程序员都接触过这样的程序，即使是优秀程序员多数也都至少编写过一个这样的程序：庞大、混乱、丑陋的程序，而它们本应该可以写得短小、清晰、漂亮。我曾经见过几个程序，本质上它们就相当于如下代码：</p>
<p class="content">if (k == 1) c001++</p>
<p class="content">if (k == 2) c002++</p>
<p class="content_4">...</p>
<p class="content">if (k == 500) c500++</p>
<p class="content">虽然这些程序确实也完成了稍微复杂一些的任务，但是基本上可以认为它们的作用只是数了数文件中 1～500 每个整数出现的次数。每个程序的代码都超过了 1 000行。今天的程序员多数都会立即意识到，自己可以编写一个长度仅为其零头的程序来完成该任务，方法就是使用一种不同的数据结构——一个有500个元素的数组来代替500个独立的变量。</p>
<p class="content">因此，本章标题的完整意义是：恰当的数据视图实际上决定了程序的结构。本章描述了多种不同的程序，这些程序都可以通过重新组织内部数据而变得更小（并且更好）。</p>
<h3 class="thirdtitle" id="bw19">
<a href="part0000.xhtml#toc27">3.1 一个调查程序</a>
</h3>
<p class="content">下面要研究的这个程序统计了某个学院的学生所填写的近2万份调查表。其部分输出如下所示：</p>
<div class="pic_"><img alt="" src="../Images/image00189.jpeg" class="calibre3"/>
</div>
<p class="content">因为一些人没有回答全部问题，所以每个族裔组的男女人数之和比总人数略少。实际的输出则更为复杂。上面给出了全部的七行以及总数行，但仅有6列，分别代表总人数和另外两个大类：身份状态和性别。在实际问题中，共有25列分别代表8个大类，以及3页相似的输出：两页分别代表两个独立的学院，而另一页为这两者的总和。此外，还需要打印其他一些密切相关的表，例如拒绝回答每个问题的学生的数目。每份调查表使用一条记录来表示。在每条记录中，项0为族裔组，编码为0～7的整数（分别对应每一个族裔和“拒绝回答”），项1为学院（编码为0～2的整数），项2为身份状态，依此类推，直到项8。</p>
<p class="content">程序员按照该系统分析员提供的高层设计来编写程序。在努力工作了两个月并完成了1000行代码以后，程序员估计自己才完成了一半的工作量。在阅读了原始设计之后，我理解了该程序员的困境：程序使用350个不同的变量来实现——25列乘以7行，再乘以2页。完成变量声明之后，程序采用一系列的嵌套逻辑来判定在读入每条记录时，应该增加哪个变量。请用几分钟的时间思考一下这个问题，看看你会如何实现。</p>
<p class="content">关键的决定是应当使用数组来存储这些数。作下一个决定则更难：该数组应该按照其输出的结构（学院、族裔组和 25 列）来组织，还是应该按照其数据输入的结构（学院、族裔组、大类和大类中的数值）来组织？忽略学院信息，上述方法可以表示如下：</p>
<div class="bodypic_"><img alt="" src="../Images/image00190.jpeg" class="calibre3"/>
</div>
<p class="content">这两种方法都可行。我编写的程序中所使用的三维视图（左）方法在数据读取的时候需要完成的工作量稍多些，而在输出时需要完成的工作量稍少些。程序由150行代码组成：80行构建该表，30行产生前述的输出，40行用来产生其他的表。</p>
<p class="content">上述的计数程序和调查程序都过于庞大。两者都包含大量的用一个数组就可以代替的变量。将代码的长度减少一个数量级不仅可以得到开发周期更短的正确程序，而且更易于测试和维护。虽然在这两个应用中差别不是很大，但是，这两个小程序在运行时间和存储空间上还是会比大程序更高效。</p>
<p class="content">在小程序可以完成任务的情况下，为什么程序员非要编写大程序呢？一个原因是他们缺少在2.5节中提到的重要的惰性。他们急于完成其最初的想法。在前面描述的两个问题中，有更深层次的原因：程序员在考虑该问题时受到了语言的限制。在他们所用的编程语言中，数组通常是固定的表格，并且必须在程序开始的时候初始化，此后不能再改变。在1.7节提到的James Adams的书中，他会说程序员遇到了“概念壁垒”，阻碍了计数器动态数组的使用。</p>
<p class="content">导致程序员犯这类错误的原因还有很多。在准备编写这一章内容时，我在自己的调查程序中发现了一个类似的例子。程序的主输入循环由8个5条语句的块构成，共计40行代码。前两个语句块可以表示如下：</p>
<p class="content">ethnicgroup = entry[0]</p>
<p class="content">campus = entry[1]</p>
<p class="content">if entry[2] == refused</p>
<p class="content_4">declined[ethnicgroup,2]++</p>
<p class="content">else</p>
<p class="content_4">j = 1 + entry[2]</p>
<p class="content_4">count[campus,ethnicgroup,j]++</p>
<p class="content">if entry[3] == refused</p>
<p class="content_4">declined[ethnicgroup,3]++</p>
<p class="content">else</p>
<p class="content_4">j = 4 + entry[3]</p>
<p class="content_4">count[campus,ethnicgroup,j]++</p>
<p class="content">将数组offset初始化为 0,0,1,4,6,…以后，我使用6行代码取代了原来的40行代码。</p>
<p class="content">for i = [2,8]</p>
<p class="content_5">if entry[i] == refused</p>
<p class="content_7">declined[ethnicgroup,i]++</p>
<p class="content">else</p>
<p class="content_5">j = offset[i] + entry[i]</p>
<p class="content_5">count[campus,ethnicgroup,j]++</p>
<p class="content">我对代码长度减少了一个数量级太满意了，结果忽视了另一个就在眼皮底下的问题。</p>
<h3 class="thirdtitle" id="bw20">
<a href="part0000.xhtml#toc28">3.2 格式信函编程</a>
</h3>
<p class="content">在常去的网店键入你的名字和密码并成功登录以后，弹出的下一页网页类似这样：</p>
<p class="content">Welcome back,Jane!</p>
<p class="content">We hope that you and all the members</p>
<p class="content">of the Public family are constantly</p>
<p class="content">reminding your neighbors there</p>
<p class="content">on Maple Street to shop with us.</p>
<p class="content">AS usual,we will ship your order to Ms.Jane Q.public</p>
<p class="content_5">600 Maple Street</p>
<p class="content_5">Your Town,Iowa 12345</p>
<p class="content_4">...</p>
<p class="content">作为程序员，你会意识到隐藏在这一幕之后所发生的事情——计算机在数据库中查找你的用户名并返回如下所示的字段：</p>
<p class="content">Public|Jane|Q|Ms.|600|Maple Street|Your Town|Iowa|12345</p>
<p class="content">但是，程序如何依据你的个人数据库记录来构建这个定制的网页呢？急躁的程序员可能会试图按照下面所示的方式开始编写程序：</p>
<p class="content">read lastname,firstname,init,title,streetnum,streetname,tomn,state,zip</p>
<p class="content">print "Welcome back,",firstname,"!"</p>
<p class="content">print "We hope that you and all the members"</p>
<p class="content">print "of the",lastname,"family are constantly"</p>
<p class="content">print "reminding your neighbous there"</p>
<p class="content">print "on",streetname,"to shop with us."</p>
<p class="content">print "As usual,we will ship your order to"</p>
<p class="content">print " ",title,firstname,init ".",lastname</p>
<p class="content">print " ",streetnum,streetname</p>
<p class="content">print " ",town ",",state,zip</p>
<p class="content">...</p>
<p class="content">这样的程序很有诱惑性，但是也很乏味。</p>
<p class="content">一个更巧妙的方法是编写一个格式信函发生器（form letter generator）。该发生器基于下面所示的格式信函模板（form letter schema）：</p>
<p class="content">Welcome back,$1!</p>
<p class="content">We hope that you and all the members of the $0 family are constantly</p>
<p class="content">reminding your neighbors there</p>
<p class="content">on $5 to shop with us.</p>
<p class="content">As usual,we will ship your order to$3 $1 $2.$0</p>
<p class="content_5">$4 $5</p>
<p class="content_5">$6,$7 $8</p>
<p class="content_4">...</p>
<p class="content">符号$i代表记录中的第i个字段。于是，$0代表姓，等等。模板使用下面的伪代码来解释。在伪代码中，文字符号$在输入模板中记为$$。</p>
<p class="content">read fields from database</p>
<p class="content">loop from start to end of schema</p>
<p class="content_5">c = next character in schema</p>
<p class="content_5">if c ! ='$'</p>
<p class="content_7">printchar c</p>
<p class="content_5">else</p>
<p class="content_7">c = next character in schema</p>
<p class="content_7">case c of</p>
<p class="content_8">'$': printchar '$'</p>
<p class="content_8">'0' - '9': printstring field[c]</p>
<p class="content_8">default: error("bad schema")</p>
<p class="content">在程序中，该模板使用一个长字符串数组表示。数组中的文本行以换行符结束。（Perl和其他脚本语言使其更容易实现。可以使用形如$lastname的变量。）</p>
<p class="content">编写该发生器和模板程序比编写显而易见的程序要简单些。将数据从控制中分离会获得许多好处：如果重新设计信函，那么模板可以使用文本编辑器来修改，从而第二个特定页的准备会很简单。</p>
<p class="content">报表模板的概念曾极大地简化了我维护过的一个5 300行代码的Cobol程序。程序的输入是家庭财务状况的描述，其输出是一个小册子，总结了财务现状并推荐未来理财策略。这里是一些相关数值：120个输入字段、18页上的400行输出语句、300行用来清除输入数据的代码、800行用于计算的代码以及4 200行用于输出的代码。据我估算：4 200 行的输出代码可以使用一个最多几十行代码的解释程序和一个 400行的模板来代替，而代码的计算部分保持不变。按这种形式编写原始程序所得到的Cobol代码的长度至多为原来的三分之一，并且维护起来也容易得多。</p>
<h3 class="thirdtitle" id="bw21">
<a href="part0000.xhtml#toc29">3.3 一组示例</a>
</h3>
<p class="content">菜单。我希望我的Visual Basic程序的用户可以通过点击菜单项来实现在几个选项之间的选择。我浏览了一系列的优秀示例程序，发现了一个允许用户在选项中进行八选一操作的程序。查看该菜单对应的代码，得到如下所示的选项0的代码：</p>
<p class="content">sub menuitem0_click()</p>
<p class="content_5">menuitem0.checked = 1</p>
<p class="content_5">menuitem1.checked = 0</p>
<p class="content_5">menuitem2.checked = 0</p>
<p class="content_5">menuitem3.checked = 0</p>
<p class="content_5">menuitem4.checked = 0</p>
<p class="content_5">menuitem5.checked = 0</p>
<p class="content_5">menuitem6.checked = 0</p>
<p class="content_5">menuitem7.checked = 0</p>
<p class="content">选项1的代码几乎是一样的，相异的部分如下：</p>
<p class="content">sub menuitem1_click()</p>
<p class="content_5">menuitem0.checked = 0</p>
<p class="content_5">menuitem1.checked = 1</p>
<p class="content_5">...</p>
<p class="content">依此类推，选项2至选项7亦是如此。总而言之，菜单项的选择总计需要大约100行代码。</p>
<p class="content">我自己编写的程序也与之相似。我从有两个选项的菜单着手编程，此时的代码是合理的。当我添加第三个、第四个和后续的选项时，我为代码所具有的功能而倍感兴奋，以至于没能停下来去整理混乱的代码。</p>
<p class="content">稍作观察以后，可以将大部分代码转化为一个函数 uncheckall，该函数将每个checked字段置0。于是第一个函数变成：</p>
<p class="content">sub menuitem0_click()</p>
<p class="content_5">uncheckall</p>
<p class="content_5">menuitem0.checked = 1</p>
<p class="content">但是，此时的代码中还是有7个相似的函数。</p>
<p class="content">幸运的是，Visual Basic支持菜单选项数组。因此可以将8个相似的函数使用一个函数表示：</p>
<p class="content">sub menuitem_click(int choice)</p>
<p class="content_5">for i = [0,numchoices)</p>
<p class="content_7">menuitem[i].checked = 0</p>
<p class="content_5">menuitem[choice].checked = 1</p>
<p class="content">将重复的代码使用通用的函数表示，使程序由100行减少至25行，而数组的恰当使用又使代码减至4行。添加下一个选择也更容易，并且可能存在错误的程序现在犹如水晶一般晶莹剔透。该方法仅仅使用了几行代码就解决了我的问题。</p>
<p class="content">出错信息。混乱系统的数百个出错信息散布在所有代码中。同时，这些出错信息又与其他输出语句混杂在一起。而清晰系统则通过一个专用函数来访问这些出错信息。考虑一下分别使用“混乱”和“清晰”两种组织形式来实现下面这种需求的难度：产生所有可能的出错信息列表，使每个“严重”出错信息产生一声报警并将出错信息翻译成法语或德语。</p>
<p class="content">日期函数。给定年份和该年中的某一天，返回该天所处的月份和月中的日子。例如，2004年的第61天是3月1日。在其Elements of Programming Style中，Kernighan和Plauger给出了一个直接从他人的程序中摘录出来的实现该任务的55行程序。随后，他们用一个5行的程序解决了该问题，该程序用到了一个有26个整数的数组。习题4介绍了关于日期函数表示的问题。</p>
<p class="content">单词分析。许多计算问题都是由英文单词的分析引起的。在13.8节将会看到拼写检查器如何使用“后缀去除”来精简字典：例如单词“laugh”就不存储其所有的不同结尾（“-ing”、“-s”、“-ed”等）。语言学家们已经得出了对应这些任务的一系列法则。1973年，Doug McIlroy在编写他的第一个实时文本语音合成器的时候，就知道代码并不适合表示这些法则。他更愿意使用1000行代码和一个400行的表来实现。有人尝试在不增加表的情况下修改程序，其结果是增加20％的内容就需要增加2 500行额外的代码。McIlroy声称他现在可以通过增加更多的表，使用少于1 000行的代码来完成该扩充任务。需要自己尝试一下类似的法则集的话，见习题5。</p>
<h3 class="thirdtitle" id="bw22">
<a href="part0000.xhtml#toc30">3.4 结构化数据</a>
</h3>
<p class="content">什么才是结构清晰的数据？随着时间的推移，其标准也在逐步提高。早些年，结构化数据就意味着选择恰当的变量名。后来，在程序员使用平行数组（parallel array）<span id="ref17">
<a href="part0007.xhtml#annot17">[15]</a>
</span>
 或寄存器偏移量的地方，编程语言加入了记录或结构以及指向它们的指针。我们学会了使用名为insert或search的函数来代替处理数据的代码，这有助于在改变数据的表达方式时不损坏程序的其他部分。David Parnas<span id="ref18">
<a href="part0007.xhtml#annot18">[16]</a>
</span>
 对这种方法进行了扩展，他发现对系统待处理数据进行研究可以深入认识到优秀的模块化结构。</p>
<p class="content">下一步是“面向对象编程”。程序员们学会识别设计中的基本对象，向外公开一个抽象的对象及其基本操作，并隐藏具体的实现细节。使用诸如 Smalltalk 和 C++的编程语言，可以将这些对象封装在类中。在第 13 章中，我们在研究集合的抽象和实现时会仔细研究这种方法。</p>
<h3 class="thirdtitle" id="bw23">
<a href="part0000.xhtml#toc31">3.5 用于特殊数据的强大工具</a>
</h3>
<p class="content">曾几何时，程序员需要从头开始编写每个应用程序。现代工具允许程序员（以及其他人员）花费最少的精力来编写应用程序。本节所列出的一些工具仅为示范性的，并不完备。每种工具都使用数据的某一视图来解决特定但又通用的问题。诸如Visual Basic、Tcl等语言和各种shell都提供了连接这些对象的“胶水”。</p>
<p class="content">超文本。在20世纪90年代早期，网站的数量还只有数千个的时候，我所阅读的入门参考书都是存储在 CD-ROM 上面的。那些资料令人眼花缭乱，包括百科全书、字典、年鉴、电话号码簿、古典文学、教科书、系统参考手册等，所有这些资料都可以放在我的手掌心里。不幸的是，不同资料集的用户界面也是一样地令人头晕目眩：每个程序都有其特别之处。现在我可以轻松地访问所有CD上的或网上的数据（甚至更多），而我所用的界面通常就是网页浏览器。这使用户和开发人员都轻松多了。</p>
<p class="content">名字—值对。书目数据库中的项可能如下所示：</p>
<p class="content">%title　　　　The C++ Programming Language,Third Edition</p>
<p class="content">%author　　　 Bjarne Stroustrup</p>
<p class="content">%city　　　　 Reading,Massachusetts</p>
<p class="content">%yesr　　　　 1997</p>
<p class="content">%publisher Addison-Wesley</p>
<p class="content">Visual Basic使用这种方法描述界面的控件。窗体左上角的文本框可以使用如下的属性（名字）和设置（值）来描述：</p>
<div class="pic_"><img alt="" src="../Images/image00191.jpeg" class="calibre3"/>
</div>
<p class="content">（完整的文本框包含 36 个名字—值对。）例如要展宽文本框时，可以使用鼠标拖动右边框，或者输入一个更大的整数来替代215，或者使用运行时赋值语句</p>
<p class="content">txtSample.Width = 400</p>
<p class="content">程序员可以选择最方便的方式来操作这个简单但功能很强大的结构。</p>
<p class="content">电子表格。搞明白本部门的预算对我来说似乎有点困难。习惯上，我会为这项工作编写一个庞大的程序，用户界面也是沉闷生硬的。而另一位程序员从一个更广的视角入手，采用电子表格实现该程序，同时也使用了少量的Visual Basic函数。用户界面对财务人员等主要用户来说很熟悉。（如果今天我还需要编写大学调查程序，数据为数值数组的这个事实会促使我尝试将数据放到电子表格中。）</p>
<p class="content">数据库。多年以前，一位程序员在纸质日志上记录了他最初的十几次跳伞的详细信息以后，决定将自己跳伞数据的记录自动化。再早几年，记录这样的数据需要使用复杂的记录格式，并且需要使用手工程序（或使用“报表程序发生器”）来完成数据的录入、更新和提取。当时，该程序员和我都被他完成该工作时所使用的新发明的商业数据库震惊了。他可以在几分钟之内完成数据库操作的新界面，而不再需要几天的时间。</p>
<p class="content">特定领域的编程语言。图形用户界面（GUI）已经替代了许多古老沉闷的文本语言。但是特殊用途的编程语言在某些应用程序中依然很有效。当需要计算数据时，我并不喜欢使用鼠标在屏幕上点击一个虚拟的计算器，而是倾向于采用如下所示的方式直接输入数学公式：</p>
<p class="content">n = 1000000</p>
<p class="content">47 * n * log(n)/log(2)</p>
<p class="content">相比于用炫丽的文本框和操作按钮组合来定义一个查询，我更倾向于用下面这样的语言来写：</p>
<p class="content">(design or architecture) and not building</p>
<p class="content">以前使用数百行可执行代码来定义的窗口，现在可以使用数十行HTML代码来定义。这些语言对一般的用户输入来说可能不够时尚了，但是在某些应用场合它们依然是有效的工具。</p>
<h3 class="thirdtitle" id="bw24">
<a href="part0000.xhtml#toc32">3.6 原理</a>
</h3>
<p class="content">虽然本章中的故事横跨数十年并涉及多种编程语言，但是每个故事的精髓都是一致的：“能用小程序实现的，就不要编写大程序”。许多结构都见证了Polya在How to Solve It <span id="ref19">
<a href="part0007.xhtml#annot19">[17]</a>
</span>
 一书中提到的发明家悖论：“更一般性的问题也许更容易解决”。对于程序设计来说，这意味着直接编写解决23种情况的问题很困难；而编写一个处理n种情况的通用程序，再令n=23来得到最终结果，却相对要容易一些。</p>
<p class="content">本章集中讨论了数据结构对软件的一个贡献：将大程序缩减为小程序。数据结构设计还有许多其他正面影响，包括节省时间和空间、提高可移植性和可维护性。Fred Brooks<span id="ref20">
<a href="part0007.xhtml#annot20">[18]</a>
</span>
 在《人月神话》第 9 章中的评论就是针对节省空间的。而对于想要获得其他属性的程序员来说，下面的建议可谓金玉良言：</p>
<p class="content">程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效。（数据的）表示形式是程序设计的根本。</p>
<p class="content">下面是退回起点进行思考时的几条原则。</p>
<p class="content">使用数组重新编写重复代码。冗长的相似代码常常可以使用最简单的数据结构——数组来更好地表述。</p>
<p class="content">封装复杂结构。当需要非常复杂的数据结构时，使用抽象术语进行定义，并将操作表示为类。</p>
<p class="content">尽可能使用高级工具。超文本、名字—值对、电子表格、数据库、编程语言等都是特定问题领域中的强大的工具。</p>
<p class="content">从数据得出程序的结构。本章的主题就是：通过使用恰当的数据结构来替代复杂的代码，从数据可以得出程序的结构。万变不离其宗：在动手编写代码之前，优秀的程序员会彻底理解输入、输出和中间数据结构，并围绕这些结构创建程序。</p>
<h3 class="thirdtitle" id="bw25">
<a href="part0000.xhtml#toc33">3.7 习题</a>
</h3>
<p class="content">1.本书行将出版之时，美国的个人收入所得税分为 5 种不同的税率，其中最大的税率大约为 40%。以前的情况则更为复杂，税率也更高。下面所示的程序文本采用25个if语句的合理方法来计算1978年的美国联邦所得税。税率序列为0.14，0.15， 0.16，0.17，0.18，…。序列中此后的增幅大于0.01。有何建议呢？</p>
<p class="content">if income &lt;= 2200</p>
<p class="content_5">tax = 0</p>
<p class="content">else if income &lt; 2700</p>
<p class="content_5">tax =.14 * (income - 2200)</p>
<p class="content">else if income &lt;= 3200</p>
<p class="content_5">tax = 70 +.15 * (income - 2700)</p>
<p class="content">else if income &lt;= 3700</p>
<p class="content_5">tax = 145 +.16 * (income - 3200)</p>
<p class="content">else if income &lt;= 4200</p>
<p class="content_5">tax = 225 +.17 * (income - 3700)</p>
<p class="content">...</p>
<p class="content">else</p>
<p class="content_5">tax = 53090 +.70 * (income - 102200)</p>
<p class="content">2.k阶常系数线性递归定义的级数如下：</p>
<p class="content_">a<span class="sub">n</span>
 =c <span class="sub">1</span>
 a<span class="sub">n−</span>
 1+c<span class="sub">2</span>
 a<span class="sub">n−2</span>
 +…+c<span class="sub">k</span>
 a<span class="sub">n−k</span>
 +c<span class="sub">k+</span>
 1，</p>
<p class="content">其中，c<span class="sub">1</span>
 ,…,c<span class="sub">k 1</span>
 + 为实数。编写一个程序，其输入为k,a<span class="sub">1</span>
 ,…,a<span class="sub">k</span>
 ,c<span class="sub">1</span>
 ,…,c<span class="sub">k+1</span>
 和m，输出为a<span class="sub">1</span>
 至a<span class="sub">m</span>
 。</p>
<p class="content">该程序与计算一个具体的 15 阶递归的程序相比会复杂多少？不使用数组又如何实现呢？</p>
<p class="content">3.编写一个“banner”函数，该函数的输入为大写字母，输出为一个字符数组，该数组以图形化的方式表示该字母。</p>
<p class="content">4.编写处理如下日期问题的函数：给定两个日期，计算两者之间的天数；给定一个日期，返回值为周几；给定月和年，使用字符数组生成该月的日历。</p>
<p class="content">5.本习题处理英语中的一小部分连字符问题。下面所示的规则描述了以字母“c”结尾的单词的一些合法的连字符现象：</p>
<p class="content">et-ic al-is-tic s-tic p-tic -lyt-ic ot-ic an-tic n-tic c-tic at-ic h-nic n-ic m-ic l-lic b-lic -clic l-ic h-ic f-ic d-ic -bic a-ic -mac i-ac</p>
<p class="content">规则的应用必须按照上述顺序进行；因此，有连字符“eth-nic”（由规则“h-nic”捕获）和“clin-ic”（前一测试失败，然后满足“n-ic”）。如何用函数来表达该规则？要求函数的输入为单词，返回值必须是后缀连字符。</p>
<p class="content">6.编写一个“格式信函发生器”，使之可以通过数据库中的每条记录来生成定制的文档（这常常称为“邮件归并”特性）。设计简短的模板和输入文件来测试程序的正确性。</p>
<p class="content">7.常见的字典允许用户查找单词的定义。习题2.1描述了允许用户查找变位词的字典。设计查找单词正确拼写的字典和查找单词的押韵词的字典。讨论具有以下功能的字典：查找整数序列（例如，1，1，2，3，5，8，13，21，…）、化学结构或者歌曲韵律结构。</p>
<p class="content">8.[S.C.Johnson]七段显示设备实现了十进制数字：</p>
<div class="bodypic_"><img alt="" src="../Images/image00192.jpeg" class="calibre3"/>
</div>
<p class="content">的廉价显示。七段显示通常如下编号：</p>
<div class="bodypic_"><img alt="" src="../Images/image00193.jpeg" class="calibre3"/>
</div>
<p class="content">编写一个使用5个七段显示数字来显示16位正整数的程序。输出为一个5个字节的数组，当且仅当数字j中的第i段点亮时，字节j中的位i置1。</p>
<h3 class="thirdtitle" id="bw26">
<a href="part0000.xhtml#toc34">3.8 深入阅读</a>
</h3>
<p class="content">数据可以结构化程序，但是只有聪明的程序员才能结构化大型软件系统。Steve McConnell<span id="ref21">
<a href="part0007.xhtml#annot21">[19]</a>
</span>
 的《代码大全》由微软出版社于1993年出版，其副标题A Practical Handbook of Software Construction精确地描述了这部860页著作的内容。该书是程序员智慧结晶的捷径。</p>
<p class="content">该书的第8章至第12章都与本章密切相关，都讨论有关“数据”的话题。McConnell从诸如数据声明和选择数据名称等基本内容开始，进而讨论高级的主题，例如表驱动程序和抽象数据类型。其第4章至第7章详细描述的关于“设计”的主题与本章一致。</p>
<p class="content">从开发有趣的小函数到管理大的软件项目，开发软件项目所需要的知识面很广。尤其在与他的 Rapid Development<span id="ref22">
<a href="part0007.xhtml#annot22">[20]</a>
</span>
 （微软出版社 1996 年出版）和 Software Project Survival Guide<span id="ref23">
<a href="part0007.xhtml#annot23">[21]</a>
</span>
 （微软出版社1998年出版）结合起来的时候，McConnell的工作覆盖了这两个极端以及大部分的中间地带。McConnell 的书读起来很风趣，但永远不要忘记，他所说的都是来之不易的亲身体会。</p>
<h2 class="secondtitle" id="bw27">
<a href="part0000.xhtml#toc35">第4章 编写正确的程序</a>
</h2>
<p class="content">20世纪60年代末，人们就在讨论验证其他程序正确性的那些验证程序的前景了。不幸的是，到今天这几十年间，除了屈指可数的几个例外，自动验证系统依然还是纸上谈兵。尽管以前的预期落空了，对程序验证所进行的研究还是给我们提供了很有价值的东西——对计算机编程的基本理解，这比一个吞入程序，然后闪现“好”或“坏”的黑匣子要好得多。</p>
<p class="content">本章的目的是阐述这些基本理解如何帮助实际程序员编写正确的程序。一位读者将大多数程序员习以为常的方法形象地归纳为“编写代码，然后丢给另一个部门，由QA（质量保证）或 QT（质量测试）来处理错误”。本章描述一种不同的方法。在开始讨论之前，我们必须正确地认识到：编程技巧仅仅是编写正确程序的很小一部分，大部分内容还是前面三章讨论过的主题：问题定义、算法设计以及数据结构选择。如果这些步骤都完成得很好，那么编写正确的程序通常是很容易的。</p>
<h3 class="thirdtitle" id="bw28">
<a href="part0000.xhtml#toc36">4.1 二分搜索的挑战</a>
</h3>
<p class="content">即使有了最好的程序设计，程序员也常常要编写巧妙的代码。本章讨论一个需要特别仔细地编写代码的问题：二分搜索。在回顾这个问题并简介其算法之后，我们将使用验证原则来编写程序。</p>
<p class="content">我们首次遇到这个问题是在2.2节。我们需要确定排序后的数组x[0..n−1]中是否包含目标元素 t。<span id="ref24">
<a href="part0007.xhtml#annot24">[22]</a>
</span>
 准确地说，已知n≥0且x[0]≤x[1]≤x[2]≤⋅⋅⋅≤x[n−1]，当 n=0时数组为空。t 与 x 中元素的数据类型相同。无论是整型、浮点型还是字符串型，伪代码都必须同样地正确运行。答案存储在整数p中（记录位置）：当p为-1时，目标t不在数组x[0..n−1]中；否则0≤p≤n−1，且t=x[p]。</p>
<p class="content">二分搜索通过持续跟踪数组中包含元素t的范围（如果t存在于数组的话）来解决问题。一开始，这个范围是整个数组；然后通过将t与数组的中间项进行比较并抛弃一半的范围来缩小范围。该过程持续进行，直到在数组中找到t或确定包含t的范围为空时为止。在有n个元素的表中，二分搜索大约需要执行log<span class="sub">2</span>
 n次比较操作。</p>
<p class="content">多数程序员都认为有了上述描述在手，编写代码是轻而易举的事。但是他们错了。相信这一点的唯一办法就是马上放下书，然后自己编写这段程序。试试看。</p>
<p class="content">我在给专业程序员上课时布置过该问题。学生们有数小时的时间将上面的描述转换成程序。可以使用任何一种编程语言，高级伪代码也可以。规定的时间到了的时候，几乎所有的程序员都报告说自己完成了该任务的正确代码。然后，我们用 30 分钟时间来检查这些程序员已经用测试实例检验过了的代码。在几个课堂里对一百多名程序员的检查结果大同小异：90%的程序员都在他们的程序中发现了错误（并且我不相信那些没有发现错误的程序就一定是正确的）。</p>
<p class="content">我很惊诧：提供充足的时间，竟然仅有约10%的专业程序员能够将这个小程序编写正确。但是他们不是唯一一批发现这个任务困难的人：Knuth 在其 The Art of Computer Programming,Volume 3: Sorting and Searching的6.2.1节的历史部分中指出，虽然第一篇二分搜索论文在 1946 年就发表了，但是第一个没有错误的二分搜索程序却直到1962年才出现。</p>
<h3 class="thirdtitle" id="bw29">
<a href="part0000.xhtml#toc37">4.2 编写程序</a>
</h3>
<p class="content">二分搜索的关键思想是如果t在x[0..n−1]中，那么它就一定存在于x的某个特定范围之内。这里使用mustbe(range)来表示：如果t在数组中，那么它一定在range中。使用这个定义可以将上面描述的二分搜索转换成下面的程序框架：</p>
<p class="content">initialize range to 0..n-1</p>
<p class="content">loop</p>
<p class="content_5">{ invariant: mustbe(range) }</p>
<p class="content_5">if range is empty,</p>
<p class="content_5">break and report that t is not in the array compute m,the middle of the range</p>
<p class="content_5">use m as a probe to shrink the range</p>
<p class="content_7">if t is found during the shrinking process,</p>
<p class="content_7">break and report its position</p>
<p class="content">该程序的最重要部分是大括号内的循环不变式（loop invariant）。之所以把这种关于程序状态的断言（assertion）称为不变式（invariant），是因为在每次循环迭代之前和之后，该断言都为真。这个名称将前面已有的直观概念形式化了。</p>
<p class="content">现在进一步完善程序，并确保所有的操作都遵循该不变式。我们面对的第一个问题就是范围（range）的表示方式：这里使用两个下标l和u（对应下限lower和上限upper）来表示范围l..u。（9.3节的二分搜索函数使用起始位置和长度来表示范围）。逻辑函数mustbe(l,u)是说：如果t在数组中，t就一定在（闭区间）范围x[l..u]之内。</p>
<p class="content">下一步的工作是初始化。l和u应该为何值，才能使mustbe(l,u)为真？显而易见的选择是0和n-1：mustbe(0,n-1)是说如果t在x中，那么t就一定在x[0..n-1]中；而这恰好就是我们在程序一开始就知道的事实。于是，初始化由赋值语句 l=0 和u=n-1组成。</p>
<p class="content">下一步的任务是检查空范围并计算新的中间点m。当l&gt;u时范围l..u为空，在这种情况下，将特殊值-1赋给p并终止循环，程序如下：</p>
<p class="content">if l &gt; u</p>
<p class="content_5">p = -1; break</p>
<p class="content">break语句终止了外层的loop。下面的语句计算范围的中间点m：</p>
<p class="content">m = (l + u) / 2</p>
<p class="content">“/”运算符实现整数除法：6/2等于3，7/2也等于3。至此，扩展的程序如下：</p>
<p class="content">l = 0; u = n-1</p>
<p class="content">loop</p>
<p class="content_5">{ invariant; mustbe(l,u) }</p>
<p class="content_5">if l &gt; u</p>
<p class="content_7">p=-1; break</p>
<p class="content_5">m = (l + u) / 2</p>
<p class="content_5">use m as a probe to shrink the range l..u</p>
<p class="content_7">if t is found during the shrinking process,break and note its position</p>
<p class="content">为了完善循环体中的后三行，需要比较t和x[m]，并采取合适的操作来保持不变式成立。因此代码的一般形式为：</p>
<p class="content">case</p>
<p class="content_5">x[m] &lt; t: action a</p>
<p class="content_5">x[m] == t: action b</p>
<p class="content_5">x[m] &gt; t: action c</p>
<p class="content">对于操作b，由于t在位置m，所以将p设为m并终止循环。由于另外两种情况是对称的，这里集中讨论第一种情况并认为对最后一种情况的讨论可以根据对称性得到（这也是在下一节中我们必须精确验证代码正确性的一部分原因）。</p>
<p class="content">如果x[m]&lt;t,那么x[0]≤x[1]≤…≤x[m]&lt;t。因此，t不可能存在于x[0..m]中的任何位置。将该结论与已知条件“t不在x[l..u]之外”相结合，可知t一定在x[m+1..u]之内，记为mustbe(m+1,u)。然后，通过将l设为m+1可以再次确立不变式mustbe(l,u)。将这些情况放入前面的代码框架中，就获得了最终的函数。</p>
<p class="content">l = 0; u = n-1</p>
<p class="content">loop</p>
<p class="content_5">{ mustbe(l,u) }</p>
<p class="content_5">if l &gt; u</p>
<p class="content_7">p = -1; break</p>
<p class="content_5">m = (l + u) / 2</p>
<p class="content_5">case</p>
<p class="content_7">x[m] &lt; t: l = m+1</p>
<p class="content_7">x[m] == t: P = m; break</p>
<p class="content_7">x[m] &gt; t: u = m-1</p>
<p class="content">这是一个简短的程序：只有9行代码和一个不变式断言。程序验证的基本技术（精确定义不变式并在编写每一行代码时随时保持不变式的成立）在我们将算法框架转化成伪代码时起到了很大的作用。该过程使我们对程序的正确性树立了一些信心。但是这并不意味着该程序就一定是正确的。在继续往下阅读之前，请花几分钟时间确定该代码的功能是否与所描述的一致。</p>
<h3 class="thirdtitle" id="bw30">
<a href="part0000.xhtml#toc38">4.3 理解程序</a>
</h3>
<p class="content">当面对复杂的编程问题的时候，我总是试图得到如同上面那样详细的程序代码，然后使用验证方法来增强自己对程序正确性的信心。本书中的第9章、第11章和第14章也将在这个层面上使用验证技术。</p>
<p class="content">本节我们将在近乎吹毛求疵的细节层面上研究对二分搜索程序所进行的验证分析，实践中我很少做这么多正式的分析。下一页的程序大量使用断言进行注释，从而形式化了最初编写代码时所用的直观概念。</p>
<p class="content">代码的开发是自上而下进行的（从一般思想开始，将其完善为独立的代码行），该正确性分析则是自下而上进行的：从每个独立的代码行开始，检查它们是如何协同运作并解决问题的。</p>
<div class="bodypic_"><img alt="" src="../Images/image00194.jpeg" class="calibre3"/>
</div>
<p class="content">我们从第1行至第3行开始讨论。mustbe的定义如下：如果t在数组中，那么它一定在x[0..n-1]中。由此可知，第1行的断言mustbe(0,n-1)为真。于是，根据第2行的赋值语句l=0和u=n-1可以得到第3行的断言：mustbe(l,u)。</p>
<p class="content">下面讨论困难的部分：第4行至第27行的循环。关于其正确性的讨论分为3个部分，每部分都与循环不变式密切相关。</p>
<p class="content">初始化。循环初次执行的时候不变式为真。</p>
<p class="content">保持。如果在某次迭代开始的时候以及循环体执行的时候，不变式都为真，那么，循环体执行完毕的时候不变式依然为真。</p>
<p class="content">终止。循环能够终止，并且可以得到期望的结果（在本例中，期望的结果是p得到正确的值）。为说明这一点需要用到不变式所确立的事实。</p>
<p class="content">对于初始化，我们注意到第3行的断言与第5行的相同。为确立其他两条性质，对第5行至第27行进行分析。讨论第9行和第21行（break语句）时，将确立终止性质。如果持续下去，直至第27行，就可以得到保持性质，因为这又与第5行相同。</p>
<p class="content">1.{ mustbe(0,n-1) }</p>
<p class="content">2.l = 0; u= n-1</p>
<p class="content">3.{ mustbe(l,u) }</p>
<p class="content">4.loop</p>
<p class="content">5.　　　 { mustbe(l,u) }</p>
<p class="content">6.　　　if l &gt; u</p>
<p class="content">7.　　　　　 { l &gt; u &amp;&amp; mustbe(l,u) }</p>
<p class="content">8.　　　　　　　{ t is not in the array }</p>
<p class="content">9.　　　　　　　p = -1; break</p>
<p class="content">10.　　 { mustbe(l,u) &amp;&amp; l &lt;= u }</p>
<p class="content">11.　　　m = (l + u) / 2</p>
<p class="content">12.　　 { mustbe(l,u) &amp;&amp; l &lt;= m &lt;= u }</p>
<p class="content">13.　　　case</p>
<p class="content">14.　　　　　x[m] &lt; t:</p>
<p class="content">15.　　　　　　　　　　　{ mustbe(l,u) &amp;&amp; cantbe(0,m) }</p>
<p class="content">16.　　　　　　　　　　　{ mustbe(m+l,u) }</p>
<p class="content">17.　　　　　　　　　　　l = m+1</p>
<p class="content">18.　　　　　　　　　　　{ mustbe(l,u) }</p>
<p class="content">19.　　　　　　x[m] == t:</p>
<p class="content">20.　　　　　　　　　　　{ x[m] == t }</p>
<p class="content">21.　　　　　　　　　　　p = m; break</p>
<p class="content">22.　　　　　x[m] &gt; t:</p>
<p class="content">23.　　　　　　　　　　　{ mustbe(l,u) &amp;&amp; cantbe(m,n-1) }</p>
<p class="content">24.　　　　　　　　　　　{ mustbe(l,m-1) }</p>
<p class="content">25.　　　　　　　　　　　u = m-1</p>
<p class="content">26.　　　　　　　　　　　{ mustbe(l,u) }</p>
<p class="content">27.　　　 { mustbe(l,u) }</p>
<p class="content">第6行的成功测试将得到第7行的断言：如果t在数组中，那么它就必定在位置l和u之间，且l &gt; u。这些事实就意味着第8行的断言成立：t不在数组中。于是在第9行设定p为-1后，就可以正确地终止循环。</p>
<p class="content">如果第6行的测试失败，就进入到第10行。不变式依然为真（我们没有对其做任何改动），并且由于测试失败，可得l≤u。第11行将m设为l和u的平均值，向下取整为最接近的整数。由于平均值总是位于两个值之间并且取整不会使之小于 l，所以得到第12行的断言。</p>
<p class="content">从第13行至第27行的case语句考虑到了所有3种可能。最容易分析的一个分支是位于第19行的第二个分支。由第20行的断言，我们将p设定为m并终止循环是正确的。这是第二处终止循环的地方（一共两处），由于两次对循环的终止都是正确的，于是我们确立了循环终止的正确性。</p>
<p class="content">下面讨论case语句中的两个对称分支。由于在编写代码的时候，我们把精力集中在第一个分支上，现在我们将注意力转移到第22行～第26行。考虑第23行的断言。第一个子句是不变式，循环并没有对其进行改变。由于t &lt; x[m]≤x[m+1]≤…≤x[n-1]，第二个子句亦为真，于是我们可以知道t不在数组中任何高于m-1的位置，使用简短记法表示为cantbe(m,n-1)。逻辑告诉我们，如果t一定在l和u之间，而且不等于或高于m，那么t就一定在l和m-1之间（前提是t在x中），于是得到第24行。第24行为真时执行第25行可得第26行为真——这是赋值的定义。case语句的这个分支也就再次确立了第27行的不变式。</p>
<p class="content">第14行至第18行的讨论具有完全相同的形式，至此，我们完成了对case语句所有三个分支的分析。一个正确地终止了循环，其他两个则保持了不变式。</p>
<p class="content">该代码分析表明，如果循环能够终止，那么就可以得到正确的p值。但是，程序中仍有可能包含死循环；事实上，这正是那些专业程序员编写该程序时所犯的最常见的错误。</p>
<p class="content">我们的停机证明从另一个角度对范围l..u进行了考虑。初始范围为某一有限大小（n），第6行至第9行确保当范围中的元素少于一个时终止循环。因此，要证明终止，我们必须证明在循环的每次迭代后范围都缩小了。第 12 行告诉我们，m 总处于当前范围内。case语句中不终止循环的两个分支（第14行和第22行）都排除了范围中位置m处的值，由此将范围大小至少缩小1。因此，程序必会终止。</p>
<p class="content">有了这些背景分析，我对我们进一步讨论这个函数更有信心了。下一章涵盖了以下主题：用C来实现该函数，然后进行测试以确保程序正确而且高效。</p>
<h3 class="thirdtitle" id="bw31">
<a href="part0000.xhtml#toc39">4.4 原理</a>
</h3>
<p class="content">本章的练习展示了程序验证的诸多优势：问题很重要，需要认真地编写代码；程序的开发需要遵循验证思想；可以使用一般性的工具进行程序的正确性分析。该练习的主要缺点在于其细节层面：在实践中不需要这么正式。幸运的是，这些细节阐述了许多一般性的原理，包括以下原理。</p>
<p class="content">断言。输入、程序变量和输出之间的关系勾勒出了程序的“状态”，断言使得程序员可以准确阐述这些关系。这些断言在程序生命周期中的角色在下一节中论述。</p>
<p class="content">顺序控制结构。控制程序的最简单的结构莫过于采用“执行这条语句然后执行下一条语句”的形式。可以通过在语句之间添加断言并分别分析程序执行的每一步来理解这样的结构。</p>
<p class="content">选择控制结构。这些结构包括不同形式的if和case语句；在程序运行过程中，多个分支中的一个被选择执行。我们通过分别分析每一个分支说明了该结构的正确性。一定会选择某个分支的事实允许我们使用断言来证明。例如，如果执行了语句if i &gt;j，那么我们就可以断言i &gt;j并且使用这个事实来推导出下一个相关的断言。</p>
<p class="content">迭代控制结构。要证明循环的正确性就必须为其确立3个性质：</p>
<div class="bodypic_"><img alt="保持初始化不变式终止" src="../Images/image00195.jpeg" class="calibre3"/>
</div>
<p class="content">我们首先讨论由初始化确立的循环不变式，然后证明每次迭代都保持该不变式为真。由数学归纳法可知这两步就证明了在循环的每次迭代之前和之后该不变式都为真。第三步是证明无论循环在何时终止执行，所得到的结果都是正确的。综合这些步骤可知：只要循环能停止运行，那么其结果就是正确的。因此我们还必须用其他方法证明循环一定能终止（二分搜索的停机证明所使用的方法是比较常见的）。</p>
<p class="content">函数。要验证一个函数，首先需要使用两个断言来陈述其目的。前置条件（precon-dition）是在调用该函数之前就应该成立的状态，后置条件（postcondition）的正确性由函数在终止执行时保证。如此可以得到C语言二分搜索函数如下：</p>
<p class="content">int bsearch(int t,int x[],int n)</p>
<p class="content_4">/* precondition: x[0] &lt;= x[1] &lt;=...&lt;= x[n-1]</p>
<p class="content_6">postcondition:</p>
<p class="content_9">result == -1 =&gt; t not present in x</p>
<p class="content_9">0 &lt;= result &lt; n =&gt; x[result] == t</p>
<p class="content_4">*/</p>
<p class="content">这些条件与其说是事实陈述不如说是一个契约：如果在前置条件满足的情况下调用函数，那么函数的执行将确立后置条件。一旦证明函数体具有该性质，在以后的应用中就可以直接使用前置条件和后置条件之间的关系而不再需要考虑其实现。该方法在软件开发中通常称为“契约编程”。</p>
<h3 class="thirdtitle" id="bw32">
<a href="part0000.xhtml#toc40">4.5 程序验证的角色</a>
</h3>
<p class="content">当一个程序员想要让别人相信某段代码正确的时候，首选的工具通常就是使用测试用例：运行程序并手动输入数据。这是很有效的：适用于检测程序的错误、易于使用并且很容易理解。然而，程序员明显对程序有更深的理解——如果他们做不到这一点的话，就不可能编写出第一手程序。程序验证的一个主要好处就是为程序员提供一种语言，用来表达他们对程序的理解。</p>
<p class="content">本书的后续部分（特别是第9章、第11章和第14章）将会使用验证技术进行复杂程序的开发。在编写每一行代码的时候都使用验证语言来解释，这对概括每个循环的不变式特别有用。程序文本中重要的解释以断言的形式结束；而确定在实际软件中应包含哪些断言则是一门艺术，只能在实践中学习。</p>
<p class="content">验证语言常用于程序代码初次编写完成以后，在进行初次模拟的时候开始使用。测试过程中，违反断言语句的那些情况指明了程序的错误所在，而对相应情况形式的分析则指出了在不引入新错误的情况下如何修正程序中的错误。调试过程中，需要同时修正错误代码和错误的断言：总是保持对代码的正确理解，不要理会那种“只要能让程序工作，怎么改都行”的催促。下一章介绍了程序验证在程序的测试和调试过程中所扮演的几种重要角色。断言在程序维护过程中至关重要：当你拿到一段你从未见过而且多年来也没有其他人见过的代码时，有关该程序状态的断言对于理解程序是很有帮助的。</p>
<p class="content">这些仅是编写正确程序的很小一部分技术。编写简单的代码通常是得到正确程序的关键。另一方面，几个熟悉这些验证技术的专业程序员曾经对我讲述了一段在我自己编程时也常遇到的经历：当他们编写程序的时候，“困难”的部分第一次就可以正确运行，而那些“容易”的部分往往会出毛病。当开始编写困难的部分时，他们会坐下来仔细编程并成功地使用强大的正规技术。在编写容易的部分时，他们又返回到自己的编程老路上来了，结果当然是旧病复发了。在亲身经历之前，我也并不相信会有这种现象，这种尴尬的现象是经常使用验证技术的良好动力。</p>
<h3 class="thirdtitle" id="bw33">
<a href="part0000.xhtml#toc41">4.6 习题</a>
</h3>
<p class="content">1.尽管我们的二分搜索证明历经曲折，但是按照某些标准来衡量还是不够完善。你会如何证明该程序没有运行时错误（例如除数为0、数值溢出、变量值超出声明的范围或者数组下标越界）呢？如果有离散数学的基础知识，你能否使用逻辑系统形式化该证明？</p>
<p class="content">2.如果原始的二分搜索对你来说太过容易了，那么请试试这个演化后的版本：把 t在数组x中第一次出现的位置返回给p（如果存在多个t的话，原始的算法会任意返回其中的一个）。要求代码对数组元素进行对数次比较（该任务可以在log<span class="sub">2</span>
 n次比较之内完成）。</p>
<p class="content">3.编写并验证一个递归的二分搜索程序。代码和证明中的哪些部分与迭代版本的二分搜索程序相同？哪些部分发生了改变？</p>
<p class="content">4.给你的二分搜索程序添加虚拟的“计时变量”来计算程序执行的比较次数，并使用程序验证技术来证明其运行时间确实是对数的。</p>
<p class="content">5.证明下面的程序在输入x为正整数时能够终止。</p>
<p class="content">while x != 1 do</p>
<p class="content_5">if even(x)</p>
<p class="content_7">x = x/2</p>
<p class="content_5">else</p>
<p class="content_7">x = 3*x +1</p>
<p class="content">6.[C.Scholten]David Gries<span id="ref25">
<a href="part0007.xhtml#annot25">[23]</a>
</span>
 在其Science of Programming中将下面的问题称为“咖啡罐问题”。给定一个盛有一些黑色豆子和一些白色豆子的咖啡罐以及一大堆“额外”的黑色豆子，重复下面的过程，直至罐中仅剩一颗豆子为止。</p>
<p class="content">从罐中随机选取两颗豆子，如果颜色相同，就将它们都扔掉并且放入一个额外的黑色豆子；如果颜色不同，就将白色的豆子放回罐中，而将黑色的豆子扔掉。</p>
<p class="content">证明该过程会终止。最后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子的数量有何函数关系？</p>
<p class="content">7.一位同事在编写一个在位图显示器中画线的程序时遇到了下面的问题。n对实数(a<span class="sub">i</span>
 ,b<span class="sub">i</span>
 )构成的数组定义了n条直线y<span class="sub">i</span>
 =a<span class="sub">i</span>
 x+b<span class="sub">i</span>
 。当x位于[0,1]内时，对于区间[0,n-2]内的所有i，这些线段按y<span class="sub">i</span>
 &lt;y<span class="sub">i+</span>
 1排序：</p>
<div class="bodypic_"><img alt="" src="../Images/image00196.jpeg" class="calibre3"/>
</div>
<p class="content">用更形象的话说，这些线段在垂直方向上不交叉。给定一个满足0≤x≤1的点(x， y)，他需要确定包围这个点的两条线段。他该如何快速解决该问题呢？</p>
<p class="content">8.二分搜索一般比顺序搜索要快：在含有 n 个元素的表中查找，二分搜索需要大约log<span class="sub">2</span>
 n次比较，而顺序搜索需要大约n/2次比较。通常情况下这已经足够快了，但在有些情况下，二分搜索必须执行得更快。虽然我们无法减少由算法决定的对数级的比较次数，你可以重新编写代码使之执行得更快吗？为明确起见，假定你需要搜索一个包含1 000个整数的有序表。</p>
<p class="content">9.完成以下程序验证练习，准确说明以下每个程序片段的输入/输出动作，并证明代码可以完成其任务。第一个程序实现向量加法a=b+c。</p>
<p class="content_5">i = 0</p>
<p class="content_5">while i &lt; n</p>
<p class="content_7">a[i] = b[i] + c[i]</p>
<p class="content_7">i = i+1</p>
<p class="content">（该代码和下面的两个代码片段使用末尾带有自增运算的while循环展开了“for i =[0,n)”循环）。下面的代码片段计算数组x中的最大值。</p>
<p class="content_5">max = x[0]</p>
<p class="content_5">i = 1</p>
<p class="content_5">while i &lt; n do</p>
<p class="content_7">if x[i] &gt; max</p>
<p class="content_8">max = x[i]</p>
<p class="content_7">i = i+1</p>
<p class="content">下面的顺序搜索程序返回t在数组x[0..n-1]中第一次出现的位置。</p>
<p class="content_5">i = 0</p>
<p class="content_5">while i &lt; n &amp;&amp; x[i] != t</p>
<p class="content_7">i = i+1</p>
<p class="content_5">if i &gt;= n</p>
<p class="content_7">p = -1</p>
<p class="content_5">else</p>
<p class="content_7">p = i</p>
<p class="content">下面的程序以正比于n的对数的时间计算x的n次方。该递归程序的编码和验证很简单；其迭代版本比较复杂，留作附加题。</p>
<p class="content_5">function exp(x,n)</p>
<p class="content_7">pre n &gt;= 0</p>
<p class="content_7">post result = x^n</p>
<p class="content_5">if n = 0</p>
<p class="content_7">return 1</p>
<p class="content_5">else if even(n)</p>
<p class="content_7">return square(exp(x,n/2))</p>
<p class="content_5">else</p>
<p class="content_7">return x*exp(x,n-1)</p>
<p class="content">10.在二分搜索函数中引入错误，观察验证错误代码时这些引入的错误是否会（以及如何）被捕获？</p>
<p class="content">11.使用C或C++编写递归的二分搜索函数并证明其正确性，要求函数的声明如下：</p>
<p class="content_5">int binarysearch(DataType x[],int n)</p>
<p class="content">单独使用该函数，不要调用其他任何递归函数。</p>
<h3 class="thirdtitle" id="bw34">
<a href="part0000.xhtml#toc42">4.7 深入阅读</a>
</h3>
<p class="content">David Gries所著的Science of Programming是程序验证领域里极佳的一本入门书籍，该书的平装本由 Springer-Verlag 出版社于 1987 年出版。这本书先讲逻辑，进而对程序验证和开发进行了正规的介绍，最后讨论了常见语言的编程问题。本章尝试勾勒出了程序验证的潜在好处；对多数程序员来说，要想高效地使用程序验证技术，唯一的办法就是研读一本类似Gries著作的书。</p>
<h2 class="secondtitle" id="bw35">
<a href="part0000.xhtml#toc43">第5章 编程小事</a>
</h2>
<p class="content">到目前为止，你已经做了一切该做的事：通过深入挖掘定义了正确的问题，通过仔细选择算法和数据结构平衡了真正的需求，通过程序验证技术写出了优雅的伪代码，并且对其正确性相当有把握。那么如何将这些成果合并到你的大系统中呢？嗯，万事俱备，只欠不起眼的编程了。</p>
<p class="content">程序员都是乐观主义者，他们总是试图走捷径：编写函数代码，并将其插入系统中，然后热切地期望它能运行。有时候这样做行得通。但是有千分之九百九十九的概率，这样做会导致一场灾难：人们不得不在巨型系统的迷宫中操纵这个小小的函数。</p>
<p class="content">明智的程序员则使用脚手架（scaffolding）来方便地访问函数。本章着重论述如何将前一章中用伪代码描述的二分搜索程序实现为可靠的C函数。（使用C++或Java实现的代码与之非常相似，该方法同样适用于其他多数编程语言。）编写完代码以后，我们将使用脚手架来探察代码，然后更彻底地测试代码，并通过实验来了解运行时间。对这样一个小函数来说，这个过程太繁琐了。然而，这样做能够得到一段可以信赖的程序。</p>
<h3 class="thirdtitle" id="bw36">
<a href="part0000.xhtml#toc44">5.1 从伪代码到C程序</a>
</h3>
<p class="content">假设数组x和目标项t的数据类型均为DataType，DataType使用C语言的typedef语句定义如下：</p>
<p class="content">typedef int DataType;</p>
<p class="content">定义的类型可以是长整型、浮点型或其他任何类型。数组使用如下两个全局变量实现：</p>
<p class="content">int n;</p>
<p class="content">DataType x[MAXN];</p>
<p class="content">（尽管这对于多数C程序来说是很差的编程风格，但是它反映了在C++类中访问数据的方法；使用全局变量也可以得到较小的脚手架。）我们的目标是如下的C函数：</p>
<p class="content">int binarysearch(DataType t)</p>
<p class="content_4">/* precondition: x[0] &lt;= x[1] &lt;=...&lt;= x[n-1]</p>
<p class="content_6">postcondition:</p>
<p class="content_9">result == -1=&gt; t not present in x</p>
<p class="content_9">0 &lt;= result &lt; n =&gt; x[result] == t</p>
<p class="content_6">*/</p>
<p class="content">4.2节中的大部分伪代码语句都可以直接逐行转换成C程序（或多数其他语言的程序）。伪代码将数值存储在答案变量p中，对应的C语言程序则返回该值。使用C语言的无限循环语句for(;;)取代伪代码中的loop得到如下代码：</p>
<p class="content">for (;;) {</p>
<p class="content_5">if (l &gt; u)</p>
<p class="content_7">return -1;</p>
<p class="content_5">...rest of loop...</p>
<p class="content">}</p>
<p class="content">也可以通过逆转测试条件，把该循环变成while循环语句：</p>
<p class="content">while ( l &lt;= u) {</p>
<p class="content_5">...rest of loop...</p>
<p class="content">}</p>
<p class="content">return -1;</p>
<p class="content">于是得到最终的程序如下：</p>
<p class="content">int binarysearch(DataType t)</p>
<p class="content_5">/* return (any) position if t in sorted x[0..n-1] or</p>
<p class="content_7">-1 if t is not present */</p>
<p class="content">{ int l,u,m;</p>
<p class="content_5">l = 0;</p>
<p class="content_5">u = n-1;</p>
<p class="content_5">while (l &lt;= u) {</p>
<p class="content_7">m = (l + u) / 2;</p>
<p class="content_7">if (x[m] &lt; t)</p>
<p class="content_7">l = m+1;</p>
<p class="content_5">else if (x[m] == t)</p>
<p class="content_7">return m;</p>
<p class="content_5">else /* x[m] &gt; t */</p>
<p class="content_7">u = m-1;</p>
<p class="content_5">}</p>
<p class="content_5">return -1;</p>
<p class="content">}</p>
<h3 class="thirdtitle" id="bw37">
<a href="part0000.xhtml#toc45">5.2 测试工具</a>
</h3>
<p class="content">运用该函数的第一步当然是进行一些手动测试。小实例（零元、一元和二元数组）常常就足以检测出程序中的错误。更大些的数组测试开始变得乏味，于是就有了下一步：编写驱动程序来调用该函数。5行语句的C语言脚手架就可以完成该工作：</p>
<p class="content">while ( scanf("%d %d",&amp;n,&amp;t) != EOF) {</p>
<p class="content_5">for (i = 0; i &lt; n; i++)</p>
<p class="content_7">x[i] = 10*i;</p>
<p class="content_5">printf(" %d\n",binarysearch(t));</p>
<p class="content">}</p>
<p class="content">我们先测试一个仅有二十多行语句的C语言程序：binarysearch函数和包含上述代码的main函数。可以预计，当增加额外的脚手架时，该程序会变长。</p>
<p class="content">键入输入行“2 0”，程序产生一个二元数组，其中x[0]=0，x[1]=10，然后（在下一个缩进的行）给出搜索“0”的结果是：元素“0”位于位置“0”：</p>
<p class="content">2 0</p>
<p class="content_10">0</p>
<p class="content">2 10</p>
<p class="content_10">1</p>
<p class="content">2 -5</p>
<p class="content_10">-1</p>
<p class="content">2 5</p>
<p class="content_10">-1</p>
<p class="content">2 15</p>
<p class="content_10">-1</p>
<p class="content">键入的输入数据总是用斜体表示。下一对数据行显示元素“10”在位置1正确找到。后面的6行描述了3次正确的不成功搜索。至此，该程序正确地处理了具有两个不同元素的数组中所有可能的搜索。当程序陆续通过了不同规模输入的类似测试之后，我对程序的正确性越来越有信心了，并且也越来越厌倦这费时费力的手动测试。下一节描述了脚手架如何自动完成此项工作。</p>
<p class="content">不是所有的测试都是这么一帆风顺的。下面是几位专业程序员给出的二分搜索程序：</p>
<p class="content">int badsearch(DataType t)</p>
<p class="content">{　　int l,u,m;</p>
<p class="content_5">l = 0</p>
<p class="content_5">u = n-1;</p>
<p class="content_5">while (l &lt;= u) {</p>
<p class="content_7">m = (l + u) / 2</p>
<p class="content">/* printf(" %d %d %d\n",l,m,u) */</p>
<p class="content_7">if (x[m] &lt; t)</p>
<p class="content_8">l = m;</p>
<p class="content_7">else if (x[m] &gt; t)</p>
<p class="content_8">u = m;</p>
<p class="content_7">else</p>
<p class="content_8">return m;</p>
<p class="content_5">}</p>
<p class="content_5">return -1;</p>
<p class="content">}</p>
<p class="content">（我们很快就会回过头来讨论注释掉的printf语句。）你能找出这段代码中的问题吗？</p>
<p class="content">程序通过了前两个小测试。在五元数组的位置2找到了元素20，在位置3找到了元素30：</p>
<p class="content">5 20</p>
<p class="content_10">2</p>
<p class="content">5 30</p>
<p class="content_10">3</p>
<p class="content">5 40</p>
<p class="content">...</p>
<p class="content">当我试图搜索40时，程序进入了死循环。为什么？</p>
<p class="content">为解开这个谜团，我在上面的程序中插入了一个printf语句作为注释。（该语句向左侧突出，以表明它是脚手架。）该printf语句显示了每一次搜索中l、m和u的值的序列：</p>
<p class="content">5 20</p>
<p class="content_11">0 2 4</p>
<p class="content_4">2</p>
<p class="content">5 30</p>
<p class="content_11">0 2 4</p>
<p class="content_11">2 3 4</p>
<p class="content_4">3</p>
<p class="content">5 40</p>
<p class="content_11">0 2 4</p>
<p class="content_11">2 3 4</p>
<p class="content_11">3 3 4</p>
<p class="content_11">3 3 4</p>
<p class="content_11">3 3 4</p>
<p class="content_5">...</p>
<p class="content">第一次搜索在第一次探测的时候就找到了元素20，第二次搜索在第二次探测时找到了30。第三次搜索在前两次探测时也是好的，但是第三次探测就进入了死循环。当我们试图证明循环能够终止时就应该发现该错误了。</p>
<p class="content">当我需要调试一个深深嵌入大程序中的小算法时，我有时会在大程序中使用诸如单步跟踪之类的调试工具。但是，当面对这样的使用脚手架的算法时，print语句实现起来通常比复杂的调试器更快，也更有效。</p>
<h3 class="thirdtitle" id="bw38">
<a href="part0000.xhtml#toc46">5.3 断言的艺术</a>
</h3>
<p class="content">在第4章中开发二分搜索时，断言就扮演了数个重要的角色：既可以用来指导程序代码的开发，也可以用来判断程序的正确性。现在，我们将断言插入代码中，以确保程序运行时的行为与我们的理解相一致。</p>
<p class="content">我们使用assert表示我们相信某个逻辑表达式为真。语句assert(n≥0)在n为0或更大时什么都不做，但在 n 为负值时会报告某种错误（或许还会调用调试器）。在报告二分搜索程序找到其目标之前，我们可能作出如下断言：</p>
<p class="content_5">...</p>
<p class="content">else if (x[m] == t) {</p>
<p class="content_5">assert(x[m] == t);</p>
<p class="content_5">return m;</p>
<p class="content">} else</p>
<p class="content_5">...</p>
<p class="content">这个弱断言仅仅重复了if 语句的条件。我们或许希望对其进行加强，以断言其返回值在输入范围内：</p>
<p class="content">assert(0 &lt;= m &amp;&amp; m &lt; n &amp;&amp; x[m] == t);</p>
<p class="content">当循环因为没有找到目标值而终止时，我们知道l和u已经交叉了，于是可以知道元素并不在数组中。我们可能会试图去断言我们找到了一对相邻的元素值，其中一个小于目标值，另一个大于目标值：</p>
<p class="content">assert(x[u] &lt; t &amp;&amp; x[u+1] &gt; t);</p>
<p class="content">return -1;</p>
<p class="content">其逻辑如下：如果在排序后的表中1和3相邻，那么我们就可以确定2不存在于表中。即使对正确的程序，该断言有时候也会失败，为什么？</p>
<p class="content">当n为零时，变量u初始化为-1，于是，下标会索引至数组之外的某个元素。要使断言有效，必须通过测试边界将其弱化：</p>
<p class="content">assert((u &lt; 0 || x[u] &lt; t) &amp;&amp; (u+1 &gt;= n || x[u+1] &gt; t));</p>
<p class="content">该断言确实可以在不完善的搜索中发现程序的一些错误。</p>
<p class="content">可以通过证实在每次迭代之后范围都减小来证明搜索一定会终止。我们可以通过添加一点额外的计算和一条断言，在程序执行时测试该性质。我们将 size 初始化为n+1，然后在for语句后插入如下代码：</p>
<p class="content">oldsize = size;</p>
<p class="content">size = u - l + 1;</p>
<p class="content">assert(size &lt; oldsize);</p>
<p class="content">我经常陷入这样的尴尬境地：自己费尽精力调通了一个二分搜索程序，却发现错误原因仅仅是待搜索的数组未排序。一旦定义了下面的函数：</p>
<p class="content">int sorted()</p>
<p class="content">{ int i;</p>
<p class="content_5">for ( i = 0; i &lt; n-1; i++)</p>
<p class="content_7">if ( x[i] &gt; x[i+1])</p>
<p class="content_8">return 0;</p>
<p class="content_5">return 1;</p>
<p class="content">}</p>
<p class="content">就可以断言 assert(sorted())了。但是必须注意，由于该测试的开销较大，我们应该只在所有的搜索之前进行一次测试。将该测试包含在主循环之中会导致二分搜索的运行时间正比于n log n。</p>
<p class="content">在脚手架中测试该函数时，断言会很有帮助。当我们从组件测试转向系统测试时，断言同样也很有帮助。某些项目使用预处理器定义断言，于是可以在编译阶段处理断言，而不会导致运行时的额外开销。另外，Tony Hoare曾经注意到，在测试时使用断言，而在产品发布时将断言关闭的程序员，就像是在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。</p>
<p class="content">Steve Maguire的Writing Solid Code一书（微软出版社1993年出版）第2章论述了在工业级软件中断言的应用。他详细描述了在微软的产品和库中使用断言的几个纷争。</p>
<h3 class="thirdtitle" id="bw39">
<a href="part0000.xhtml#toc47">5.4 自动测试</a>
</h3>
<p class="content">我们已经在该程序上做了足够多的工作来确保其正确性，并且我们也已经厌倦了手动输入测试用例。下一步就是建立脚手架，使用机器对程序进行自动测试。测试函数的主循环运行时，n从最小的可能值（0）变化到最大的合理值：</p>
<p class="content">for n = [0,maxn]</p>
<p class="content_5">print "n=",n</p>
<p class="content_5">/* test value n */</p>
<p class="content">print语句报告测试的进度。有些程序员不喜欢这样做：这样仅仅得到了一些混乱而非实质性的信息；另一些程序员则从中得到了慰藉，并可以在发现第一个错误的时候知道程序已经通过了哪些测试。</p>
<p class="content">测试循环的第一部分检验了所有元素互异的情况（在数组顶部放置了一个多余的元素，以确保搜索不会定位到该位置）。</p>
<p class="content">/* test distinct elements (plus one at the end) */</p>
<p class="content">for i = [0,n]</p>
<p class="content_5">x[i] = 10*i</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">assert(s(10*i)　　 ==　i)</p>
<p class="content_5">assert(s(10*i - 5) == -1)</p>
<p class="content">assert(s(10*n - 5) == -1)</p>
<p class="content">assert(s(10*n)　　 ==　-1)</p>
<p class="content">为了方便地测试不同的功能，我们定义要测试的函数如下：</p>
<p class="content">#define s binarysearch</p>
<p class="content">程序中的断言为成功的和不成功的搜索测试每一个可能的位置，以及元素在数组中但位于搜索边界之外的情况。</p>
<p class="content">测试循环的下一部分探测所有元素都相等的数组：</p>
<p class="content">/* test equal elements */</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">x[i] = 10</p>
<p class="content">if n == 0</p>
<p class="content_5">assert (s(10) == -1)</p>
<p class="content">else</p>
<p class="content_5">assert(0 &lt;= s(10) &amp;&amp; s(10) &lt; n)</p>
<p class="content">assert(s(5) == -1)</p>
<p class="content">assert(s(15) == -1)</p>
<p class="content">该程序搜索数组中的元素以及稍小和稍大些的元素。</p>
<p class="content">这些测试覆盖了程序的大部分内容。对n在0～100范围的取值进行测试涵盖了空数组、常见的出错规模（0，1，2）、2的几个幂次以及许多与 2的幂次相差1的数值。手动进行这些测试会极度枯燥（并可能因此导致出错），而用计算机来测试则只需要极少的时间。当maxn为1 000时，这些测试在我的计算机上仅需要几秒钟的时间。</p>
<h3 class="thirdtitle" id="bw40">
<a href="part0000.xhtml#toc48">5.5 计时</a>
</h3>
<p class="content">大量的测试使我们确信该搜索程序是正确的。接下来如何确信该程序完成二分搜索任务需要大约log<span class="sub">2</span>
 n次比较呢？下面是计时脚手架的主循环：</p>
<p class="content">while read(algnum,n,numtests)</p>
<p class="content_5">for i = [0,n)</p>
<p class="content_7">x[i] = i</p>
<p class="content_5">starttime = clock()</p>
<p class="content_5">for testnum = [0,numtests)</p>
<p class="content_7">for i = [0,n)</p>
<p class="content_8">switch (algnum)</p>
<p class="content_8">case 1:assert(binarysearch1(i) == i)</p>
<p class="content_8">case 2:assert(binarysearch2(i) == i)</p>
<p class="content_5">clicks = clock() - starttime</p>
<p class="content_5">print algnum,n,numtests,clicks,</p>
<p class="content_7">clicks/(le9 * CLOCKS_PER_SEC * n *numtests)</p>
<p class="content">该代码计算在n个不同元素构成的数组中进行一次成功的二分搜索所需要的平均运行时间。代码首先初始化数组，然后对数组中的每一个元素执行numtests次搜索。switch语句选择需要测试的算法（脚手架应该总是可以对数个不同的程序进行检测）。print语句报告三个输入值和两个输出值：时钟的原始值（观察这些值总是很关键）以及一个更容易解释的值（本例中为用纳秒表示的每次搜索的平均运行时间，纳秒单位在print语句中由转换系数1e9给出）。</p>
<p class="content">下面是该程序在400 MHz Pentium II计算机上实际运行的情况（与以往一样，键入的输入数据采用斜体表示）：</p>
<p class="content">1　 1000　10000</p>
<p class="content_1">1　　　　1000　　 10000　　3445　　 344.5</p>
<p class="content">1　 10000　1000</p>
<p class="content_1">1　　　　10000　　1000　　 4436　　 443.6</p>
<p class="content">1　 100000　 100</p>
<p class="content_1">1　　　　100000　 100　　　 5658　　 565.8</p>
<p class="content">1　 1000000　10</p>
<p class="content_1">1　　　　1000000　10　　　　6619　　 661.9</p>
<p class="content">第一行在一个1 000个元素的数组上对算法1（到目前为止我们一直在研究的二分搜索）进行了10 000次测试，共花费了3 445个时钟单位（在该系统中用毫秒表示）。也就是说平均每次搜索需要344.5纳秒的时间。随后的三个测试每次将n扩大10倍，而将测试的次数减少为前一次的十分之一。搜索的运行时间看起来大约是50+30log<span class="sub">2</span>
 n纳秒。</p>
<p class="content">接下来我编写了一个三行的程序来生成计时脚手架的输入。输出采用图形打印出来。如图所示，平均的搜索开销确实按log n增长。习题7研究了该脚手架的一个潜在的计时错误。在研究该习题之前，请先不要太相信这些数。</p>
<div class="bodypic_"><img alt="1 000 10 000 100 000 1 000 000平均每次搜索所需的时间（以纳秒为单位）数组大小" src="../Images/image00197.jpeg" class="calibre3"/>
</div>
<h3 class="thirdtitle" id="bw41">
<a href="part0000.xhtml#toc49">5.6 完整的程序</a>
</h3>
<p class="content">我相信用C语言实现的二分搜索程序是正确的。为什么？我仔细地将伪代码转换成方便的语言，然后使用分析技术验证了其正确性。我逐行将其转换成C语言程序，然后给出输入并观察其输出。我在代码各处都放置了断言，以确保我的理论分析和实际结果是一致的。计算机负责完成其擅长的工作，并用测试用例对程序进行了测试。最后，简单的实验表明其运行时间与理论预期的一样短。</p>
<p class="content">有了这些保证，我应该可以放心地使用该程序在大系统中执行对有序数组的搜索了。如果在该C代码中发现逻辑错误，我会非常惊讶；但是如果发现许多其他类型的错误，我不会感到震惊。调用者有没有忘记对表进行排序？如果搜索的项不存在于表中，期望的返回值是-1 吗？如果目标项在表中多次出现，这个程序会任意返回一个下标；用户需要的到底是第一次还是最后一次出现的下标？还有诸如此类的许多其他问题。</p>
<p class="content">该程序代码可以信赖吗？你可以信任我。（呵呵，但也不要什么话都相信啊，我现在有一座大桥要出售，你想不想买？）当然，还是应该从本书的网站上直接下载这个程序的代码，自己研究一下。这段代码包括到目前为止我们讨论过的所有函数，以及将在第9章讨论的几个二分搜索的变体。其主函数大致如下：</p>
<p class="content">int main(void)</p>
<p class="content">{ /* probe1(); */</p>
<p class="content_4">/* test(25); */</p>
<p class="content_4">timedriver();</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">注释掉上面三个函数中的两个，只保留一个函数调用，我们就可以用特定的输入运行程序、用测试用例测试函数或者进行计时实验。</p>
<h3 class="thirdtitle" id="bw42">
<a href="part0000.xhtml#toc50">5.7 原理</a>
</h3>
<p class="content">本章对一个小问题花费了大量的笔墨。该问题虽小，却不容易。回想4.1节提到的：虽然第一篇二分搜索论文在1946年就发表了，但是第一个对所有的n值都没有错误的二分搜索程序却直到 1962 年才出现。如果早期的程序员能够采用本章中讨论的方法，也许得到正确的二分搜索程序就用不着16年了。</p>
<p class="content">脚手架。最好的脚手架通常是最容易构建的脚手架。对某些任务来说，最简单的脚手架由一个使用Visual Basic、Java或Tcl之类的语言实现的图形用户界面构成。对于上述每一种语言，我都在半小时之内实现过具有点击控件和良好的图形输出的小程序。不过，对于许多算法任务而言，我发现更容易的办法是，摒弃这些强大的工具并使用我们在本章中见过的更简单（也更易移植）的命令行技术。</p>
<p class="content">编码。对于比较难写的函数，我发现最容易的方法是使用方便的高级伪代码来构建程序框架，然后将伪代码翻译成要实现的语言。</p>
<p class="content">测试。在脚手架中对组件进行测试要比在大系统中更容易、更彻底。</p>
<p class="content">调试。对隔离在其脚手架中的程序进行调试是很困难的，但是若将其嵌入真实运行环境中，调试工作会更困难。5.10节讲述了一些调试大型系统的故事。</p>
<p class="content">计时。如果运行时间不重要，线性搜索要比二分搜索简单得多；许多程序员都可以在第一次实现的时候得到正确的代码。正是由于运行时间非常重要，我们才引入了更加复杂的二分搜索，所以，我们应该进行实验以确保程序能够达到我们预期的性能。</p>
<h3 class="thirdtitle" id="bw43">
<a href="part0000.xhtml#toc51">5.8 习题</a>
</h3>
<p class="content">1.全面评论一下本章以及本书的编程风格。解决变量名、二分搜索函数的形式和规范说明、代码的布局等方面的问题。</p>
<p class="content">2.将二分搜索的伪代码描述转换成C语言之外的其他编程语言，并建立脚手架对你的实现进行测试和调试。所使用的语言和系统对你有哪些帮助，又有哪些妨碍？</p>
<p class="content">3.在二分搜索函数中引入错误。如何通过测试捕获这些错误？脚手架是如何帮助你找出错误的？（这个练习最好作为一个双人游戏来完成，其中攻击方引入错误，而防御方则必须追踪错误）。</p>
<p class="content">4.重复习题3，但是这次让二分搜索的代码保持正确而将错误引入调用二分搜索的函数中（例如忘记对数组进行排序）。</p>
<p class="content">5.[R.S.Cox]一个常见的错误就是把二分搜索应用于未排序的数组，而在每次搜索前检测整个数组是否有序需要进行n-1次额外的比较。你能否为该函数添加部分检测程序，以显著降低检测的开销？</p>
<p class="content">6.实现一个用于研究二分搜索算法的图形用户界面。为增加调试效率而付出额外的开发时间是否值得？</p>
<p class="content">7.5.5节的计时脚手架有一个潜在的计时错误：通过按顺序搜索每个元素，我们获得了非常有利的缓存性能。如果已知在潜在的应用中搜索是按相似的方式进行的，那么这是一个正确的程序框架（但是那样的话二分搜索恐怕并不是一个恰当的工具）。但是，如果我们希望搜索算法对数组的探测随机进行，那么我们也许还应该初始化并打乱一个排列向量</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">p[i] = i</p>
<p class="content">scramble(p,n)</p>
<p class="content">然后按随机顺序执行搜索</p>
<p class="content">assert(binarysearch1(p[i]) == p[i])</p>
<p class="content">度量这两个版本的运行时间，看看是否存在差异。</p>
<p class="content">8.脚手架并未被充分利用，而且很少有公开的描述。查看你所能找到的任意脚手架，失望或许会驱使你去访问本书的网站。编写脚手架来测试一个你自己编写的复杂函数。</p>
<p class="content">9.从本书的网站上下载search.c脚手架程序，通过实验看看二分搜索程序在你机器上的运行时间。你打算使用哪些工具来生成输入以及存储并分析输出？</p>
<h3 class="thirdtitle" id="bw44">
<a href="part0000.xhtml#toc52">5.9 深入阅读</a>
</h3>
<p class="content">Kernighan和Pike的Practice of Programming<span id="ref26">
<a href="part0007.xhtml#annot26">[24]</a>
</span>
 由Addison-Wesley出版社于1999年出版。他们使用了50页的篇幅来讲述调试（第5章）和测试（第6章）。这两章介绍了不可重现的错误、回归测试等超出本章范围的一些重要主题。</p>
<p class="content">对每一个实际程序员来说，这本书的9章都很有吸引力并且很有趣。除了上面提到的两章外，其他各章的题目包括编程风格、算法与数据结构、设计与实现、接口、性能、可移植性和表示法。书中深入剖析了两个熟练程序员的编程技巧和风格。</p>
<p class="content">本书的3.8节介绍了Steve McConnell的《代码大全》一书。该书的第25章讲述了“单元测试”，第26章描述了“调试”。</p>
<h3 class="thirdtitle" id="bw45">
<a href="part0000.xhtml#toc53">5.10 调试（边栏）</a>
</h3>
<p class="content">每个程序员都知道调试是很困难的。但是，伟大的调试人员可以使这个工作看起来很简单。心烦意乱的程序员向调试大师描述了一个他们花费数小时也没有捕捉到的错误，而大师询问了几个问题之后，他们花几分钟的时间就找到了错误代码。专业的调试人员永远也不会忘记，无论系统的行为乍看起来多么神秘莫测，其背后总有合乎逻辑的解释。</p>
<p class="content">IBM的Yorktown Heights研究中心发生的一件轶事可以说明这一点。一位程序员刚刚安装了一台新的工作站。当他坐着时一切正常，但是，一旦他站起来，就不能登录系统。这种情况是百分之百可重复的：坐着时，他总是可以登录系统；站着时，他总是不能登录系统。</p>
<p class="content">我们中的多数人都不会采取任何行动，而仅仅是为此感到惊奇。工作站是如何知道这个可怜的家伙是坐着还是站着的呢？但是，优秀的调试人员知道其中必定有一个合理的解释。从电气原理角度最容易进行假设。是地毯下面的某根电线松动了，还是问题出在静电上？但是电气问题极少每次的现象都完全一致。一位机灵的同事最终问到了正确的问题：程序员坐着和站着时分别是如何登录的呢？伸出自己的手，尝试一下这两种登录方式吧。</p>
<p class="content">问题出在键盘上：有两个键的键帽被交换了位置。当程序员坐着时，他采用盲打的方式进行登录，此时问题没有暴露出来。但是，当他站起来的时候，就不得不看着键盘输入，也就误入歧途了。发现了这一点之后，一位专业调试人员使用一把改锥交换了那两个装错位置的键帽，于是一切恢复正常了。</p>
<p class="content">芝加哥的一个银行系统已经正确运行了好几个月，但是第一次用于国际数据就出现了非正常退出。程序员们花费了几天的时间来清理代码，但是他们没有发现任何导致程序退出的错误命令。当他们更深入地观察该现象时，发现当为厄瓜多尔这个国家输入数据时程序出现了非正常退出。更进一步的观察发现，当用户键入其首都的名字基多（Quito）时，程序将其解释为退出请求。</p>
<p class="content">Bob Martin曾经遇到过一个“连续两轮仅首次运行正确”的系统。系统能正确处理第一个事务，但是在随后的所有事务中，总是有一个小错误。当系统重新启动后，又能正确处理第一个事务，而在随后的所有事务中又出现错误。当Martin将之形象地称为“连续两轮仅首次运行正确”时，程序开发人员立即知道需要去查找一个这样的变量：当程序加载时，该变量的初始化是正确的；但是在第一个事务之后没有正确地复位。</p>
<p class="content">在所有的实例中，正确的问题都可以引导聪明的程序员快速找到可恶的错误：“坐着和站着时你所做的有何区别？我可以看着你按两种方式分别登录吗？”“在程序退出之前你到底输入了什么？”“程序在出错之前是否曾正确运行？正确运行了多少次？”</p>
<p class="content">Rick Lemons说，他上过的最好的一节程序调试课是观看一场魔术表演。魔术师表演了6个事实上不可能的戏法，Lemons发现自己开始有点相信这是真的了。然后，他提醒自己，所有的这些都是不可能实现的，并且开始探究每个戏法的明显矛盾之处。他从自己已知的基础原理（物理学定律）开始，试图发现每个戏法的简单解释。这种态度令Lemons成为我见过的最优秀的调试人员之一。</p>
<p class="content">我读过的最好的关于调试的书籍是由 Berton Rouech é编写的 The Medical Detectives。该书于1991年由Penguin出版社出版。书中的主人公们“调试”复杂的系统，其范围从病情一般的病人到重病的城镇。他们解决问题的方法可以直接应用于调试计算机系统。这些真实的故事与任何虚构的故事一样具有吸引力。</p>
<hr class="calibre2"/>
<p class="noindent" id="annot3">
<a href="part0007.xhtml#ref3">[1].</a>
 折中在所有的工程领域中都存在。例如，汽车设计者可能会通过增加沉重的部件，用行驶里程的减少来换取更快的加速。但双赢是更好的结果。我对自己驾驶过的一辆小轿车做过一番研究，我观察到：“轿车基本结构重量的减少会使各底盘部件重量的进一步减少——甚至消除了对某些底盘部件的需求，例如转向助力系统。”</p>
<p class="noindent" id="annot4">
<a href="part0007.xhtml#ref4">[2].</a>
 Michael Jackson（1936—），软件工程先驱。他于20世纪70年代提出了影响深远的面向数据结构的Jackson方法。——编者注</p>
<p class="noindent" id="annot5">
<a href="part0007.xhtml#ref5">[3].</a>
 Martin Gardner（1914—），美国著名的科普作家，主持《科学美国人》的数学游戏专栏25年，写作了大量文章和图书，有世界影响。——编者注</p>
<p class="noindent" id="annot6">
<a href="part0007.xhtml#ref6">[4].</a>
 即循环移位。——审校者注</p>
<p class="noindent" id="annot7">
<a href="part0007.xhtml#ref7">[5].</a>
 Doug McIlroy（1932—），著名计算机科学家，美国工程院院士，现为达特茅斯学院兼职教授。他于1968年第一个提出了软件组件的概念。他参与设计了PL/I和C++语言、Multics和Unix操作系统。Unix上许多工具是他开发的，包括diff、echo、sort、spell和join等，管道实现也由他首创。他曾长期担任贝尔实验室计算技术研究部主任，并曾任ACM图灵奖主席。——编者注</p>
<p class="noindent" id="annot8">
<a href="part0007.xhtml#ref8">[6].</a>
 Brian Kernighan（1942—）著名计算机科学家，现为普林斯顿大学教授。他与人合作创造了Awk和AMPL编程语言，对Unix和C语言的设计也有很大贡献。他还与人合写了多部计算机名著，包括与Ritchie合著的The C Programming Language。——编者注</p>
<p class="noindent" id="annot9">
<a href="part0007.xhtml#ref9">[7].</a>
 P.J.Plauger，著名C/C++语言专家，现为著名标准库开发商Dinkumware总裁。他曾担任ISO C标准委员会负责人，著有名著《C标准库》（中文版由人民邮电出版社出版）。——编者注</p>
<p class="noindent" id="annot10">
<a href="part0007.xhtml#ref10">[8].</a>
 Ken Thompson（1943—），著名计算机科学家，1983年图灵奖得主。现为Google杰出工程师。他是Unix操作系统的主要设计者，并设计了C语言的前身B语言。——编者注</p>
<p class="noindent" id="annot11">
<a href="part0007.xhtml#ref11">[9].</a>
 该变位词算法是由许多人各自独立发现的，至少可以追溯到20世纪60年代中期。</p>
<p class="noindent" id="annot12">
<a href="part0007.xhtml#ref12">[10].</a>
 Don Knuth（1938—），中文名高德纳，著名计算机科学家，斯坦福大学荣休教授。因对算法分析和编程语言设计领域的贡献获1974年图灵奖。他是名著The Art of Computer Programming的作者，设计了TEX排版系统。——编者注</p>
<p class="noindent" id="annot13">
<a href="part0007.xhtml#ref13">[11].</a>
 该书第2版英文影印版已由清华大学出版社引进出版，中文书名《计算机程序设计艺术 第3卷 排序和查找》，中译版已由国防工业出版社出版，中文书名《计算机程序设计艺术 第3卷 排序与查找》。——编者注</p>
<p class="noindent" id="annot14">
<a href="part0007.xhtml#ref14">[12].</a>
 Mike Lesk，著名程序员，ACM会士，美国工程院院士，现任Rutgers大学教授兼系主任。他在贝尔实验室工作期间开发了大量工具，包括lex、uucp和stdio.h的前身。他领导了美国NSF数字图书馆计划，该计划支持了斯坦福大学搜索引擎研究项目，促生了Google。——编者注</p>
<p class="noindent" id="annot15">
<a href="part0007.xhtml#ref15">[13].</a>
 边栏在杂志的文章中是处在正文之外的，通常是页边上的一列。它们本质上不是专栏的一部分，仅仅提供了关于材料的一些观点。在本书中，它们作为每章的最后一节出现，用“（边栏）”来标记。</p>
<p class="noindent" id="annot16">
<a href="part0007.xhtml#ref16">[14].</a>
 原文为“Data Structures Programs”，其中structure为动词。本章深刻阐述了对数据的理解和具体表现形式的选择对程序的影响。——编者注</p>
<p class="noindent" id="annot17">
<a href="part0007.xhtml#ref17">[15].</a>
 平行数组是一种老式数据结构，通过元素数相同且下标对应的一组数组表示紧密相关的信息。已经逐渐被结构（struct）所取代。——编者注</p>
<p class="noindent" id="annot18">
<a href="part0007.xhtml#ref18">[16].</a>
 David Parnas（1941—），软件工程先驱，ACM会士。他提出了“内聚”、“耦合”、“信息隐藏”等模块化设计思想，这些都已成为面向对象程序设计的基础。——编者注</p>
<p class="noindent" id="annot19">
<a href="part0007.xhtml#ref19">[17].</a>
 该书中译版已由上海科技教育出版社出版，中文书名《怎样解题》。——编者注</p>
<p class="noindent" id="annot20">
<a href="part0007.xhtml#ref20">[18].</a>
 Fred Brooks（1931—），著名计算机科学家，因在计算机体系结构、操作系统和软件工程方面里程碑性的贡献而荣获1999年图灵奖。他领导了OS/360操作系统的开发，并以此经历写成名著《人月神话》。——编者注</p>
<p class="noindent" id="annot21">
<a href="part0007.xhtml#ref21">[19].</a>
 Steve McConnel，著名软件工程专家。曾长期担任IEEE Software期刊的主编和IEEE计算机学会Professional Practice委员会主席。他还是SWEBOK项目专家组成员。所著《代码大全》产生了广泛影响。——编者注</p>
<p class="noindent" id="annot22">
<a href="part0007.xhtml#ref22">[20].</a>
 该书英文影印版《快速软件开发》已由机械工业出版社出版。中译版《快速软件开发——有效控制与完成进度计划》已由电子工业出版社出版。——编者注</p>
<p class="noindent" id="annot23">
<a href="part0007.xhtml#ref23">[21].</a>
 该书英文影印版《软件项目生存指南》已由清华大学出版社出版。——编者注</p>
<p class="noindent" id="annot24">
<a href="part0007.xhtml#ref24">[22].</a>
 如果在评价短变量名、二分搜索函数定义、出错处理以及其他对于大型软件项目的成功至关重要的编程风格问题时需要帮助的话，可以参考习题5.1及其答案。</p>
<p class="noindent" id="annot25">
<a href="part0007.xhtml#ref25">[23].</a>
 David Gries（1939—），著名计算机科学家，ACM会士，现任康奈尔大学教授。他在编程方法学、编程语言语义和教学等方面成就颇多。——编者注</p>
<p class="noindent" id="annot26">
<a href="part0007.xhtml#ref26">[24].</a>
 该书英文影印版和中译版已由机械工业出版社引进出版，中文书名为《程序设计实践》。——编者注</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0006.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0008.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
