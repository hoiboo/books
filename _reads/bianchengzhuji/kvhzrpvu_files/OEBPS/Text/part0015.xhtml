<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>附录D 代码调优法则</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc139">附录D 代码调优法则</a>
</h1>
<p class="content">我1982年的Writing Efficient Programs一书为代码调优提供了27个法则。该书现已绝版，因此我在这里再次列出那些法则（只作了一些很小的改动），并给出它们在本书中的应用示例。</p>
<p class="content_1">D.1 空间换时间法则</p>
<p class="content">修改数据结构。为了减少数据上的常见运算所需要的时间，我们通常可以在数据结构中增加额外的信息，或者修改数据结构中的信息使之更易访问。</p>
<p class="content">9.2节中，Wright希望在一组用经纬度表示的球面的点中查找最近邻（利用角度），这项工作涉及费时的三角函数运算。Appel修改了数据结构，用x、y和z坐标代替了经纬度，从而大大减少了计算欧氏距离的时间。</p>
<p class="content">存储预先计算好的结果。对于开销较大的函数，可以只计算一次，然后将计算结果存储起来以减少开销。以后再需要该函数时，可以直接查表而不需要重新计算。</p>
<p class="content">8.2节和答案8.11的累加数组使用两次查表和一次减法来代替一系列的加法。</p>
<p class="content">答案9.7通过一次查找一个字节或单词来加速程序对位的计数。</p>
<p class="content">答案10.6使用表查找替代了移位和逻辑运算。</p>
<p class="content">高速缓存。最经常访问的数据，其访问开销应该是最小的。</p>
<p class="content">9.1节描述了Van Wyk如何缓存最常用的结点大小，以避免对系统存储分配器的高开销调用。答案9.2给出了一种结点缓存的细节。</p>
<p class="content">第13章为链表、箱和二分搜索树缓存了结点。</p>
<p class="content">如果没有指明在基本数据中的位置，那么高速缓存就达不到期望的效果，只会增加程序的运行时间。</p>
<p class="content">懒惰求值。除非需要，否则不对任何一项求值。这一策略可以避免对不必要的项求值。</p>
<p class="content_1">D.2 时间换空间法则</p>
<p class="content">堆积。密集存储表示可以通过增加存储和检索数据所需的时间来减少存储开销。</p>
<p class="content">10.2 节的稀疏数组表示只稍微增加了一些访问该结构的时间，却大大减少了存储开销。</p>
<p class="content">13.8节中McIlroy的拼写检查器字典将75 000个英语单词压缩到了52 KB。</p>
<p class="content">10.3节中Kernighan的数组和14.4节中的堆排序都使用了共享空间技术，通过在同一内存空间中存储不可能被同时调用的数据项来节省数据空间。</p>
<p class="content">尽管堆积有时通过牺牲时间来获取空间，但是这种较小的表示方式处理起来通常更快。</p>
<p class="content">解释程序。使用解释程序通常可以减少表示程序所需的空间，在解释程序中常见的操作序列以一种紧凑的方式表示。</p>
<p class="content">3.2节为“格式信函编程”使用了解释程序，10.4节为一个简单的图形程序使用了解释程序。</p>
<p class="content_1">D.3 循环法则</p>
<p class="content">将代码移出循环。与其在循环的每次迭代时都执行一次某种计算，不如将其移到循环体外，只计算一次。</p>
<p class="content">11.1节将对变量t的赋值移出了isort 2的主循环。</p>
<p class="content">合并测试条件。高效的内循环应该包含尽量少的测试条件，最好只有一个。因此，程序员应尽量用一些退出条件来模拟循环的其他退出条件。</p>
<p class="content">哨兵是该法则的常见应用：在数据结构的边界上放一个哨兵以减少测试是否已搜索结束的开销。9.2节在顺序搜索数组时用到了哨兵。第13章使用哨兵为数组、链表、箱和二分搜索树生成清晰（而且高效）的代码。答案14.1在堆的一端放置了一个哨兵。</p>
<p class="content">循环展开。循环展开可以减少修改循环下标的开销，对于避免管道延迟、减少分支以及增加指令级的并行性也都很有帮助。</p>
<p class="content">展开9.2节的顺序搜索大约能将运行时间缩短50%，展开9.3节的二分搜索可以使运行时间缩短35%～65%。</p>
<p class="content">删除赋值。如果内循环中很多开销来自普通的赋值，通常可以通过重复代码并修改变量的使用来删除这些赋值。具体说来，删除赋值i = j后，后续的代码必须将j视为i。</p>
<p class="content">消除无条件分支。快速的循环中不应该包含无条件分支。通过“旋转”循环，在底部加上一个条件分支，能够消除循环结束处的无条件分支。</p>
<p class="content"> 该操作通常由优化的编译器完成。</p>
<p class="content">循环合并。如果两个相邻的循环作用在同一组元素上，那么可以合并其运算部分，仅使用一组循环控制操作。</p>
<p class="content_1">D.4 逻辑法则</p>
<p class="content">利用等价的代数表达式。如果逻辑表达式的求值开销太大，就将其替换为开销较小的等价代数表达式。</p>
<p class="content">短路单调函数。如果我们想测试几个变量的单调非递减函数是否超过了某个特定的阈值，那么一旦达到这个阈值就不再需要计算任何变量了。</p>
<p class="content">该法则的一个更成熟的应用就是，一旦达到了循环的目的就退出循环。第10章、第13章和第15章中的搜索循环都是一旦找到所需的元素就终止。</p>
<p class="content">对测试条件重新排序。在组织逻辑测试的时候，应该将低开销的、经常成功的测试放在高开销的、很少成功的测试前面。</p>
<p class="content">答案9.6简要介绍了一系列可能已重新排过序的测试。</p>
<p class="content">预先计算逻辑函数。在比较小的有限域上，可以用查表来取代逻辑函数。</p>
<p class="content">答案9.6描述了如何通过查表来实现标准C的库字符分类函数。</p>
<p class="content">消除布尔变量。我们可以用if - else语句来取代对布尔变量v的赋值，从而消除程序中的布尔变量。在该if - else语句中，一个分支表示v为真的情况，另一个分支表示v为假的情况。</p>
<p class="content_1">D.5 过程法则</p>
<p class="content">打破函数层次。对于（非递归地）调用自身的函数，通常可以通过将其改写为内联版本并固定传入的变量来缩短其运行时间。</p>
<p class="content">使用宏替代9.2节的max函数，几乎能够使速度提高1倍。</p>
<p class="content">把11.1节的swap函数改写为内联版本，几乎可以使速度变为原来的3倍；而把11.3节的swap函数改为内联版本，速度提升的比例就小一些了。</p>
<p class="content">高效处理常见情况。应该使函数能正确处理所有情况，并能高效处理常见情况。</p>
<p class="content">9.1节中，Van Wyk的存储分配器能正确处理所有结点大小；对于最常见的结点大小，程序的处理效率尤其高。</p>
<p class="content">6.1节中，Appel使用专用的小时间步长处理高开销的邻近对象，这就使得程序的其他部分可以使用更为高效的大时间步长。</p>
<p class="content">协同程序。通常，使用协同例程能够将多趟算法转换为单趟算法。</p>
<p class="content">2.8节的变位词程序使用了管道，这能通过一组协同程序来实现。</p>
<p class="content">递归函数转换。递归函数的运行时间往往可以通过下面的转换来缩短。</p>
<p class="content">将递归重写为迭代，如第13章的链表和二分搜索树。通过使用一个显式的程序栈将递归转化为迭代。（如果函数仅包含一个对其自身的递归调用，那么就没有必要将返回地址存储在栈中）。</p>
<p class="content">如果函数的最后一步是递归调用其自身，那么使用一个到其第一条语句的分支来替换该调用，这通常称为消除尾递归。答案11.9的代码给出了一个尾递归的例子，该分支往往可以转换为一个循环，通常由编译器来执行这一优化。</p>
<p class="content">解决小的子问题时，使用辅助过程通常比把问题的规模变为0或1更有效。</p>
<p class="content">11.3节的qsort4函数用到了一个接近50的小整数cutoff值。</p>
<p class="content">并行性。在底层硬件条件下，我们构建的程序应该尽可能多地挖掘并行性。</p>
<p class="content_1">D.6 表达式法则</p>
<p class="content">编译时初始化。在程序执行之前，应该对尽可能多的变量初始化。</p>
<p class="content">利用等价的代数表达式。如果表达式的求值开销太大，就将其替换为开销较小的等价代数表达式。</p>
<p class="content">9.2节中，Appel用乘法和加法取代了高开销的三角函数运算，并利用单调性消除了高开销的开方运算。</p>
<p class="content">9.2节使用开销较小的if语句替换了内循环中高开销的C取模运算符%。</p>
<p class="content">乘以或除以2的幂通常可以通过左移或右移来实现。答案13.9把箱所使用的任意除法替换为移位。答案10.6把除以10的运算替换为移动4位。</p>
<p class="content">6.1 节中，Appel 充分利用了数据结构所提供的额外精度，用更为快速的 32位浮点数替换了64位浮点数。</p>
<p class="content">用加法替代乘法，降低数组元素上的循环强度。很多编译器进行了这一优化。这种方法可以推广为一大类增量算法。</p>
<p class="content">消除公共子表达式。如果两次对同一个表达式求值时，其所有变量都没有任何改动，那么我们可以用下面的方法避免第二次求值：存储第一次的计算结果并用其取代第二次求值。</p>
<p class="content">现代编译器都能消除不包含函数调用的公共子表达式。</p>
<p class="content">成对计算。如果经常需要对两个类似的表达式一起求值，那么就应该建立一个新的过程，将它们成对求值。</p>
<p class="content">13.1 节中，我们的第一个伪代码总是同时使用成员函数和 insert 函数。如果insert函数的参数已经在集合中，C++代码就使用不完成任何操作的insert替代这两个函数。</p>
<p class="content">利用计算机字的并行性。用底层计算机体系结构的全部数据路径宽度来对高开销的表达式求值。</p>
<p class="content">习题13.8说明通过操作char或int等类型可以使位向量能够一次操作很多位。</p>
<p class="content">答案9.7并行统计位数。</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0014.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0016.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
