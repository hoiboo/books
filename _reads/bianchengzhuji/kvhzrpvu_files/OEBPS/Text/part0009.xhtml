<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  
    <title>第三部分 应用</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../../page_styles.css"/>

  

  <link href="../../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />
</head>
<body>


<div class="calibreMain">
  <div class="calibreEbookContent">
    
<h1 class="firsttitle">
<a href="part0000.xhtml#toc95">第三部分 应用</a>
</h1>
<p class="content">下面开始介绍有趣的内容。第一部分和第二部分是打基础的，接下来的5章利用前面的知识来编写有趣的程序。这些问题本身就很重要，而且它们也集中体现了在实际应用中如何结合运用前面各章的方法。</p>
<p class="content">第11章描述几种通用的排序算法。第12章描述一个来自实际应用（生成随机整数样本）的特定问题，并给出了该问题的多种解决方案。方案之一是将其视为一个集合表示问题，这是第13章讨论的内容。第14章介绍堆数据结构，并说明如何用堆得到高效的排序和优先级队列算法。第15章讨论与在很长的文本字符串中搜索单词或短语有关的几个问题。</p>
<p class="content_1">本部分内容</p>
<p class="content_">第11章 排序</p>
<p class="content_">第12章 取样问题</p>
<p class="content_">第13章 搜索</p>
<p class="content_">第14章 堆</p>
<p class="content_">第15章 字符串</p>
<h2 class="secondtitle" id="bw86">
<a href="part0000.xhtml#toc96">第11章 排序</a>
</h2>
<p class="content">如何将一系列的记录排成有序的？答案通常很简单：使用库排序函数。答案1.1使用了这种方法，2.8节的变位词程序也两次使用了这种方法。不幸的是，这种方法并非总是有效的：已有的排序方法使用起来可能比较麻烦，或者速度太慢以至于无法解决特定问题（如1.1节所示）。在这样的情况下，程序员别无选择，只能自己编写排序函数。</p>
<h3 class="thirdtitle" id="bw87">
<a href="part0000.xhtml#toc97">11.1 插入排序</a>
</h3>
<p class="content">大多数纸牌游戏玩家都采用插入排序来排列他们手中的纸牌。他们保持已发到手中的牌有序，当拿到一张新牌时，将其插入到合适的位置。为了将数组x[n]按升序排列，我们首先将第一个元素视为有序子数组x[0..0]，然后插入x[1],…,x[n-1]，如下面的伪代码所示：</p>
<p class="content">for i = [1,n)</p>
<p class="content_5">/* invariant: x[0..i-1] is sorted */</p>
<p class="content_5">/* goal: sift x[i] down to its</p>
<p class="content_7">proper place in x[0..i] */</p>
<p class="content">下面4行展示了该算法在一个四元数组上的执行过程。“|”代表变量i，它左边的元素是有序的，而它右边的元素则还是初始顺序。</p>
<p class="content">3|1 4 2</p>
<p class="content">1 3|4 2</p>
<p class="content">1 3 4|2</p>
<p class="content">1 2 3 4|</p>
<p class="content">筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（即j &gt;0）且没有到达最终位置（即该元素小于它的前驱），循环就交换该元素和它的前驱。完整的程序isort1如下所示：</p>
<p class="content">for i = [1,n)</p>
<p class="content_5">for (j = i; j &gt; 0 &amp;&amp; x[j-1] &gt; x[j]; j--)</p>
<p class="content_7">swap(j-1,j)</p>
<p class="content">当偶尔需要自己写排序代码时，这是我们考虑的第一个函数，只有简单的3行代码。</p>
<p class="content">想要调优代码的程序员可能会觉得，内循环的swap函数调用看起来非常不舒服。我们可以通过把该函数的函数体内联写入内循环来实现加速，当然许多优化编译器会帮我们完成这一工作。我们将swap函数替换为下面的代码，其中变量t用来交换x[j]和x[j-1]。</p>
<p class="content">t = x[j];　　x[j] = x[j-1];　　x[j-1] = t</p>
<p class="content">在我的机器上，isort2的运行时间仅是isort1的三分之一。</p>
<p class="content">这一改动又为进一步的加速提供了思路。由于内循环中总是给变量t赋同样的值（x[i]的初始值），所以我们可以将上面两个含t的赋值语句移出内循环，并相应地修改比较语句，从而得到isort3：</p>
<p class="content">for i = [1,n)</p>
<p class="content_5">t = x[i]</p>
<p class="content_5">for (j = i; j &gt; 0 &amp;&amp; x[j-1] &gt; t; j--)</p>
<p class="content_7">x[j] = x[j-1]</p>
<p class="content_5">x[j] = t</p>
<p class="content">只要t小于已排序部分的元素值，我们的代码就将该元素右移一个位置，最终将t移到它的正确位置。这个5行的函数比前面那个函数要复杂一些，但是在我的系统上它要比isort2函数快15%。</p>
<p class="content">在随机数据的最坏情况下，插入排序的运行时间和n<span class="super">2</span>
 成正比。下表给出了当输入为n个随机整数时上面3个程序的运行时间。</p>
<div class="pic_"><img alt="" src="../Images/image00219.jpeg" class="calibre3"/>
</div>
<p class="content">第3个程序排序n=1 000个整数需要几毫秒，排序n=10 000个整数需要三分之一秒，而排序100万个整数则几乎要一个小时。我们很快会看到能在1秒之内排序100万个整数的代码。如果输入数组几乎是有序的，那么插入排序的速度会快很多，因为每个元素移动的距离都很短。11.3节的一个算法利用了这个性质。</p>
<h3 class="thirdtitle" id="bw88">
<a href="part0000.xhtml#toc98">11.2 一种简单的快速排序</a>
</h3>
<p class="content">C.A.R.Hoare<span id="ref41">
<a href="part0009.xhtml#annot41">[1]</a>
</span>
 在其发表于Computer Journal 5第1期（1962年4月，第10页～第15页）的经典论文“Quicksort”（快速排序）中描述了这一算法。该算法用到了8.3节的分治算法：排序数组时，将数组分成两个小部分，然后对它们递归排序。例如，为了对如下的八元数组排序：</p>
<div class="bodypic_"><img alt="" src="../Images/image00220.jpeg" class="calibre3"/>
</div>
<p class="content">我们围绕第一个元素（55）进行划分：所有小于 55 的元素都移到其左边，所有大于55的元素都移到其右边：</p>
<div class="bodypic_"><img alt="" src="../Images/image00221.jpeg" class="calibre3"/>
</div>
<p class="content">如果接着对下标为0～2的子数组和下标为4～7的子数组分别进行递归排序，那么整个数组就排好序了。</p>
<p class="content">该算法的平均运行时间远远小于插入排序的 O(n<span class="super">2</span>
 )时间，因为划分操作对排序大有裨益：通常对n个元素进行划分之后，大约有一半元素的值大于划分值，一半元素的值小于划分值；而在相近的运行时间内，插入排序的筛选操作只能使一个元素移动到正确的位置。</p>
<p class="content">现在我们对递归函数有了大概的了解。下面分别用下标l和u表示数组待排序部分的下界和上界，递归结束的条件是待排序部分的元素个数小于2。代码如下：</p>
<p class="content">void qsort(l,u)</p>
<p class="content_5">if l &gt;= u then</p>
<p class="content_7">/* at most one element,do nothing */</p>
<p class="content_7">return</p>
<p class="content_5">/* goal:partition array around a particular value,</p>
<p class="content_5">which is eventually placed in its correct position p*/</p>
<p class="content">qsort(l,p-1)</p>
<p class="content">qsort(p+1,u)</p>
<p class="content">为了围绕值t对数组进行划分，我们首先从一个简单的方案开始，这是我从Nico Lomuto那里学到的。下一节我们将看到一个更快的程序<span id="ref42">
<a href="part0009.xhtml#annot42">[2]</a>
</span>
 ，但本节提供的这个函数很容易理解，所以基本上不会出错，而且速度也绝对不慢。给定了值t之后，我们需要重新组织x[a..b]，并计算下标m（“中间元素”的下标），使得所有小于t的元素在m的一端，所有大于t的元素在m的另一端。下面通过一个从左到右扫描数组的简单for循环完成这一任务，其中用变量i和m指向数组x中的下列不变式。</p>
<div class="bodypic_"><img alt="" src="../Images/image00222.jpeg" class="calibre3"/>
</div>
<p class="content">代码在检查第i个元素时必须考虑两种情况。如果x[i]≥t，那么一切正常，不变式仍然为真；如果x[i]&lt;t，可以通过使m增加1（指向小元素的新位置）重新获得不变式，然后交换x[i]和x[m]。完整的划分代码如下：</p>
<p class="content">m = a-1</p>
<p class="content">for i = [a,b]</p>
<p class="content_5">if x[i] &lt; t</p>
<p class="content_7">swap(++m,i)</p>
<p class="content">下面我们围绕值t = x[l]划分数组x[l..u]，从而a为l+1，b为u。因此，划分循环的不变式如下所示：</p>
<div class="bodypic_"><img alt="" src="../Images/image00223.jpeg" class="calibre3"/>
</div>
<p class="content">循环终止时我们有：</p>
<div class="bodypic_"><img alt="" src="../Images/image00224.jpeg" class="calibre3"/>
</div>
<p class="content">然后交换x[l]和x[m]得到：<span id="ref43">
<a href="part0009.xhtml#annot43">[3]</a>
</span>
</p>
<div class="bodypic_"><img alt="" src="../Images/image00225.jpeg" class="calibre3"/>
</div>
<p class="content">现在就可以使用参数(l,m-1)和(m+1,u)分两次递归调用该函数了。</p>
<p class="content">最终我们得到了第一个完整的快速排序代码qsort1，可以通过调用qsort1(0,n-1)来排序数组x[n]。</p>
<p class="content">void qsort1(l,u)</p>
<p class="content_5">if (l &gt;= u)</p>
<p class="content_7">return</p>
<p class="content_5">m = l</p>
<p class="content_5">for i = [l+1,u]</p>
<p class="content_7">/* invariant: x[l+1..m] &lt; x[l] &amp;&amp;</p>
<p class="content_8">x[m+1..i-1] &gt;= x[l] */</p>
<p class="content_7">if (x[i] &lt; x[l])</p>
<p class="content_5">swap(++m,i)</p>
<p class="content_5">swap(l,m)</p>
<p class="content_5">/* x[l..m-1] &lt; x[m] &lt;= x[m+1..u] */</p>
<p class="content_5">qsort1(l,m-1)</p>
<p class="content_5">qsort1(m+1,u)</p>
<p class="content">习题 2 描述了 Bob Sedgewick 对该划分代码的修改，修改后可以得到稍微快一点的qsort2。</p>
<p class="content">有关该程序正确性证明的大部分内容都已经在上面的推导过程中给出了，具体的证明过程可以通过归纳进行：外层的if语句正确地处理了空数组和1元数组，而划分代码可以正确地把对大数组的处理分成两个小的递归调用。该程序不会导致无限递归调用，因为每次调用都排除了元素x[m]，这和4.3节证明二分搜索会终止道理一样。</p>
<p class="content">当输入数组是不同元素的随机排列时，该快速排序平均需要O(n log n)的时间和O(logn)的栈空间，其数学原理和8.3节类似。大多数算法教材都分析了快速排序的运行时间，并证明了任何基于比较的排序至少需要O(n log n)次比较，因此快速排序接近最优算法。</p>
<p class="content">qsortl 函数是我所知道的最简单的快速排序，它展现了该算法的很多重要属性。首要的一点是，它确实非常快：在我的系统上，该函数只需要一秒多一点的时间就能够对100万个随机整数排序，大约比调优过的C库函数qsort快1倍。（qsort函数的通用接口开销很大。）qsortl函数可能适合于一些表现良好的应用程序，但是它具有很多快速排序算法都具有的另一个性质：在一些常见输入下，它可能退化为平方时间的算法。下一节研究几种更健壮的快速排序算法。</p>
<h3 class="thirdtitle" id="bw89">
<a href="part0000.xhtml#toc99">11.3 更好的几种快速排序</a>
</h3>
<p class="content">qsort1函数能够快速完成对随机整数数组的排序，但是在非随机的输入上它的性能如何呢？如2.4节所示，程序员经常通过排序来获取相等的元素，因此我们需要考虑一种极端的情况：n 个相同元素组成的数组。对于这种输入，插入排序的性能非常好：每个元素需要移动的距离都为0，所以总的运行时间为O(n)；但qsort1函数的性能却非常糟糕。n-1次划分中每次划分都需要O(n)时间来去掉一个元素，所以总的运行时间为O(n<span class="super">2</span>
 )。当n=1 000 000时，运行时间从一秒一下子变成了两个小时。</p>
<p class="content">使用双向划分可以避免这个问题，循环不变式如下：下标 i 和 j 初始化为待划分数组的两端。主循环中有两个内循环，第一个内循环将 i向右移过小元素，遇到大元素时停止；第二个内循环将j向左移过大元素，遇到小元素时停止。然后主循环测试这两个下标是否交叉并交换它们的值。</p>
<div class="bodypic_"><img alt="" src="../Images/image00226.jpeg" class="calibre3"/>
</div>
<p class="content">但是当元素相同时代码如何处理呢？我们首先想到的就是向右扫描元素以避免做多余的工作，但是当所有的输入都相同时，这样做会得到平方时间的算法。我们的做法是，当遇到相同的元素时停止扫描，并交换i和j的值。这样做虽然使交换的次数增加了，但却将所有元素都相同的最坏情况变成了差不多需要nlog2n次比较的最好情况。下面的代码实现了这一划分；</p>
<p class="content">void qsort3(l,u)</p>
<p class="content">if l &gt;= u</p>
<p class="content_5">return</p>
<p class="content">t = x[l]; i = l; j = u+1</p>
<p class="content">loop</p>
<p class="content_5">do i++ while i &lt;= u &amp;&amp; x[i] &lt; t</p>
<p class="content_5">do j-- while x[j] &gt; t</p>
<p class="content_5">if i &gt; j</p>
<p class="content_7">break</p>
<p class="content_5">swap(i,j)</p>
<p class="content">swap(l,j)</p>
<p class="content">qsort3(l,j-1)</p>
<p class="content">qsort3(j+1,u)</p>
<p class="content">除了能够处理所有元素都相同的情况外，上述代码的平均交换次数也比qsort1少。</p>
<p class="content">到目前为止我们看到的快速排序都是围绕数组的第一个元素进行划分的。对于随机输入，这样做没问题；但对于某些常见输出，这种做法需要的时间和空间都偏多。例如，如果数组已经按升序排好了，那么它就会先围绕最小的元素进行划分，然后是第 2 小的元素，依此类推，总共需要 O(n<span class="super">2</span>
 )的时间。随机选择划分元素就可以得到好得多的性能，我们通过把x[l]与x[l..u]中的一个随机项相交换来实现这一点：</p>
<p class="content">swap(l,randint(l,u));</p>
<p class="content">如果手头没有现成的randint函数，可以用习题12.1的方法自己编写一个。但是不论使用什么样的代码，都要注意 randint 返回的值在范围[l,u]内——超出这个范围是不对的。结合随机划分元素和双向划分代码后，对于任意的n元输入数组，快速排序的期望运行时间都正比于n log n。随机情况下的性能边界是通过调用随机数生成器得到的，而不是通过对输入的分布进行假设得到的。</p>
<p class="content">我们的快速排序程序花费了大量的时间来排序很小的子数组。如果用插入排序之类的简单方法来排序这些很小的子数组，程序的速度会更快。Bob Sedgewick开发了一个特别聪明的代码来实现这一思想。当在小的子数组上调用快速排序时（l 和 u 非常接近），不执行任何操作。我们将qsort3中的第一个if语句改为</p>
<p class="content">if u-l &lt; cutoff</p>
<p class="content_5">return</p>
<p class="content">其中cutoff是一个小整数。程序结束时，数组并不是有序的，而是被组合成一块一块随机排列的值，并且满足这样的条件：某一块中的元素小于它右边任何块中的元素。我们必须通过另一种排序算法对块的内部进行排序。由于数组是几乎有序的，因此插入排序比较适用。我们通过下面的代码排序整个数组：</p>
<p class="content">qsort4(0,n-1)</p>
<p class="content">isort3()</p>
<p class="content">习题3讨论了cutoff的最佳取值。</p>
<p class="content">代码调优的最后一步是展开循环体内swap函数的代码（另外两个对swap的调用不在循环体内，将它们改写为内联代码对速度的影响微乎其微）。下面是快速排序的最终代码qsort4：</p>
<p class="content">void qsort4(l,u)</p>
<p class="content_5">if u – l &lt; cutoff</p>
<p class="content_7">return</p>
<p class="content_5">swap(l,randint(l,u))</p>
<p class="content_5">t = x[l]; i = l; j = u+1</p>
<p class="content_5">loop</p>
<p class="content_7">do i++; while i &lt;= u &amp;&amp; x[i] &lt; t</p>
<p class="content_7">do j--; while x[j] &gt; t</p>
<p class="content_7">if i &gt; j</p>
<p class="content_8">break</p>
<p class="content_5">temp = x[i]; x[i] = x[j]; x[j] = temp swap(l,j)</p>
<p class="content_5">qsort4(l,j-1)</p>
<p class="content_5">qsort4(j+1,u)</p>
<p class="content">习题4和习题11提到了进一步提升快速排序性能的方法。</p>
<p class="content">下表对快速排序的各个版本进行了总结。最右边一列给出了排序n个随机整数所需的平均运行时间，以纳秒为单位。在某些输入条件下，表中许多函数都会退化为平方时间的算法。</p>
<div class="pic_"><img alt="" src="../Images/image00227.jpeg" class="calibre3"/>
</div>
<p class="content">qsort4函数使用15行C代码和isort3的5行代码。对于100万个随机整数，表中程序的运行时间在0.6秒（C++标准库函数sort）到2.7秒（C标准库函数qsort）之间。第14章我们将看到一种即使在最坏情况下也能够确保O(n log n)时间性能的排序算法。</p>
<h3 class="thirdtitle" id="bw90">
<a href="part0000.xhtml#toc100">11.4 原理</a>
</h3>
<p class="content">本章介绍了一些重要的经验，既适用于排序这个具体问题，也适用于一般意义上的编程。</p>
<p class="content">C 标准库函数 qsort 非常简单并且相对比较快，它比我们自己写的快速排序慢，仅仅是因为其通用而灵活的接口对每次比较都使用函数调用。C++标准库函数sort具有最简单的接口：我们通过调用sort(x,x+n)对数组x排序，其实现也非常高效。如果系统中的排序能够满足我们的需求，那么就不用考虑自己编写代码了。</p>
<p class="content">插入排序的代码很容易编写，并且对于小型的排序任务速度很快。在我的系统上用isort3排序10 000个整数仅需要三分之一秒。</p>
<p class="content">如果n很大，快速排序的O(n log n)运行时间就非常关键了。第8章的算法设计方法为我们提供了分治算法的基本思想，第4章的程序验证技术使得我们能够用简洁而高效的代码实现这一思想。</p>
<p class="content">尽管更改算法能够大大提高程序的速度，但第9章介绍的代码调优技术可以进一步使插入排序的速度提高3倍，快速排序的速度提高1倍。</p>
<h3 class="thirdtitle" id="bw91">
<a href="part0000.xhtml#toc101">11.5 习题</a>
</h3>
<p class="content">1.就像其他任何强大的工具一样，我们经常会在不该使用排序的时候使用排序，而在应该使用排序的时候却不使用排序。请解释在计算 n 元浮点数组的最小值、最大值、均值、中值、众数等统计量时，哪些情况会导致过度使用排序，哪些情况会导致不能充分利用排序。</p>
<p class="content">2.[R.Sedgewick]把x[l]用作哨兵以加速Lomuto的划分方案。说明如何利用该方法来移除循环后面的swap。</p>
<p class="content">3.在特定的系统上如何求出最佳的cutoff值?</p>
<p class="content">4.虽然快速排序平均只需要O(log n)的栈空间，但是在最坏情况下需要线性空间，请解释原因。修改程序，使得最坏情况下仅使用对数空间。</p>
<p class="content">5.[M.D.McIlroy]说明如何用Lomuto的划分方案来排序可变长的位字符串，要求排序时间与位字符串的长度之和成正比。</p>
<p class="content">6.使用本章的方法实现其他排序算法。选择排序首先将最小的值放在 x[0]中，然后将剩下的最小值放在x[1]中，依此类推。希尔排序（或“递减增量排序”）类似于插入排序，但它将元素向后移动h个位置而不是1个位置。h的值开始很大，然后慢慢减小。</p>
<p class="content">7.本章排序程序的实现在本书网站上可以下载。统计在你的系统上运行各个排序函数所需的时间，然后将统计值制成类似于11.3节的表。</p>
<p class="content">8.起草一份一页纸的指南，告诉用户如何在你的系统中选择排序算法。确保你的方法考虑到了运行时间、空间、程序员时间（开发和维护所需的时间）、通用性（如果我想排序代表罗马数字的字符串会怎样？）、稳定性（具有相同关键字的项在排序前后的相对顺序不变）及输入数据的特殊性质等。用第 1 章描述的排序问题对你的方法进行极端测试。</p>
<p class="content">9.编写程序，在O(n)时间内从数组x[0..n-1]中找出第k个最小的元素。算法可以对x中的元素进行排序。</p>
<p class="content">10.收集并显示有关快速排序程序运行时间的经验数据。</p>
<p class="content">11.编写一个“宽支点”划分函数，使得结果如下图所示：</p>
<div class="pic_"><img alt="" src="../Images/image00228.jpeg" class="calibre3"/>
</div>
<p class="content">如何将这个函数应用到快速排序中？</p>
<p class="content">12.研究非计算机应用（如邮件收发室和零钱分类器）中的排序方法。</p>
<p class="content">13.本章介绍的快速排序程序随机选择一个划分元素。研究更好的选择，如数组样本的中间值。</p>
<p class="content">14.本章的快速排序使用两个整数下标表示子数组。在Java等语言中必须这样做，因为它们没有指向数组的指针。在C或C++中，可以为初始调用和所有的递归调用使用类似下面的函数来排序整数数组：</p>
<p class="content">void qsort(int x[],int n)</p>
<p class="content">修改本章中的算法，使它们都使用这一接口。</p>
<h3 class="thirdtitle" id="bw92">
<a href="part0000.xhtml#toc102">11.6 深入阅读</a>
</h3>
<p class="content">Don Knuth的The Art of Computer Programming,Volume 3：Sorting and Searching自从1973年由Addison-Wesley出版社出版第1版以来，一直是该领域的权威参考书。他详细介绍了所有的重要算法，从数学上分析了它们的运行时间，并用汇编代码加以实现。该书的练习题和参考书目描述了基本算法的许多重要变体。1998年Knuth把该书更新并修订为第2 版，他所用的 MIX 汇编语言有些过时了，但是代码所体现的基本原理是永恒的。</p>
<p class="content">Robert Sedgewick在他的名著Algorithms第3版中对排序和搜索给出了更加现代化的描述。该书的第一部分至第四部分分别介绍基本原理、数据结构、排序和搜索。Algorithms in C由Addison-Wesley出版社1997年出版，Algorithms in C++（C++顾问为Chris Van Wyk）于1998年出版，Algorithms in Java（Java顾问为Tim Lindholm）于1999年出版。他着重强调算法的实现（使用你自己选择的语言），并从直观上解释了算法的性能。</p>
<p class="content">这几本书是本书中排序（本章）、搜索（第13章）和堆（第14章）的主要参考书。</p>
<h2 class="secondtitle" id="bw93">
<a href="part0000.xhtml#toc103">第12章 取样问题</a>
</h2>
<p class="content">小的计算机程序往往能够寓教于乐。本章讲述了一个小程序的故事，这个程序不仅用来教学和娱乐，还可用于商业。</p>
<h3 class="thirdtitle" id="bw94">
<a href="part0000.xhtml#toc104">12.1 问题</a>
</h3>
<p class="content">20世纪80年代初，一家公司购买了他们的第一批个人电脑。帮他们安装好主要的系统使其能够运行之后，我建议他们留意一下办公室里面哪些工作可以用程序来完成。该公司的业务主要是民意调查，一个机敏的雇员建议让计算机自动完成从打印出的选区列表中进行随机取样的任务。由于手工做这件事非常枯燥，处理一张随机表需要一个小时，她建议开发如下的程序：</p>
<p class="content">程序的输入是选区名列表以及整数m，输出是随机选择的m个选区名的列表。通常选区名有几百个（每个选区名都是一个不超过12字符的字符串）， m通常在20～40。</p>
<p class="content">这是用户对程序的想法，在开始编码之前你对问题的定义有什么建议吗？</p>
<p class="content">我的第一反应是：这是一个好主意，这个任务比较适合自动化。接着我指出，输入几百个名字虽然可能比处理一长列一长列的随机数容易一些，但仍然很枯燥且容易出错。一般来说，如果程序会忽略输入中的大部分内容，那么准备很多的输入是不明智的。因此我建议实现下面的程序：</p>
<p class="content">程序的输入包含两个整数m和n，其中m&lt;n。输出是0～n-1范围<span id="ref44">
<a href="part0009.xhtml#annot44">[4]</a>
</span>
 内m个随机整数的有序列表，不允许重复。从概率的角度说，我们希望得到没有重复的有序选择，其中每个选择出现的概率相等。</p>
<p class="content">当m=20，n=200时，程序可能产生4、15、17开始的20元序列，然后用户在200个选区的列表中标记出第4、15、17个选区名，等等，从而完成对20个样本的取样。（要求输出是有序的，因为硬拷贝的列表上没有编号。）</p>
<p class="content">这一规范说明得到了潜在用户的认可。程序实现之后，原先一小时的任务现在只要几分钟就能完成。</p>
<p class="content">下面从另一个角度考虑这个问题：如何实现这个程序？假设你有一个能返回很大的随机整数（远远大于m和n）的函数bigrand()，以及一个能返回i..j范围内均匀选择的随机整数的函数randint(i,j)。习题1讨论了这类函数的实现。</p>
<h3 class="thirdtitle" id="bw95">
<a href="part0000.xhtml#toc105">12.2 一种解决方案</a>
</h3>
<p class="content">确定了需要解决的问题后，我马上找出Knuth的The Art of Computer Programming,Volume2：Seminumerical Algoriths<span id="ref45">
<a href="part0009.xhtml#annot45">[5]</a>
</span>
 （在家里和办公室都放上Knuth的三卷本是很值得的）。10 年前我就认真研读过这本书，隐约记得书中有几个算法能解决类似的问题。花几分钟考虑了几种可能的设计（稍后将看到）之后，我认为该书 3.4.2 节的算法 S是理想的解决方案。</p>
<p class="content">该算法依次考虑整数0,1,2,…,n-1，并通过一个适当的随机测试对每个整数进行选择。通过按序访问整数，我们可以保证输出结果是有序的。</p>
<p class="content">为了理解选择的标准，我们考虑m=2，n=5的情况。选择第一个整数0的概率为2/5，可以通过下面的语句来实现：</p>
<p class="content">if (bigrand() % 5) &lt; 2</p>
<p class="content">不幸的是，我们不能用同样的概率来选择整数1：这样做的话我们从5个整数中选出的整数可能是两个也可能不是两个。因此决策有一些不同：在已经选择0的情况下以1/4的概率选择1，而在未选择0的情况下以2/4的概率选择1。一般来说，如果要从r个剩余的整数中选出s个，我们以概率s/r选择下一个数，伪代码如下：</p>
<p class="content">select = m</p>
<p class="content">remaining = n</p>
<p class="content">for i = [0,n）</p>
<p class="content_4">if (bigrand() % remaining) &lt; select print i</p>
<p class="content_5">select--</p>
<p class="content_4">remaining--</p>
<p class="content">只要 m≤n，程序选出的整数就恰为 m个：不会选择更多的整数，因为 select 变为 0时就不能再选择整数了；也不会选择更少的整数，因为当select/remaining为1时一定会选中一个整数。for语句确保按序输出所有的整数。上面的描述可以帮助我们理解，每个子集被选中的可能性是相等的，Knuth给出了概率上的证明。</p>
<p class="content">有了Knuth的第2卷，这个程序就很容易写了。即使包含标题、输入、输出和越界检查等内容，最终的程序也只需要13行BASIC代码。问题定义清楚后，程序只需要半个小时就能写完，而且使用多年也没有问题。下面给出C++实现：</p>
<p class="content">void genknuth(int m,int n)</p>
<p class="content">{ for (int i = 0; i &lt; n; i++)</p>
<p class="content_4">/* select m of remaining n-i */</p>
<p class="content_4">if ((bigrand() % (n-i)) &lt; m) {</p>
<p class="content_5">cout &lt;&lt; i &lt;&lt; "\n";</p>
<p class="content_5">m--;</p>
<p class="content_4">}</p>
<p class="content">}</p>
<p class="content">程序只需要几十个字节的内存，并能快速解决该公司的问题。不过，当n很大时代码会比较慢。例如，在我的机器上使用该算法生成一些32位的随机正整数（n=2<span class="super">32</span>
 ）需要12分钟。粗略估算：使用该代码生成1个48位或64位的整数需要多长时间？</p>
<h3 class="thirdtitle" id="bw96">
<a href="part0000.xhtml#toc106">12.3 设计空间</a>
</h3>
<p class="content">解决现有的问题是程序员任务的一部分，另一个也许更重要的部分是做好解决未来问题的准备。有时，这种准备包括听课或者读书（如 Knuth 的书）；不过更常见的情况是，程序员通过询问自己如何用不同的方法解决问题来得到提高。下面我们就来探讨一下取样问题的其他可行解决方案。</p>
<p class="content">我在西点军校谈到这个问题的时候，要求他们给出一个比原始问题陈述（输入200个选区名）更好的方法。一个学生建议复印选区列表，用切纸机将副本切成一个个含有选区名的纸片，然后将这些纸片放入一个纸袋中并摇乱，再从中抽取需要数目的纸片。这个学生的方法体现了1.7节引用的James L.Adams著作<span id="ref46">
<a href="part0009.xhtml#annot46">[6]</a>
</span>
 的主题“打破概念壁垒”。</p>
<p class="content">从现在开始，我们把目标限定为：编写程序从0～n-1中随机输出m个有序整数。首先评价一下前面的算法。该算法思想很简单，代码很短，所需的空间很少，运行时间对这个应用来说也是合适的。不过，算法的运行时间跟n成正比，对有些应用来说是不能接受的，因此花几分钟研究一下其他的解决方案还是值得的。在阅读下面的内容之前，尽可能地多思考几种高层设计，不必考虑实现细节。</p>
<p class="content">一种解决方案是在一个初始为空的集合里面插入随机整数，直到个数足够。伪代码如下：</p>
<p class="content">initialize set S to empty</p>
<p class="content">size = 0</p>
<p class="content">while size &lt; m do</p>
<p class="content_4">t = bigrand() % n</p>
<p class="content_4">if t is not in S</p>
<p class="content_5">insert t into S</p>
<p class="content_5">size++</p>
<p class="content">print the elements of S in sorted order</p>
<p class="content">算法对每个元素的决策都一样，输出是随机的。接下来的问题是如何实现集合S，我们需要考虑一种适当的数据结构。</p>
<p class="content">如果在过去，我们应该会考虑有序链表、二分搜索树和其他所有可能的常见数据结构；但是现在，我可以利用C++标准模板库，用set表示集合：</p>
<p class="content">void gensets(int m,int n)</p>
<p class="content">{ set&lt;int&gt; S;</p>
<p class="content_4">while (S.size() &lt; m)</p>
<p class="content_5">S.insert(bigrand() % n);</p>
<p class="content_4">set&lt;int&gt;::iterator i;</p>
<p class="content_4">for (i = S.begin(); i != S.end(); ++i)</p>
<p class="content_5">cout &lt;&lt; *i &lt;&lt; "\n";</p>
<p class="content">}</p>
<p class="content">我很高兴地看到，实际的代码跟伪代码一样长。这个程序在我的机器上生成并输出100万个有序且无重复的随机整数大约需要20秒。由于仅生成并输出100万个无序的整数（不考虑重复）就需要约12.5秒，因此集合运算只消耗了约7.5秒。</p>
<p class="content">C++标准模板库规范每次插入操作都在O(log m)时间内完成，而遍历集合则需要O(m)时间，因此完整的程序需要O(m log m)时间（当m相对于n比较小时）。但是，该数据结构的空间开销比较大：我机器的128 MB内存大约在m=1 700 000<span id="ref47">
<a href="part0009.xhtml#annot47">[7]</a>
</span>
 时就不够用了。下一章考虑该集合的几种可能的实现。</p>
<p class="content">生成随机整数的有序子集的另一种方法是把包含整数 0～n-1 的数组顺序打乱，然后把前m个元素排序输出。Knuth书中3.4.2节的算法P就是这样做的：</p>
<p class="content">for i = [0,n)</p>
<p class="content_4">swap(i,randint(i,n-1))</p>
<p class="content">Ashley Shepherd和Alex Woronow发现，在这个问题中我们只需要打乱数组的前m个元素，对应的C++代码如下：</p>
<p class="content">void genshuf(int m,int n)</p>
<p class="content">{ int i,j;</p>
<p class="content_4">int *x = new int[n];</p>
<p class="content_4">for (i = 0; i &lt; n; i++)</p>
<p class="content_5">x[i] = i;</p>
<p class="content_4">for (i = 0; i &lt; m; i++) {</p>
<p class="content_5">j = randint(i,n-1);</p>
<p class="content_5">int t = x[i]; x[i] = x[j]; x[j] = t;</p>
<p class="content_4">}</p>
<p class="content_4">sort(x,x+m);</p>
<p class="content_4">for (i = 0; i &lt; m; i++)</p>
<p class="content_5">cout &lt;&lt; x[i] &lt;&lt; "\n";</p>
<p class="content">}</p>
<p class="content">算法需要n个元素的内存空间和O(n+m log m)的时间，如果使用习题1.9的方法，则可以把时间降低到O(m log m)。我们可以把这个算法看作前一个程序的变体：x[0..i-1]表示已选中元素的集合，x[i..n-1]表示未选中元素的集合。通过显式地表示未选中的元素，我们就避免了对新元素是否已经选中的测试。不幸的是，由于这一方法需要O(n)的时间和空间，其性能通常不如Knuth的算法。</p>
<p class="content">到目前为止，我们已经看到了几种不同的解决方案，但这些绝没有能够覆盖所有的解决方案。例如，当n为100万而m为n-10时，我们可能需要生成一个包含10个元素的有序随机样本，然后输出不在样本中的整数。再如，当m为1 000万而n为2<span class="super">31</span>
 时，我们可能会先生成1 100万个整数，然后排序并对其扫描以删除重复的元素，最后得到一个有1 000万元素的有序样本。答案9给出了一种特别聪明的基于搜索的算法，该算法由Robert Floyd<span id="ref48">
<a href="part0009.xhtml#annot48">[8]</a>
</span>
 提出。</p>
<h3 class="thirdtitle" id="bw97">
<a href="part0000.xhtml#toc107">12.4 原理</a>
</h3>
<p class="content">本章示例了编程过程中的几个重要步骤。尽管下面的讨论是按一种比较自然的顺序对各个阶段进行介绍的，实际的设计过程应该更加能动一些：可以从一个阶段跳到另一个阶段，在得到一个可以接受的解决方案之前，通常需要对每个步骤迭代好多次。</p>
<p class="content">正确理解所遇到的问题。与用户讨论问题产生的背景。问题的陈述通常就包含了与解决方案有关的想法；跟早期的想法一样，这些想法也都应当加以考虑，但不应排除其他想法。</p>
<p class="content">提炼出抽象问题。简洁、明确的问题陈述不仅可以帮助我们解决当前遇到的问题，还有助于我们把解决方案应用到其他问题中。</p>
<p class="content">考虑尽可能多的解法。很多程序员很快就发现了问题的“解决方案”，他们只愿意花1分钟的时间思考，然后花一天的时间来写代码，而不是先花1个小时来思考，再用一个小时来写代码。非正式的高级语言可以帮助我们描述设计方案：伪代码表示控制流，抽象数据类型表示关键的数据结构。对文献的熟悉程度在这一阶段非常重要。</p>
<p class="content">实现一种解决方案。如果运气很好的话，在前一阶段我们就能发现某种解决方案显著优于其他方案；否则我们就得列出几种性能比较好的方案，然后从中选择最佳的。我们应该用简单的代码和最有效的操作来实现最终选择的解决方案。<span id="ref49">
<a href="part0009.xhtml#annot49">[9]</a>
</span>
</p>
<p class="content">回顾。Polya的How to Solve It一书能帮助任何程序员更好地解决问题。在第15页他指出：“改进的余地总是存在的。经过充分的研究和思考，任何解决方案都可能被改进；任何情况下，对于解决方案的理解一定能被改进。”他的提示对编程问题的回顾尤其有用。</p>
<h3 class="thirdtitle" id="bw98">
<a href="part0000.xhtml#toc108">12.5 习题</a>
</h3>
<p class="content">1.C 库函数 rand()通常返回约 15 个随机位。使用该函数实现函数 bigrand()和randint(l,u)，要求前者至少返回30个随机位，后者返回[l,u]范围内的一个随机整数。</p>
<p class="content">2.12.1节要求所有的m元子集被选中的概率相等，这个条件比按等概率m/n选择每个整数更强。给出这样一个算法，其中每个元素的选中概率相等，但某些子集的选中概率比其他子集大一些。</p>
<p class="content">3.证明当 m&lt;n/2 时，基于集合的算法在找到一个不在集合中的数之前，所进行的成员测试的期望次数小于2。</p>
<p class="content">4.在基于集合的程序中对成员测试进行计数会产生组合数学和概率论中的许多有趣问题。程序平均需要进行多少次成员测试（用m和n的函数表示）？当m=n时需要进行多少次测试？什么情况下测试次数可能超过m？</p>
<p class="content">5.本章描述了一个问题的几种算法，在本书网站上可以下载。在你的系统上度量它们的性能，并指出它们各自在什么情况下适用（表示为运行时间、空间等的约束函数）。</p>
<p class="content">6.[课堂练习]我在本科生算法课程中两次让学生生成有序子集。在学习排序和搜索之前，要求学生以m=20和n=400编写程序，主要评分标准是简短、清晰——运行时间不是问题。学习了排序和搜索之后，要求学生再次以m=5 000 000和n=1 000 000 000解决该问题，评分标准主要基于运行时间。</p>
<p class="content">7.[V.A.Vyssotsky]生成组合对象的算法通常用递归函数来表达。Knuth的算法如下所示：</p>
<p class="content">void randselect(m,n)</p>
<p class="content_4">pre 0 &lt;= m &lt;= n</p>
<p class="content_4">post m distinct integers from 0..n-1 are printed in decreasing order</p>
<p class="content_4">if m &gt; 0</p>
<p class="content_5">if (bigrand() % n) &lt; m</p>
<p class="content_4">print n-1</p>
<p class="content_4">randselect(m-1,n-1)</p>
<p class="content">else</p>
<p class="content_4">randselect(m,n-1)</p>
<p class="content">该程序按降序输出随机整数，如何使其按升序输出整数？请论证你的升序程序的正确性。如何使用该程序的基本递归结构生成0～n-1的所有m元子集？</p>
<p class="content">8.如何从0～n-1中随机选择m个整数，使得最终的输出顺序是随机的？如果有序列表中允许有重复整数，如何生成该列表？如果既允许重复，又要求按随机顺序输出，情况又如何？</p>
<p class="content">9.[R.W.Floyd]当m接近于n时，基于集合的算法生成的很多随机数都要丢掉，因为它们之前已经存在于集合中了。能否给出一个算法，使得即使在最坏情况下也只使用m个随机数？</p>
<p class="content">10.如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个？具体来说，如何在事先不知道文本文件行数的情况下读取该文件，从中随机选择并输出一行？</p>
<p class="content">11.[M.I.Shamos]在一种彩票游戏中，每位玩家有一张包含16个覆盖点的纸牌，覆盖点下面隐藏着1～16的随机排列，玩家刮开覆盖点则现出下面的整数。只要整数3出现，则判玩家负；否则，如果1和2都出现（顺序不限），则玩家获胜。随机选择覆盖点的顺序就能够获胜的概率如何计算？请列出详细步骤，假定你最多可以使用一个小时的CPU时间。</p>
<p class="content">12.我为本章中某个程序编写的最初版本有一个严重的问题：m=0 时程序会死掉；m 取其他值时程序会生成看似随机的输出，但实际上并非如此。如何测试一个生成样本的程序，以确保其输出确实是随机的？</p>
<h3 class="thirdtitle" id="bw99">
<a href="part0000.xhtml#toc109">12.6 深入阅读</a>
</h3>
<p class="content">Don Knuth的The Art of Computer Programming，Volume3：Seminumerical Algor ithms第3版由Addison-Wesley出版社于1998年出版。该书第3章（前半部分）是关于随机数的，第4章（后半部分）是关于算术的。3.4.2节是关于“随机取样并打乱顺序”的，与本章的内容尤其相关。如果想要自己写随机数生成器或执行高级算术运算的函数，那么你就需要阅读这本书。</p>
<h2 class="secondtitle" id="bw100">
<a href="part0000.xhtml#toc110">第13章 搜索</a>
</h2>
<p class="content">搜索问题形形色色。编译器查询变量名以得到其类型和地址，拼写检查器查字典以确保单词拼写正确，电话号码簿程序查询用户名以找到其电话号码，因特网域名服务器查找域名来发现 IP 地址，上述应用以及很多类似的应用都需要搜索一组数据，以找到与特定项相关的信息。</p>
<p class="content">本章详细研究这样一个搜索问题：在没有其他相关数据的情况下，如何存储一组整数？这个问题虽然很小，但却能引发在数据结构实现中出现的许多关键问题。我们从任务的准确定义开始，用该定义来研究最常见的集合表示。</p>
<h3 class="thirdtitle" id="bw101">
<a href="part0000.xhtml#toc111">13.1 接口</a>
</h3>
<p class="content">我们接着讨论上一章的问题：生成[0,maxval]范围内m个随机整数的有序序列，不允许重复。我们的任务是实现如下伪代码：</p>
<p class="content">initialize set S to empty</p>
<p class="content">size = 0</p>
<p class="content">while size &lt; m do</p>
<p class="content_4">t = bigrand() % maxval</p>
<p class="content_4">if t is not in S</p>
<p class="content_5">insert t into S</p>
<p class="content_5">size++</p>
<p class="content">print the elements of S in sorted order</p>
<p class="content">我们将待生成的数据结构称为 IntSet，意指整数集合。下面我们将把该接口定义为具有如下公有成员的C++类：</p>
<p class="content">class IntSetImp {</p>
<p class="content">public:</p>
<p class="content_4">IntSetImp(int maxelements,int maxval);</p>
<p class="content_4">void insert(int t);</p>
<p class="content_4">int size();</p>
<p class="content_4">void report(int *v);</p>
<p class="content">};</p>
<p class="content">构造函数 IntSetImp 将集合初始化为空。该函数有两个参数，分别表示集合元素的最大个数和集合元素的最大值（加1），特定的实现可以忽略其中之一或者两个都忽略。insert 函数向集合中添加一个新的整数（前提是集合中原先没有这个整数），size函数返回当前的元素个数，而report函数（按顺序）将元素写入向量v中。</p>
<p class="content">很明显，这个小接口仅具有教学意义，它缺乏对工业级的类来说很关键的许多构成部分，例如错误处理和析构函数。熟练的C++程序员可能会使用带有虚函数的抽象类来表示这个接口，然后将每个实现都写成派生类。这里我们将采用更简单（有时也更高效）的方法：用IntSetArr作为数组实现的名字，用IntSetList作为链表实现的名字，等等，并用名字IntSetImp表示任意实现。</p>
<p class="content">下面的C++代码使用这样的数据结构来生成一个随机整数的有序集合：</p>
<p class="content">void gensets(int m,int maxval)</p>
<p class="content">{ int *v = new int[m];</p>
<p class="content_4">IntSetImp S(m,maxval);</p>
<p class="content_4">while (S.size() &lt; m)</p>
<p class="content_5">S.insert(bigrand() % maxval);</p>
<p class="content_4">S.report(v);</p>
<p class="content_4">for (int i = 0; i &lt; m; i++)</p>
<p class="content_5">cout &lt;&lt; v[i] &lt;&lt; "\n";</p>
<p class="content">}</p>
<p class="content">由于insert函数不会在集合中放入重复元素，因此我们不需要在插入前测试元素是否在集合中。</p>
<p class="content">IntSet最简单的实现使用了C++标准模板库中强大而通用的set模板：</p>
<p class="content">class IntSetSTL {</p>
<p class="content">private:</p>
<p class="content_4">set&lt;int&gt; S;</p>
<p class="content">public:</p>
<p class="content_4">IntSetSTL(int maxelements,int maxval) { }int size() { return S.size(); }</p>
<p class="content_4">void insert(int t) { S.insert(t);}</p>
<p class="content_4">void report(int *v)</p>
<p class="content_4">{ int j = 0;</p>
<p class="content_5">set&lt;int&gt;::iterator i;</p>
<p class="content_5">for (i = S.begin(); i != S.end(); ++i)</p>
<p class="content_6">v[j++] = *i;</p>
<p class="content_4">}</p>
<p class="content">};</p>
<p class="content">构造函数忽略了它的两个参数。我们的IntSet、size和insert函数都对应着标准模板库中的相应部分，report 函数使用标准的迭代器将集合元素按序写入数组。这个通用结构不错，但还不够完美，下面马上可以看到一种时空效率都高出5倍的对这个特定任务的实现。</p>
<h3 class="thirdtitle" id="bw102">
<a href="part0000.xhtml#toc112">13.2 线性结构</a>
</h3>
<p class="content">我们使用整数数组这一最简单的结构来建立第一个集合实现。我们的类用整数n保存当前的元素个数，用向量x保存整数本身：</p>
<p class="content">private:</p>
<p class="content_4">int n,*x;</p>
<p class="content">（附录E给出了所有类的完整实现。）下面的C++构造函数伪代码为数组分配空间（多分配一个元素的空间给哨兵用）并将n设置为0：</p>
<p class="content">IntSetArray(maxelements,maxval)</p>
<p class="content_4">x = new int[1 + maxelements]</p>
<p class="content_4">n = 0</p>
<p class="content_4">x[0] = maxval</p>
<p class="content">由于report函数要求按序输出，因此我们总是按这种方式存储元素（在其他一些应用中，使用无序数组更合适）。此外，我们将哨兵元素maxval放置在已排序元素的最后（maxval 比集合中的任何元素都大）。这样我们就可以通过寻找一个更大的元素（maxval）来判断是否到达了列表的末尾，从而可以简化插入代码，并使其运行得更快：</p>
<p class="content">void insert(t)</p>
<p class="content_4">for (i = 0; x[i] &lt; t; i++)</p>
<p class="content_5">;</p>
<p class="content">if x[i] == t</p>
<p class="content_4">return</p>
<p class="content">for (j = n; j &gt;= i; j--)</p>
<p class="content_4">x[j+1] = x[j]</p>
<p class="content">x[i] = t</p>
<p class="content">n++</p>
<p class="content">第一个循环扫描小于插入值t的数组元素。如果新元素等于t，则说明它已经在集合中，因此立即返回；否则，将大于t的元素（包括哨兵）都向右移动一位，将t插入到空出来的位置，并使n增1。这需要O(n)时间。</p>
<p class="content">各种实现中的size函数都是一样的：</p>
<p class="content">int size()</p>
<p class="content_4">return n</p>
<p class="content">report函数在O(n)时间内将所有元素（哨兵除外）复制到输出数组中：</p>
<p class="content">void report(v)</p>
<p class="content_4">for i = [0,n]</p>
<p class="content_5">v[i] = x[i]</p>
<p class="content">如果事先知道集合的大小，那么数组是一种比较理想的结构。因为数组是有序的，所以我们可以用二分搜索建立一个运行时间为O(log n)的成员函数。本节最后将详细讨论数组的运行时间。</p>
<p class="content">如果事先不知道集合的大小，那么链表将是表示集合的首选结构，而且链表还能省去插入时元素移动的开销。</p>
<div class="bodypic_"><img alt="" src="../Images/image00229.jpeg" class="calibre3"/>
</div>
<p class="content">我们的IntSetList类将使用下面的私有数据；</p>
<p class="content">private:</p>
<p class="content_4">int n;</p>
<p class="content_4">struct node{</p>
<p class="content_5">int val;</p>
<p class="content_5">node *next;</p>
<p class="content_5">node(int v,node *p){val = v ; next = p ;}</p>
<p class="content_4">};</p>
<p class="content_4">node *head,*sentinel;</p>
<p class="content">链表中的每个结点都具有一个整数值和一个指向链表中下一结点的指针，node构造函数将两个参数的值赋给这两个字段。</p>
<p class="content">出于和使用有序数组同样的原因，我们使用的链表也是有序的。与在数组中一样，链表使用了一个哨兵结点，其值大于所有实际的值。构造函数建立这样一个结点，并让头指针head指向它。</p>
<p class="content">IntSetList(maxelements,maxval)</p>
<p class="content_4">sentinel = head = new node(maxval,0)</p>
<p class="content_4">n = 0</p>
<p class="content">report函数遍历链表，并将排好序的元素写入输出向量：</p>
<p class="content">void report(int*v)</p>
<p class="content_4">j = 0</p>
<p class="content_4">for (p = head; p != sentinel; p = p-&gt;next)</p>
<p class="content_5">v[j++] = p-&gt;val</p>
<p class="content">为了在有序链表中插入一项，我们遍历整个链表，直到找到该元素（此时立即返回）或找到一个更大的值并在该点插入新元素。不幸的是，情形的多样化通常会导致代码比较复杂，见答案4。我所知道的完成这个任务的最简单的代码是一个递归函数，初始调用是这样的：</p>
<p class="content">void insert(t)</p>
<p class="content_4">head = rinsert(head,t)</p>
<p class="content">递归部分非常清晰；</p>
<p class="content">node *rinsert(p,t)</p>
<p class="content_4">if p-&gt;val &lt; t</p>
<p class="content_5">p-&gt;next = rinsert(p-&gt;next,t)</p>
<p class="content_4">else if p-&gt;val &gt; t</p>
<p class="content_5">p = new node(t,p)</p>
<p class="content_5">n++</p>
<p class="content_4">return p</p>
<p class="content">当编程问题隐藏在众多特殊情形下时，使用递归通常能够将代码简化成上面这样。</p>
<p class="content">当使用上面两种结构之一来生成m个随机整数时，对m次搜索中的每一次而言，平均运行时间都与 m 成正比。因此这两种结构的总运行时间都正比于 m<span class="super">2</span>
 。我猜测链表版本比数组版本要稍微快一些：它通过使用额外的空间（用于指针）避免了对较大元素的移动。下面是n固定为1 000 000，而m在10 000～40 000变化时的运行时间。</p>
<div class="pic_"><img alt="" src="../Images/image00230.jpeg" class="calibre3"/>
</div>
<p class="content">跟我所估计的一样，数组的运行时间成平方级递增，并带有比较合理的常数因子。不过我第一次实现的链表开始时比数组慢一个数量级，而后来运行时间的增幅却比m<span class="super">2</span>
 还要快，肯定出了问题。</p>
<p class="content">我的第一反应就是将原因归结为递归。除了递归调用的开销外，rinsert函数的递归深度就是找到元素的位置，即 O(m)。递归全部结束后，代码将初值赋给几乎所有的指针。当我将递归函数转换成答案4所描述的迭代版本时，运行时间几乎降低为原来的三分之一。</p>
<p class="content">我的第二反应就是使用习题5中的方法改变存储分配：构造函数只分配一个具有m 个结点的块，insert 根据需要使用这些空间；而不是为每次插入操作分配一个新结点。这样就在如下两个不同的方面得到了改进。</p>
<p class="content">附录C中的运行时间开销模型表明，存储分配的时间开销要比大多数简单运算高出两个数量级。我们把m次这样的高开销运算减少到一次。</p>
<p class="content">附录C中的空间开销模型表明，如果将多个结点分配为一个块，每个结点只消耗8个字节的空间（4个用于整数，4个用于指针），40 000个结点消耗320 KB的空间，比较适合我机器的二级缓存。但如果分别为这些结点分配空间，每个结点都要消耗48字节的空间，总共要消耗1.92 MB的空间，超出了二级缓存的容量。</p>
<p class="content">在另一个具有更高效分配器的系统中，消除递归能够将加速系数变为 5，而改成单次分配却只能加速10%。与大多数代码调优技巧类似，高速缓存和递归消除有时会带来很大好处，有时却没什么作用。</p>
<p class="content">数组插入算法搜索整个序列，以找到目标值的合适插入位置，然后再移动比它大的值。链表插入算法只需要完成第一部分工作，不需要进行移动。既然链表只完成一半的工作，为什么却需要两倍的时间呢？部分原因是它需要两倍的内存：大链表必须将8字节的结点读入高速缓存以访问4字节的整数；另一部分原因是数组访问数据时具有较好的预见性，而链表的访问模式则可能导致在内存空间的来回跳跃。</p>
<h3 class="thirdtitle" id="bw103">
<a href="part0000.xhtml#toc113">13.3 二分搜索树</a>
</h3>
<p class="content">下面考虑支持快速搜索和插入的结构。下图给出了依次插入整数 31、41、59 和26后的二分搜索树：</p>
<div class="bodypic_"><img alt="" src="../Images/image00231.jpeg" class="calibre3"/>
</div>
<p class="content">IntSetBST类定义了结点和根：</p>
<p class="content">private:</p>
<p class="content_4">int n,*v,vn;</p>
<p class="content_4">struct node {</p>
<p class="content_5">int val;</p>
<p class="content_5">node *left,*right;</p>
<p class="content_5">node(int i) { val = i; left = right = 0; }</p>
<p class="content_4">};</p>
<p class="content_4">node *root;</p>
<p class="content">初始化该树的时候将根设为空，并通过调用递归函数执行其他操作：</p>
<p class="content">IntSetBST(int maxelements,int maxval) { root = 0; n = 0; }</p>
<p class="content">void insert(int t) { root = rinsert(root,t); }</p>
<p class="content">void report(int *x) { v = x; vn = 0; traverse(root); }</p>
<p class="content">插入函数遍历这棵树，直到找到该值（搜索终止）或在整棵树中都没有找到该值（插入该结点）：</p>
<p class="content">node *rinsert(p,t)</p>
<p class="content_4">if p == 0</p>
<p class="content_5">p = new node(t)</p>
<p class="content_5">n++</p>
<p class="content_4">else if t &lt; p-&gt;val</p>
<p class="content_5">p-&gt;left = rinsert(p-&gt;left,t)</p>
<p class="content_4">else if t &gt; p-&gt;val</p>
<p class="content_5">p-&gt;right = rinsert(p-&gt;right,t)</p>
<p class="content">// do nothing if p-&gt;val == t</p>
<p class="content">return p</p>
<p class="content">由于在我们的应用中，元素是按随机顺序插入的，所以不用考虑复杂的平衡方案。（习题1表明随机集合上的其他算法会得到高度不平衡的树。）</p>
<p class="content">中序遍历<span id="ref50">
<a href="part0009.xhtml#annot50">[10]</a>
</span>
 首先处理左子树，接着输出结点本身，最后处理右子树：</p>
<p class="content">void traverse(p)</p>
<p class="content_4">if p == 0</p>
<p class="content_5">return</p>
<p class="content_4">traverse(p-&gt;left)</p>
<p class="content_4">v[vn++] = p-&gt;val</p>
<p class="content_4">traverse(p-&gt;right)</p>
<p class="content">它使用变量vn来索引向量v中下一个可用元素。</p>
<p class="content">下表给出了13.1节的C++标准模板库set结构（在我机器上的实现）、二分搜索树以及下一节将要介绍的其他几种结构的运行时间，最大的整数规模固定为n = 10<span class="super">8</span>
 。m可以尽可能地增大，直到系统内存不够而必须使用磁盘时为止。</p>
<div class="pic_"><img alt="" src="../Images/image00232.jpeg" class="calibre3"/>
</div>
<p class="content">这些时间都没有包含打印输出的时间，打印输出的时间略大于标准模板库实现的时间。简单的二分搜索树避免了标准模板库所使用的复杂的平衡方案（标准模板库规范能够确保在最坏情况下有较好的性能），因此稍微快一些，同时使用的空间也少一些。标准模板库在m = 1 600 000<span id="ref51">
<a href="part0009.xhtml#annot51">[11]</a>
</span>
 时内存就不够了，而第一个二分搜索树则大概在m =1 900 000时内存不够。标记为“二分搜索树*”的一行描述了进行几种优化后的二分搜索树运行情况。最重要的是它一次性地为所有结点分配空间（如习题5），这大大降低了树的空间需求，从而大约能使运行时间降低三分之一。该代码还将递归转化为迭代（如习题4），并使用了习题7中描述的哨兵结点，这又使速度提高了约25%。</p>
<h3 class="thirdtitle" id="bw104">
<a href="part0000.xhtml#toc114">13.4 用于整数的结构</a>
</h3>
<p class="content">下面介绍最后两个利用整数特性的结构。位向量在第1章就介绍过了，下面是位向量的私有数据和函数：</p>
<p class="content">enum { BITSPERWORD = 32,SHIFT = 5,MASK = 0x1F };</p>
<p class="content">int n,hi,*x;</p>
<p class="content">void set(int i)　{　　　　　x[i&gt;&gt;SHIFT] |=　(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">void clr(int i)　{　　　　　x[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">int test(int i) { return x[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i &amp; MASK)); }</p>
<p class="content">构造函数为数组分配空间并将所有位都置为0：</p>
<p class="content">IntSetBitVec(maxelements,maxval)</p>
<p class="content_4">hi = maxval</p>
<p class="content_4">x = new int[1 + hi/BITSPERWORD]</p>
<p class="content_4">for i = [0,hi]</p>
<p class="content_5">clr(i)</p>
<p class="content_4">n = 0</p>
<p class="content">习题8表明通过一次操作多位数据可以提高这一速度。在report函数中也可以进行类似的提速：</p>
<p class="content">void report(v)</p>
<p class="content_4">j = 0</p>
<p class="content_4">for i = [0,hi]</p>
<p class="content_5">if test(i)</p>
<p class="content_6">v[j++] = i</p>
<p class="content">最后，insert函数将位置为1并增加n，但只在该位原先为0的情况下才这样做：</p>
<p class="content">void insert(t)</p>
<p class="content_4">if test(t)</p>
<p class="content_5">return</p>
<p class="content_4">set(t)</p>
<p class="content_4">n++</p>
<p class="content">上一节的表说明如果最大值n足够小使得位向量能装入内存，那么这个结构的效率就非常高（习题8讨论如何使其更高效）。不幸的是，如果n是2<span class="super">32</span>
 ，则位向量需要0.5 GB的内存。</p>
<p class="content">最后一个数据结构结合了链表和位向量的优点。它在箱序列中放入整数，如果有0～99范围内的4个整数，就将它们放在4个箱中：箱0包含0～24范围内的整数，箱1表示25～49范围内的整数，箱2表示50～74内的整数，箱3表示75～99内的整数：</p>
<div class="bodypic_"><img alt="" src="../Images/image00233.jpeg" class="calibre3"/>
</div>
<p class="content">这m个箱可以看作一种散列，每个箱中的整数用一个有序链表表示。由于整数是均匀分布的，所以每个链表的期望长度都为1。</p>
<p class="content">该结构具有如下私有数据：</p>
<p class="content">private:</p>
<p class="content_4">int n,bins,maxval;</p>
<p class="content_4">struct node{</p>
<p class="content_5">int val;</p>
<p class="content_5">node *next;</p>
<p class="content_5">node(int v,node *p) { val = v; next = p; }</p>
<p class="content_4">};</p>
<p class="content_4">node **bin,*sentinel;</p>
<p class="content">构造函数为箱数组和哨兵元素分配空间，并为哨兵赋一个比较大的值：</p>
<p class="content">IntSetBins(maxelements,pmaxval)</p>
<p class="content_4">bins = maxelements</p>
<p class="content_4">maxval = pmaxval</p>
<p class="content_4">bin = new node*[bins]</p>
<p class="content_4">sentinel = new node(maxval,0)</p>
<p class="content_4">for i = [0,bins)</p>
<p class="content_5">bin[i] = sentinel</p>
<p class="content_4">n = 0</p>
<p class="content">insert函数需要将整数t放入合适的箱中。直观的映射t*bins/maxval可能导致数值溢出（根据我个人的痛苦经验，还可能导致调试很麻烦），因此我们采用下述代码所示的更安全的映射：</p>
<p class="content">void insert(t)</p>
<p class="content_4">i = t / (1 + maxval/bins)</p>
<p class="content_4">bin[i] = rinsert(bin[i],t)</p>
<p class="content">这里的rinsert类似于前面用于链表的rinsert。类似地，report函数本质上也是把对应的链表代码按顺序应用到了每个箱上：</p>
<p class="content">void report(v)</p>
<p class="content_4">j = 0</p>
<p class="content_4">for i = [0,bins)</p>
<p class="content_5">for (node *p = bin[i]; p!= sentinel; p = p-&gt;next)</p>
<p class="content_6">v[j++] = p-&gt;val</p>
<p class="content">上一节的表说明箱很快。标记为“箱*”的一行描述了做出在初始化阶段为所有结点分配空间（如习题5）的修改后箱的运行时间，修改后的结构大约只需要原先四分之一的空间和一半的时间。消除递归可以使运行时间进一步缩短10%。</p>
<h3 class="thirdtitle" id="bw105">
<a href="part0000.xhtml#toc115">13.5 原理</a>
</h3>
<p class="content">本章介绍了5种表示集合的重要数据结构。若m相对n来说比较小，这些结构的平均性能如下表所示（b表示每个元素的位数）。</p>
<div class="pic_"><img alt="" src="../Images/image00234.jpeg" class="calibre3"/>
</div>
<p class="content">上表仅列出了几种简单的集合表示方法。答案 10 提到了其他一些可能的方法， 15.1节描述了用于搜索单词集合的数据结构。</p>
<p class="content">尽管本章主要讨论用于表示集合的数据结构，但我们也学到了一些在许多编程任务中都有用的原理。</p>
<p class="content">库的作用。C++标准模板库提供了一个实现起来很容易，并且维护和扩展也比较简单的通用解决方案。当遇到涉及数据结构的问题时，我们的第一反应应该是寻求解决问题的通用工具。但是在本章的例子中，专用的代码可以充分利用特定问题的性质，大大提高运行速度。</p>
<p class="content">空间的重要性。在13.2节我们看到，调优得很好的链表虽然完成的工作只有数组的一半，但却需要两倍于数组的时间。为什么呢？因为数组中每个元素所占的内存只有链表的一半，而且数组是顺序访问内存的。在13.3节我们看到，使用定制的内存分配方案可以使空间降为原来的三分之一，时间降为原来的一半。当所需的内存超过0.5 MB（我机器的二级缓存大小）并接近80 MB（空闲内存大小）时，运行时间显著增加。</p>
<p class="content">代码调优方法。最显著的改进就是用只分配一个较大内存块的方案来替换通用内存分配。这样就消除了很多开销较大的调用，而且也使空间的利用更加有效。将递归函数重写为迭代版本可以使链表的速度提升为原来的3倍，但只能使箱提速10%。对大多数结构来说，引入哨兵可以获得清晰、简单的代码，并缩短运行时间。</p>
<h3 class="thirdtitle" id="bw106">
<a href="part0000.xhtml#toc116">13.6 习题</a>
</h3>
<p class="content">1.答案12.9描述了生成有序随机整数集合的Bob Floyd算法。你能否用本章的几种IntSet实现该算法？这些结构在Floyd算法生成的非随机分布上性能如何？</p>
<p class="content">2.如何修改简单的IntSet接口使其更健壮？</p>
<p class="content">3.为集合类增加一个 find 函数，该函数用于判断给定的元素是否在集合中。你能否让该函数比insert更高效?</p>
<p class="content">4.为链表、箱和二分搜索树的递归插入函数重写相应的迭代版本，并度量运行时间的差别。</p>
<p class="content">5.9.1节和答案9.2描述了Chris Van Wyk如何通过将可用结点保存在自已的结构中来避免多次调用存储分配器。说明如何将这一思想应用到链表、箱和二分搜索树实现的IntSet上。</p>
<p class="content">6.在各种IntSet实现上对下面的代码段计时，能够发现什么？</p>
<p class="content">IntSetImp S(m,n);</p>
<p class="content">for (int i = 0; i &lt; m; i++)</p>
<p class="content_4">S.insert(i);</p>
<p class="content">7.我们的数组、链表和箱都使用了哨兵。说明如何将哨兵用于二分搜索树。</p>
<p class="content">8.说明如何通过同时在很多位上进行操作来加速位向量的初始化和输出操作。这种方法在操作char、short、int、long或某种其他类型时是不是最有效的?</p>
<p class="content">9.说明如何通过使用低开销的逻辑移位替代高开销的除法运算来对箱进行加速。</p>
<p class="content">10.在完成类似于生成随机数的任务时，可以使用其他哪些数据结构来表示整数集合？</p>
<p class="content">11.实现一个最快的完整函数来生成一个有序的随机整数数组，不允许重复。（可以使用前面介绍的任何接口来表示集合。）</p>
<h3 class="thirdtitle" id="bw107">
<a href="part0000.xhtml#toc117">13.7 深入阅读</a>
</h3>
<p class="content">11.6节介绍了Knuth和Sedgewick编写的优秀算法教材。搜索是Knuth的The Art of Computer Programming，Volume 3：Sorting and Searching一书第6章（第二部分）的主题，也是Sedgewick的Alorithms一书第四部分的主题。</p>
<h3 class="thirdtitle" id="bw108">
<a href="part0000.xhtml#toc118">13.8 一个实际搜索问题（边栏）</a>
</h3>
<p class="content">本章给出的简单结构为我们研究工业级的数据结构提供了基础。而本节将研究Doug McIlroy于1978年写的spell程序中用于表示字典的著名结构。20世纪80年代撰写本书初稿时，我使用McIlroy的程序对各章进行了拼写检查。对本书我再次使用了 spell，发现它仍然非常有用。有关该程序的详细内容见 McIlroy 发表于 IEEE Transactions on Communications第30卷第1期的“Development of a spelling list”一文（1982年1月，第91页～第99页）。我的字典将“珠玑”定义为“上等的、精致的”东西，他的程序是符合这一标准的。</p>
<p class="content">McIlroy面对的第一个问题是组成单词列表。他求出了完整版字典（为了权威性）和有百万单词的布朗大学英语语料库（为了时效性）的交集，这是一个合理的开端，但仍有许多工作需要完成。</p>
<p class="content">McIlroy 组成单词列表的方法可以通过如何处理专有名词来说明，因为大多数字典都没有专有名词。首先是人名：大型电话号码簿中最常见的 1000 个姓、男孩和女孩的名字列表、著名的名字（如Dijkstra和Nixon）以及Bulfinch神话中虚构的名字；发现了Xerox和Texaco这样的“拼写错误”后，他把财富500强中的公司名也考虑进来了；出版公司的名字在参考书目中出现得很多，所以也要包含进来。接着是地理名词：国家及其首都、州及其首府、美国和世界上最大的100个城市，此外还有海洋、行星和恒星。</p>
<p class="content">他还添加了动植物的常用名，以及化学、解剖学中的术语，当然还有计算机术语。但同时他也注意尽量不增加太多：不考虑有效但生活中容易误拼的单词（如地质学术语 cwm），并且在有几种可选的拼写方法时只包含一个（因此只有 traveling 而没有travelling）。</p>
<p class="content">McIlroy的窍门在于检查实际运行时spell的输出，有一段时间spell会自动将输出复制一份发送给他（那时候人们对隐私和性能之间权衡的观点与现在不同）。当发现问题时，他尽可能采用最具有一般性的解决方法。这样最终得到了75 000个精选单词的列表：它包含了我在文档中可能用到的大多数单词，至今仍能帮我查出拼写错误。</p>
<p class="content">该程序使用词缀分析从单词中去除前后缀，这样做很有必要也非常方便。说它有必要是因为我们没有全部英语单词的列表，拼写检查器只有两种选择：要么猜测misrepresented之类的派生词，要么对许多有效的英语单词报错。说它方便是因为词缀分析能够缩小字典的规模。</p>
<p class="content">词缀分析的目标是去掉 mis-、re-、pre-和-ed，把 misrepresented 缩短为 sent。（represent并不表示“再次出现”，present的含义也不是“事先发送”，spell利用这样的巧合来缩小字典的规模。）程序的表中包含40条前缀法则和30条后缀法则，并使用一个具有 1300 项例外的“终止列表”来终止符合词缀法则但并不正确的猜测，例如，把entend（intend的误拼）理解为en-+tend。这一分析把75 000单词的列表进一步压缩为30 000单词。McIlroy的程序对每个单词执行循环，不断地去除词缀直至找到匹配或者虽没有找到匹配但已无词缀（此时报错）。</p>
<p class="content">粗略的分析表明，将字典放在内存中是很重要的。McIlroy最初是在只有64 KB地址空间的PDP-11上编写该程序的，对他来说把字典放在内存中尤其困难。他在文章摘要中总结了自己的空间压缩策略：“去除前后缀使得列表的大小不到原先的三分之一，散列法又去掉了剩下的 60%，接下来的数据压缩再次节省了一半的空间。”从而可以用26 000个16位的计算机字就能表示75 000个英语单词（以及数量跟这差不多的单词变形）。</p>
<p class="content">McIlroy通过散列来表示30 000个英语单词，每个单词用27位表示（马上我们会看到为什么选27）。下面以一个小型单词列表为例说明其方案：</p>
<p class="content_">a list of five words</p>
<p class="content">第一种散列法用到了一个几乎和单词列表一样大的n元散列表以及一个把字符串映射为[0,n)范围内的整数的散列函数（15.1节将看到这样一个用于字符串的散列函数）。表的第i项指向一个链表，该链表包含所有散列到i的字符串。如果用空白单元表示空列表，且散列函数满足h(a)=2，h(list)=1，等等，那么相应的5元散列表如下所示：</p>
<div class="bodypic_"><img alt="" src="../Images/image00235.jpeg" class="calibre3"/>
</div>
<p class="content">为了查找单词w，我们对第h(w)个单元指向的链表进行顺序搜索。</p>
<p class="content">第二种方案使用的表要大得多。选择 n=23 使得大多数散列单元可能只包含一个元素。在本例中，h(a)=13且h(list)=5。</p>
<div class="bodypic_"><img alt="" src="../Images/image00236.jpeg" class="calibre3"/>
</div>
<p class="content">spell程序中取n=2<span class="super">27</span>
 （约1.34亿），几乎所有的非空链表都仅包含一个元素。</p>
<p class="content">下一步非常大胆：McIlroy 在每个表项中仅存放一个位，而不是存放单词链表。这就大大节省了空间，但也容易出错。下图使用和前面一样的散列函数，并用空白单元表示为零的位。</p>
<div class="bodypic_"><img alt="" src="../Images/image00237.jpeg" class="calibre3"/>
</div>
<p class="content">为了查找单词w，程序访问表中的第h(w)位。如果该位为0，那么程序就正确地报告说单词w不在表中；如果该位为1，程序就认为w在表中。有时候，不正确的单词会碰巧散列到有效位，但是出现这种错误的概率只有30 000/2<span class="super">27</span>
 （约1/4 000）。因此，平均每4000个不正确的单词中只有一个会被认为有效。McIlroy经过观察发现，常见的草稿所包含的错误很少超过20个，所以程序每运行100次最多只出现1次这种错误——这就是他选择27的原因。</p>
<p class="content">使用n=2<span class="super">27</span>
 位的字符串表示散列表将消耗超过16 MB的空间，因此，程序仅表示值为1的位。在上面的例子中，程序存储下列散列值：</p>
<p class="content_">5 10 13 18 22</p>
<p class="content">如果h(w)存在，那么我们认为单词w在表中。表示这些值一般需要30 000个27位的计算机字，但是McIlroy机器的地址空间中仅有32 000个16位的字。因此他对列表排序，并使用可变长码来表示连续散列值之间的差值。假设从值0开始，上面的列表可压缩为：</p>
<p class="content_">5 5 3 5 4</p>
<p class="content">McIlroy的spell程序平均使用13.6位来表示每个差值，这样就节省下了几百个额外的字来指向压缩列表中有用的起始位置，从而加快顺序搜索。这样我们就得到一个64 KB的字典，该字典不仅支持快速访问，而且很少出错。</p>
<p class="content">前面我们考虑了spell两个方面的性能：它输出有用的结果，并能适用于只有64 KB 地址空间的情况。此外，该程序的速度也非常快。即便在最初编写该程序的老机器上，它也能在半分钟完成对 10 页文档的拼写检查，检查与本书容量差不多的一本书也只需要约10分钟（当时看来是非常快的）。因为该字典很小，能够从磁盘上很快地读入，所以单个单词的拼写检查只需要几秒钟。</p>
<h2 class="secondtitle" id="bw109">
<a href="part0000.xhtml#toc119">第14章 堆</a>
</h2>
<p class="content">本章主要介绍“堆”，我们将使用这一数据结构解决下面两个重要问题。</p>
<p class="content">排序。采用堆排序算法对n元数组排序，所花的时间不会超过O(n log n)，而且只需要几个字的额外空间。</p>
<p class="content">优先级队列。堆通过插入新元素和提取最小元素这两种操作来维护元素集合，每个操作所需的时间都为O(log n)。</p>
<p class="content">对于这两个问题，用堆来处理都易于编码且计算效率很高。</p>
<p class="content">本章采用自底向上的组织结构：从细节开始，逐步过渡到我们的正题。下面两节描述了堆数据结构和对其进行操作的两个函数，随后的两节使用这些工具解决上面提到的问题。</p>
<h3 class="thirdtitle" id="bw110">
<a href="part0000.xhtml#toc120">14.1 数据结构</a>
</h3>
<p class="content">堆是用来表示元素集合的一种数据结构<span id="ref52">
<a href="part0009.xhtml#annot52">[12]</a>
</span>
 。我们给的示例中堆用于表示数值，但实际上堆中的元素可以是任何有序类型。下面是由12个整数构成的堆：</p>
<div class="bodypic_"><img alt="" src="../Images/image00238.jpeg" class="calibre3"/>
</div>
<p class="content">这棵二叉树是一个堆，这是由它的如下两个性质决定的。第一个性质是顺序：任何结点的值都小于或等于其子结点的值。这意味着集合的最小元素位于根结点（本例中为12），但是它没有说明左右子结点的相对顺序。第二个性质是形状，如下图所示。</p>
<div class="bodypic_"><img alt="" src="../Images/image00239.jpeg" class="calibre3"/>
</div>
<p class="content">用文字可以表述为：具有这种形状性质的二叉树，最多在两层上具有叶结点，其中最底层的叶结点尽可能地靠左分布。树中不存在空闲的位置，如果它有n个结点，那么所有结点到根结点的距离都不超过log<span class="sub">2</span>
 n。马上我们就能看到，这两个性质具有足够的限制性，使得我们能够找到集合中的最小元素；但也具有足够的灵活性，使得我们在插入或删除一个元素之后能够有效地重新组织结构。</p>
<p class="content">下面我们考虑堆的实现。最常见的二叉树表示方法需要使用记录和指针。我们的实现仅适合于具有形状性质的二叉树，但对于这种特殊情况非常有效。具有形状性质的12元二叉树可以用一个12元的数组x[1..12]表示如下：</p>
<div class="bodypic_"><img alt="" src="../Images/image00240.jpeg" class="calibre3"/>
</div>
<p class="content">注意，堆使用的是从下标1开始的数组，C语言中最简单的方法就是声明x[n+l]并浪费元素x[0]。在这个隐式的二叉树表示中，根结点位于x[1]，它的两个子结点分别位于x[2]和x[3]，依此类推。树中常见的函数定义如下：</p>
<p class="content">root = 1</p>
<p class="content">value(i) = x[i]</p>
<p class="content">leftchild(i) = 2*i</p>
<p class="content">rightchild(i) = 2*i+1</p>
<p class="content">parent(i) = i / 2</p>
<p class="content">null(i) = (i &lt; 1) or (i &gt; n)</p>
<p class="content">n元的隐式树一定具有形状性质：它不会考虑元素缺失的情况。</p>
<p class="content">下图给出了一个12元的堆以及用12元数组表示的隐式树实现。</p>
<div class="bodypic_"><img alt="" src="../Images/image00241.jpeg" class="calibre3"/>
</div>
<p class="content">由于形状性质是通过表示方法来保证的，从现在开始，我们约定“堆”这个词意味着任何结点的值都大于或等于其父结点的值。更精确地说，如果</p>
<p class="content_">∀<span class="sub">2≤i≤n</span>
 x[i/2]≤x[i]</p>
<p class="content">那么数组x[1..n]就具有堆性质。回忆一下，整数除法操作“/”会向下取整，所以4/2和5/2都是2。下一节将讨论具有堆性质的子数组x[l..u]（它具有形状性质的一种变体性质），我们可以从数学上把heap(l,u)定义为：</p>
<p class="content_">∀ <span class="sub">2l≤i≤u</span>
 x[i/2]≤x[i]</p>
<h3 class="thirdtitle" id="bw111">
<a href="part0000.xhtml#toc121">14.2 两个关键函数</a>
</h3>
<p class="content">本节研究两个函数，这两个函数用于在数组某一端不再具备堆性质时进行调整。两个函数都很有效率：重新组织一个n元的堆大约需要log n步。考虑到本章的自底向上风格，我们在这里先给出函数定义，下一节再使用它们。</p>
<p class="content">当x[1..n-1]是堆时，在x[n]中放置一个任意的元素可能无法产生heap(1,n)。我们使用siftup函数来重新获得堆性质。该函数的名字就表明了其策略：它尽可能地将新元素向上筛选，向上筛选是通过交换该结点与其父结点来实现的。（本节使用常见的堆定义来规定哪个方向是向上筛选的方向：堆的根为x[1]，位于树的顶部，因此x[n]位于数组的底部。）下图（从左到右）演示了新元素13在堆中向上筛选，直到到达合适的位置并成为根的右子结点的过程。</p>
<div class="bodypic_"><img alt="" src="../Images/image00242.jpeg" class="calibre3"/>
</div>
<p class="content">该过程一直持续到带圈的结点大于等于其父结点（本例所示）或位于树根。如果过程开始时heap(1,n-1)为真，那么heap(1,n)为真。</p>
<p class="content">有了这一直观的背景，我们就可以编写代码了。由于筛选过程需要一个循环，所以我们从循环不变式开始。在上图中，除了带圈结点和其父结点之间的部分外，树的所有其他地方都具有堆性质。如果i是带圈结点的下标，那么就可以使用不变式：</p>
<p class="content">loop</p>
<p class="content_4">/* invariant: heap(1,n) except perhaps</p>
<p class="content_5">between i and its parent */</p>
<p class="content">由于开始时heap(1,n-1)为真，因此可以通过赋值语句i = n初始化循环。</p>
<p class="content">循环中必须检查有没有完成任务（带圈的结点要么位于堆的顶部，要么大于或等于它的父结点），若没有则继续。不变式表明，除了结点i和其父结点之间的部分可能不具有堆性质外，其他地方都具有堆性质。如果i == 1为真，那么结点i没有父结点，从而所有地方都具有堆性质，因此可以终止循环。当结点i有父结点时，可以通过赋值语句p==i/2使p成为父结点的下标。如果x[p]≤x[i]，那么所有地方都具有堆性质，循环可以终止。</p>
<p class="content">另一方面，如果结点i和其父结点之间的顺序不对，那么我们交换x[i]和x[p]。这一步骤如下图所示，其中的关键字是单个字母，结点i带有圈。</p>
<div class="bodypic_"><img alt="(以下不是块的文字)块坐标:92,421,329,372" src="../Images/image00243.jpeg" class="calibre3"/>
</div>
<p class="content">交换之后，所有5个元素的顺序都是正确的：因为b原先在堆中就位于较高层<span id="ref53">
<a href="part0009.xhtml#annot53">[13]</a>
</span>
 所以b&lt;d且b&lt;e；因为测试条件x[p]≤x[i]不满足，所以a&lt;b；结合a&lt;b和b&lt;c可以得到a&lt;c。这就确保了除了结点 p 和其父结点之间的部分外，其他地方都具有堆性质，因此我们通过赋值语句i =p重新获得不变式。</p>
<p class="content">这个过程给出在下面的siftup代码中，它的运行时间和log n成正比，因为堆具有log n层。</p>
<p class="content">void siftup(n)</p>
<p class="content_6">pre n &gt; 0 &amp;&amp; heap(1,n-1)</p>
<p class="content_6">post heap(1,n)</p>
<p class="content_5">i = n</p>
<p class="content_5">loop</p>
<p class="content_6">/* invariant: heap(1,n) except perhaps</p>
<p class="content_13">between i and its parent */</p>
<p class="content_6">if i == 1</p>
<p class="content_7">break</p>
<p class="content_6">p = i / 2</p>
<p class="content_6">if x[p] &lt;= x[i]</p>
<p class="content_9">break</p>
<p class="content_9">swap(p,i)</p>
<p class="content_9">i = p</p>
<p class="content">跟第 4 章一样，“pre”和“post”开头的两行特征化该函数：如果在函数调用之前前置条件为真，那么在函数返回之后后置条件也为真。</p>
<p class="content">下面考虑siftdown，当x[1..n]是一个堆时，给x[1]分配一个新值得到heap(2,n)，然后用函数siftdown使得heap(1,n)为真。该函数将x[1]向下筛选，直到它没有子结点或小于等于它的子结点。下图给出了 18 在堆中向下筛选直到最后小于它的单个子结点19的过程。</p>
<div class="bodypic_"><img alt="" src="../Images/image00244.jpeg" class="calibre3"/>
</div>
<p class="content">元素向上筛选时，总是向根移动。向下筛选比较复杂：将顺序不对的元素和比它小的子结点交换。</p>
<p class="content">上图显示了siftdown循环的不变式：除了带圈结点和它的子结点之间的部分外，其他部分都具有堆性质。</p>
<p class="content">loop</p>
<p class="content_4">/* invariant: heap(1,n) except perhaps between</p>
<p class="content_5">i and its (0,1 or 2) children */</p>
<p class="content">这个循环和siftup的循环非常相似。首先检查结点i是否具有子结点，如果没有子结点就终止循环。下面就涉及比较复杂的部分了：如果结点i具有子结点，那么把变量c设置为较小的那个子结点的下标。最后，或者满足x[i]≤x[c]终止循环，或者通过交换x[i]和x[c]并赋值i = c继续进行到循环底部。</p>
<p class="content">void siftdown(n)</p>
<p class="content_4">pre heap(2,n) &amp;&amp; n &gt;= 0</p>
<p class="content_4">post heap(1,n)</p>
<p class="content">i = 1</p>
<p class="content">loop</p>
<p class="content_4">/* invariant: heap(1,n) except perhaps between i and its (0,1 or 2) children */</p>
<p class="content_4">c = 2*i</p>
<p class="content">if c &gt; n</p>
<p class="content_4">break</p>
<p class="content">/* c is the left child of i */</p>
<p class="content">if c+1 &lt;= n</p>
<p class="content_4">/* c+1 is the right child of i */if x[c+1] &lt; x[c]</p>
<p class="content_5">c++</p>
<p class="content">/* c is the lesser child of i */</p>
<p class="content">if x[i] &lt;= x[c]</p>
<p class="content_4">break</p>
<p class="content">swap(c,i)</p>
<p class="content">i = c</p>
<p class="content">与siftup类似的实例分析表明，交换操作使得除了结点c和它的子结点之间的部分外，其他所有地方都具有堆性质。跟siftup类似，这个函数所需的时间和log n成正比，因为它在堆的每层的计算量都是固定的。</p>
<h3 class="thirdtitle" id="bw112">
<a href="part0000.xhtml#toc122">14.3 优先级队列</a>
</h3>
<p class="content">每个数据结构都可以从两方面看。从外部来看，它的规范说明了它做什么——队列通过insert和extract操作来维护元素序列。从内部来看，它的实现说明了它如何做——队列可以使用数组或链表来实现。本节首先说明优先级队列的抽象性质，再考虑其实现。</p>
<p class="content">优先级队列操作一个初始为空<span id="ref54">
<a href="part0009.xhtml#annot54">[14]</a>
</span>
 的元素集合，称为S。insert函数在集合中插入一个新元素，可以在前置条件和后置条件中更精确地定义如下：</p>
<p class="content">void insert(t)</p>
<p class="content_4">pre |S| &lt; maxsize</p>
<p class="content_4">post current S = original S ∪ {t}</p>
<p class="content">函数extractmin删除集合中最小的元素，并通过单个参数t返回该值。</p>
<p class="content">int extractmin()</p>
<p class="content_4">pre |S| &gt; 0</p>
<p class="content_4">post original S = current S ∪ {result}</p>
<p class="content_5">&amp;&amp; result = min(original S)</p>
<p class="content">当然，可以修改这个函数以产生最大元素，或总排序下的任何极值。</p>
<p class="content">可以使用模板（指定队列中元素的类型为T）定义一个C++类来完成这一任务：</p>
<p class="content">template&lt;class T&gt;</p>
<p class="content">class priqueue {</p>
<p class="content">public:</p>
<p class="content_4">priqueue(int maxsize);　　// init set S to empty</p>
<p class="content_4">void insert(T t);　　　　　// add t to S</p>
<p class="content_4">T extractmin();　　　　　　 // return smallest in S</p>
<p class="content">};</p>
<p class="content">优先级队列在许多应用中都非常有用。操作系统可以使用这样一种结构来表示一组任务，按任意顺序插入它们，然后进行提取：</p>
<p class="content">priqueue&lt;Task&gt; queue;</p>
<p class="content">在模拟离散事件时，可以把事件的时间作为元素。模拟循环提取下一个事件，并且可能在队列中添加更多的事件：</p>
<p class="content">priqueue&lt;Event&gt; eventqueue;</p>
<p class="content">这两个应用都需要使用集合元素之外的信息来扩展基本的优先级队列。在下面的讨论中将忽略“实现细节”，但是C++类通常能很好地处理。</p>
<p class="content">显然，我们可以使用数组或链表之类的顺序结构来实现优先级队列。如果序列是有序的，那么提取最小元素非常简单，但插入新元素比较困难；在无序的结构中情况则相反。下表比较了n元集合上几种结构的性能。</p>
<div class="pic_"><img alt="" src="../Images/image00245.jpeg" class="calibre3"/>
</div>
<p class="content">尽管二分搜索能够在O(log n)时间内找到新元素的位置，但是移动已有的元素给新元素腾空间却需要O(n)步。如果你忘记了O(n<span class="super">2</span>
 )算法和O(n log n)算法之间的区别，请回顾一下8.5节：当n为100万时，这两种算法的程序运行时间分别为3小时和1秒。</p>
<p class="content">优先级队列的堆实现提供了两种顺序结构之间的折中方案。它使用具有堆性质的数组x[l..n]表示n元集合，其中x在C或C++中声明为x[maxsize+l（] 我们不使用x[0]）。可以通过赋值n = 0将集合初始化为空。插入新元素时将n加1，然后将新元素放置在x[n]处。这样我们就具备了调用siftup的前提：heap(1,n-1)。因此，插入操作的代码如下所示：</p>
<p class="content">void insert(t)</p>
<p class="content_4">if n &gt;= maxsize</p>
<p class="content_5">/* report error */</p>
<p class="content_4">n++</p>
<p class="content_4">x[n] = t</p>
<p class="content_4">/* heap(1,n-1) */</p>
<p class="content_4">siftup(n)</p>
<p class="content_4">/* heap(1,n) */</p>
<p class="content">函数extractmin查找并删除集合中的最小元素，然后重新组织数组使其具有堆性质。由于该数组是一个堆，所以最小元素位于x[1]，集合中剩下的n-1个元素位于x[2..n]中。新数组也具有堆性质，通过两步可重新得到 heap(1,n)。第一步，将 x[n]移动到x[1],并将n减1，这样集合中的元素就都在x[1..n]中了，并且heap(2,n)为真；第二步，调用siftdown。代码非常简单：</p>
<p class="content">int extractmin()</p>
<p class="content_4">if n &lt; 1</p>
<p class="content_5">/* report error */</p>
<p class="content_4">t = x[1]</p>
<p class="content_4">x[1] = x[n--]</p>
<p class="content_4">/* heap(2,n) */</p>
<p class="content_4">siftdown(n)</p>
<p class="content_4">/* heap(1,n) */</p>
<p class="content_4">return t</p>
<p class="content">当将insert和extractmin应用到包含n个元素的堆时，都需要O(log n)的时间。</p>
<p class="content">下面是优先级队列的完整C++实现：</p>
<p class="content">template&lt;class T&gt;</p>
<p class="content">class priqueue {</p>
<p class="content">private:</p>
<p class="content_4">int n,maxsize;</p>
<p class="content_4">T *x;</p>
<p class="content_4">void swap(int i,int j)</p>
<p class="content_4">{ T t = x[i]; x[i] = x[j]; x[j] = t; }</p>
<p class="content">public:</p>
<p class="content_4">priqueue(int m)</p>
<p class="content_4">{ maxsize = m;</p>
<p class="content_5">x = new T[maxsize+1];</p>
<p class="content_5">n = 0;</p>
<p class="content_4">}</p>
<p class="content_4">void insert(T t)</p>
<p class="content_4">{ int i,p;</p>
<p class="content_5">x[++n] = t;</p>
<p class="content_5">for (i = n; i &gt; 1 &amp;&amp; x[p=i/2] &gt; x[i]; i = p)</p>
<p class="content_6">swap(p,i);</p>
<p class="content_4">}</p>
<p class="content_4">T extractmin(){</p>
<p class="content_5">int i,c;</p>
<p class="content_5">T t = x[1];</p>
<p class="content_5">x[1] = x[n--];</p>
<p class="content_5">for (i = 1; (c = 2*i) &lt;= n; i = c) {</p>
<p class="content_6">if (c+1 &lt;= n &amp;&amp; x[c+1] &lt; x[c])</p>
<p class="content_7">c++;</p>
<p class="content_6">if (x[i] &lt;= x[c])</p>
<p class="content_7">break;</p>
<p class="content_6">swap(c,i);</p>
<p class="content_5">}</p>
<p class="content_5">return t;</p>
<p class="content_4">}</p>
<p class="content">};</p>
<p class="content">这个简单的接口程序没有提供错误检查机制和析构函数，但是却简洁地表达了算法的本质内容。相比于伪代码的冗长风格而言，上述精炼的代码走的是另一个极端。</p>
<h3 class="thirdtitle" id="bw113">
<a href="part0000.xhtml#toc123">14.4 一种排序算法</a>
</h3>
<p class="content">优先级队列提供了一种简单的向量排序算法：首先在优先级队列中依次插入每个元素，然后按序删除它们。在C++中使用priqueue类进行编码非常简单：</p>
<p class="content">template&lt;class T&gt;</p>
<p class="content">void pqsort(T v[],int n)</p>
<p class="content">{ priqueue&lt;T&gt; pq(n);</p>
<p class="content_4">int i;</p>
<p class="content_4">for (i = 0; i &lt; n; i++)</p>
<p class="content_5">pq.insert(v[i]);</p>
<p class="content_4">for (i = 0; i &lt; n; i++)</p>
<p class="content_5">v[i] = pq.extractmin();</p>
<p class="content">}</p>
<p class="content">n次insert和extractmin操作在最坏情况下的开销是O(n log n)，优于第11章中快速排序的最坏情况开销O(n<span class="super">2</span>
 )。不幸的是，堆使用的数组x[0..n]需要n+1个字的额外内存。</p>
<p class="content">现在来看看堆排序，它改进了上面的方法。堆排序算法的代码更少；由于不需要辅助数组，因此使用的空间更少；此外，需要的时间也更少。根据该算法的目的，假设我们已经修改了 siftup 和 siftdown，使它们能够操作最大元素在顶部的堆（通过交换“&lt;”和“&gt;”符号很容易就能实现这一点）。</p>
<p class="content">以前的简单算法使用两个数组，一个用于优先级队列，另一个用于待排序的元素。堆排序仅使用一个数组，因而节省了空间。单个数组x同时表示两种抽象结构：左边是堆，右边是元素序列。元素的初始顺序是随意的，最终则是有序的。下图给出了数组x的演变过程：数组是水平绘制的，垂直方向表示时间。</p>
<div class="bodypic_"><img alt="步骤0堆步骤n堆已排序步骤2n-1" src="../Images/image00246.jpeg" class="calibre3"/>
</div>
<p class="content">堆排序算法是一个两阶段的过程：前n步将数组建立到堆中，后n步按降序提取元素并从右到左建立最终的有序序列。</p>
<p class="content">第一阶段建立堆，其不变式如下所示：</p>
<div class="bodypic_"><img alt="堆" src="../Images/image00247.jpeg" class="calibre3"/>
</div>
<p class="content">下面这段代码通过将元素在数组中向上筛选来建立heap(1,n)：</p>
<p class="content">for i = [2,n]</p>
<p class="content_4">/* invariant: heap(1,i-1) */</p>
<p class="content">siftup(i)</p>
<p class="content">/* heap(1,i) */</p>
<p class="content">第二阶段使用堆来建立有序序列，其不变式如下所示：</p>
<div class="bodypic_"><img alt="堆，≤ 已排序，≥" src="../Images/image00248.jpeg" class="calibre3"/>
</div>
<p class="content">两个操作的循环体都始终保持不变式为真。由于x[1]是前i个元素中最大的，将它和 x[i]交换就使有序序列多了一个元素。这一交换影响到了堆性质，我们可以通过把新的顶部元素向下筛选来重新获得堆性质。第二阶段的代码如下所示：</p>
<p class="content">for (i = n; i &gt;= 2; i--)</p>
<p class="content_4">/* heap(1,i) &amp;&amp; sorted(i+1,n) &amp;&amp; x[1..i] &lt;= x[i+1..n] */swap(1,i)</p>
<p class="content_4">/* heap(2,i-1) &amp;&amp; sorted(i,n) &amp;&amp; x[1..i-1] &lt;= x[i..n] */siftdown(i-1)</p>
<p class="content_4">/* heap(1,i-1) &amp;&amp; sorted(i,n) &amp;&amp; x[1..i-1] &lt;= x[i..n] */</p>
<p class="content">有了前面建立的函数，完整的堆排序算法仅需要5行代码：</p>
<p class="content">for i = [2,n]</p>
<p class="content_4">siftup(i)</p>
<p class="content">for (i = n; i &gt;= 2; i--)</p>
<p class="content_4">swap(1,i)</p>
<p class="content_4">siftdown(i-1)</p>
<p class="content">由于该算法使用了n-1次siftup和n-1次siftdown操作，而每次操作的开销最多为O(log n)，因此即使在最坏情况下，该算法的运行时间也是O(n log n)。</p>
<p class="content">答案2和答案3描述了几种用来加速（同时也简化）堆排序算法的方法。虽然堆排序保证了最坏情况下的O(n log n)性能，但对于常见的输入数据，最快的堆排序通常也比11.2节的简单快速排序慢。</p>
<h3 class="thirdtitle" id="bw114">
<a href="part0000.xhtml#toc124">14.5 原理</a>
</h3>
<p class="content">高效性。形状性质保证了堆中所有结点和根结点之间相差的层数在 log<span class="sub">2</span>
 n 之内。由于树是平衡的，所以函数siftup 和siftdown的运行效率很高。堆排序通过在同一个实现数组中包含两种抽象结构（堆和元素序列）来避免使用额外的空间。</p>
<p class="content">正确性。为循环编写代码之前首先要精确地说出它的不变式，循环体执行过程中始终保持不变式为真。形状和顺序性质是另一种不变式：它们是堆数据结构的不变性质。操作堆的函数可以假设其开始运行时上述性质为真，并且必须确保运行结束时这些性质仍为真。</p>
<p class="content">抽象性。好的工程师能够分清某个组件做什么（用户看到的抽象功能）和如何做（黑盒实现）之间的差别。本章将黑盒按两种不同的方式打包：过程抽象和抽象数据类型。</p>
<p class="content">过程抽象。你可以在不知道排序函数实现细节的情况下用它来排序数组，即将排序视为单个操作。函数siftup和siftdown提供了类似级别的抽象：在建立优先级队列和堆排序算法时，我们并不关心函数是如何工作的，但是我们知道它们做了什么工作（用于在数组某一端不再具备堆性质时进行调整）。良好的工程设计使得我们可以只对这些黑盒组件定义一次，然后使用它们组成两种不同类型的工具。</p>
<p class="content">抽象数据类型。数据类型做什么是由它的方法和方法的规范给出的，而如何做则是由具体实现决定的。我们可以仅仅使用本章的 C++类 priqueue 或上一章的 C++类IntSet的规范来推断它们的正确性，当然它们的具体实现肯定会对程序的性能有影响。</p>
<h3 class="thirdtitle" id="bw115">
<a href="part0000.xhtml#toc125">14.6 习题</a>
</h3>
<p class="content">1.实现基于堆的优先级队列，尽可能地提高运行速度。n取何值时比顺序结构快？</p>
<p class="content">2.修改siftdown使之满足下列规范。</p>
<p class="content">void siftdown(l,u)</p>
<p class="content_4">pre heap(l+1,u)</p>
<p class="content_4">post heap(l,u)</p>
<p class="content">代码的运行时间是多少？说明如何用它来在O(n)时间内构造一个n元堆，从而得到一个代码量更少且更快速的堆排序算法。</p>
<p class="content">3.实现一个尽可能快的堆排序程序。你的程序与11.3节表格给出的排序算法相比性能如何？</p>
<p class="content">4.如何使用优先级队列的堆实现解决下列问题？当输入有序时，你的答案有什么变化？</p>
<p class="content">a.构建赫夫曼码（绝大多数关于信息理论的书和许多关于数据结构的书都会讨论这种编码）。</p>
<p class="content">b.计算大型浮点数集合的和。</p>
<p class="content">c.在存有10亿个数的文件中找出最大的100万个数。</p>
<p class="content">d.将多个较小的有序文件归并为一个较大的有序文件（在实现1.3节那样的基于磁盘的归并排序程序时会出现这种问题）。</p>
<p class="content">5.装箱问题需要将n个权值（每个都介于0和1之间）分配给最少数目的单位容量箱。解决这一问题的“首次适应”启发式方法按序考虑权值，将每个权值放到第一个合适的箱中（按升序扫描箱）。David Johnson在他的MIT论文中指出，一种类似于堆的结构能够在O(n log n)时间内实现该启发式方法。说明如何实现。</p>
<p class="content">6.磁盘上顺序文件的常见实现让每个块都指向它的后继块，后继块可以是磁盘上的任意一个块。该方法要求写入一个块（因为文件已经写在硬盘上了）、读取文件的第一个块以及读完文件的第i-1个块后再读第i个块所需的时间都是同一个常数，从而从头开始读第i个块所需的时间跟i成正比。Ed McCreight在施乐帕洛阿尔托研究中心设计磁盘控制器时发现，只要为每个结点增加一个额外的指针，就能获得其他所有的性质，但却使读取第i个块的时间正比于log i。如何实现这一点？解释一下这里读取第i个块的算法与习题4.9中在正比于log i的时间内计算i次幂的代码有什么共同点。</p>
<p class="content">7.在一些计算机上，除以 2 以求出当前范围的中点是二分搜索程序中开销最大的部分。假设我们已经正确构建了待搜索的数组，说明如何使用乘以 2 的操作来替代除法。给出建立并搜索这样一个数组的算法。</p>
<p class="content">8.有哪些方法可以较好地实现表示[0,k)范围内整数的优先级队列（队列的平均规模远远大于k）？</p>
<p class="content">9.证明在优先级队列的堆实现中，insert和extractmin的对数运行时间都在一个最佳常数因子范围内。</p>
<p class="content">10.体育爱好者都很熟悉堆的基本观点。假设在半决赛中，Brian击败了Al， Lynn击败了Peter,并且在决赛中Lynn战胜了Brian，这些结果通常可绘制为：</p>
<div class="bodypic_"><img alt="" src="../Images/image00249.jpeg" class="calibre3"/>
</div>
<p class="content">这样的“锦标赛树”在网球锦标赛和足球、棒球、篮球的季后赛中很常见。假设比赛的结果是一致的（在体育运动中这种假设通常是无效的）<span id="ref55">
<a href="part0009.xhtml#annot55">[15]</a>
</span>
 ，那么 2 号种子进入决赛的概率有多大？请根据运动员的赛前排名来安排比赛的场次。</p>
<p class="content">11.在C++标准模板库中如何实现堆、优先级队列和堆排序？</p>
<h3 class="thirdtitle" id="bw116">
<a href="part0000.xhtml#toc126">14.7 深入阅读</a>
</h3>
<p class="content">11.6 节介绍了 Knuth 和 Sedgewick 编写的优秀算法教材。Knuth 的 The Art of Computer Programming，Volume 3：Sorting and Searching一书的5.2.3节描述了堆和堆排序，Sedgewick的Algorithms一书的第9章描述了优先级队列和堆排序。</p>
<h2 class="secondtitle" id="bw117">
<a href="part0000.xhtml#toc127">第15章 字符串</a>
</h2>
<p class="content">我们生活在一个字符串的世界里。位字符串构成了整数和浮点数，数字字符串构成了电话号码，字母字符串构成了单词，长字符串可以形成网页，更长的字符串则形成书。在遗传学家的数据库和本书众多读者的细胞内，存在着由字母 A、C、G 和 T表示的极长的字符串。</p>
<p class="content">可以用程序对这些字符串执行各种各样的操作，例如排序、统计、搜索以及分析它们以区分不同的模式等。本章通过一些有关字符串的经典问题来讨论这些操作。</p>
<h3 class="thirdtitle" id="bw118">
<a href="part0000.xhtml#toc128">15.1 单词</a>
</h3>
<p class="content">我们的第一个问题是为文档中包含的单词生成一个列表。（以几百本书作为这样一个程序的输入，我们就能得到字典中单词列表的雏形。）但是，什么才是单词呢？我们采用了如下的简单定义：单词是包含在空白中的字符序列，但是这样一来，网页上将包含很多像“&lt;html&gt;”、“&lt;body&gt;”和“&amp;nbsp;”这样的“单词”。习题 1 讨论如何避免这样的问题。</p>
<p class="content">我们的第一个C++程序用到了C++标准模板库中的sets和strings，由答案1.1中的程序稍做修改而得：</p>
<p class="content">int main(void)</p>
<p class="content">{ set &lt;string&gt; S;</p>
<p class="content_4">set &lt;string&gt;::iterator j;</p>
<p class="content_4">string t;</p>
<p class="content_4">while (cin &gt;&gt; t)</p>
<p class="content_5">S.insert(t);</p>
<p class="content_4">for (j = S.begin(); j != S.end(); ++j)</p>
<p class="content_5">cout &lt;&lt; *j &lt;&lt; "\n";</p>
<p class="content_4">return 0;</p>
<p class="content">}</p>
<p class="content">while循环读取输入并将每个单词插入集合S（根据标准模板库规范，忽略重复的单词)，然后for循环迭代整个集合，并按排好的顺序输出单词。该程序编写得非常优雅，也相当高效（马上将详细讨论这一点）。</p>
<p class="content">接下来的问题是对文档中每个单词的出现次数进行统计。下面给出了詹姆斯一世钦定版《圣经》中出现频率最高的 21 个单词，按数值递减的次序排列，并对齐为 3列显示以节省空间：</p>
<p class="content">the　62053　　　　shall 9756　　　　 they　　6890</p>
<p class="content">and　38546　　　　he　　 9506　　　　 be　6672</p>
<p class="content">of　 34375　　　　unto　8929　　　　 is　6595</p>
<p class="content">to　 13352　　　　I　　　8699　　　　 with　　5949</p>
<p class="content">And　12734　　　　his　　8352　　　　 not 5840</p>
<p class="content">that 12428　　　 a　　　7940　　　　 all 5238</p>
<p class="content">in　 12154　　　　for　　7139　　　　 thou　　4629</p>
<p class="content">该书的789 616个单词中大概有8%是单词“the”（而在我们这个句子中，比例为16%）<span id="ref56">
<a href="part0009.xhtml#annot56">[16]</a>
</span>
 。根据我们的单词定义，“and’’和“And”需要分别计数。</p>
<p class="content">上述统计是通过下面的C++程序实现的，该程序使用标准模板库中的map将整数计数与每个字符串联系起来：</p>
<p class="content">int main(void)</p>
<p class="content">{ map &lt;string,int&gt; M;</p>
<p class="content_5">map &lt;string,int&gt;::iterator j;</p>
<p class="content_5">string t;</p>
<p class="content_5">while (cin &gt;&gt; t)</p>
<p class="content_7">M[t]++;</p>
<p class="content_5">for (j = M.begin(); j != M.end(); ++j)</p>
<p class="content_7">cout &lt;&lt; j-&gt;first &lt;&lt; " " &lt;&lt; j-&gt;second &lt;&lt; "\n";</p>
<p class="content_5">return 0;</p>
<p class="content">}</p>
<p class="content">while语句将每个单词t插入映射M，并对相关的计数器（初始化为0）增1。for语句按排好的顺序遍历单词，并打印出每个单词（first）及其计数（second）。</p>
<p class="content">这段C++代码直白、简洁而且运行起来出奇地快。在我的机器上，它处理《圣经》只需要7.6秒，其中读取操作约需要2.4秒，插入操作约需要4.9秒，输出操作约需要0.3秒。</p>
<p class="content">为了减少处理时间，我们可以建立自己的散列表，散列表中的结点包含指向单词的指针、单词出现频率以及指向表中下一个结点的指针。下面给出了插入“in”、“the”和“in”之后的散列表，两个字符串罕见地都散列到了1：</p>
<div class="bodypic_"><img alt="" src="../Images/image00250.jpeg" class="calibre3"/>
</div>
<p class="content">我们用如下的C结构实现散列表：</p>
<p class="content">typedef struct node *nodeptr;</p>
<p class="content">typedef struct node {</p>
<p class="content_5">char *word;</p>
<p class="content_5">int count;</p>
<p class="content_5">nodeptr next;</p>
<p class="content">} node;</p>
<p class="content">即便在我们的宽松“单词”定义下，《圣经》中也只有29 131个不同的单词。我们采用传统的办法，用跟29 131最接近的质数作为散列表的大小，并将乘数定义为31：</p>
<p class="content">#define NHASH 29989</p>
<p class="content">#define MULT 31</p>
<p class="content">nodeptr bin[NHASH];</p>
<p class="content">散列函数把每个字符串映射为一个小于NHASH的正整数：</p>
<p class="content">unsigned int hash(char *p)</p>
<p class="content_5">unsigned int h = 0</p>
<p class="content_5">for ( ; *p; p++)</p>
<p class="content_7">h = MULT * h + *p</p>
<p class="content_5">return h % NHASH</p>
<p class="content">其中使用无符号整数以确保h为正。</p>
<p class="content">下面的main函数首先把每个箱都初始化为NULL，接着读取单词并增加计数值，然后迭代散列表输出（未排序的）单词和计数值：</p>
<p class="content">int main(void)</p>
<p class="content_5">for i = [0,NHASH)</p>
<p class="content_7">bin[i] = NULL</p>
<p class="content_5">while scanf("%s",buf) != EOF</p>
<p class="content_7">incword(buf)</p>
<p class="content_5">for i = [0,NHASH)</p>
<p class="content_7">for (p = bin[i]; p != NULL; p = p-&gt;next)</p>
<p class="content_8">print p-&gt;word,p-&gt;count</p>
<p class="content_5">return 0</p>
<p class="content">主要工作由incword完成，它负责增加与输入单词相关联的计数器的值（如果以前没有这个单词，就对计数器进行初始化）：</p>
<p class="content">void incword(char *s)</p>
<p class="content_5">h = hash(s)</p>
<p class="content_5">for (p = bin[h]; p != NULL; p = p-&gt;next)</p>
<p class="content_7">if strcmp(s,p-&gt;word) == 0</p>
<p class="content_8">(p-&gt;count)++</p>
<p class="content_8">return</p>
<p class="content_5">p = malloc(sizeof(hashnode))</p>
<p class="content_5">p-&gt;count = 1</p>
<p class="content_5">p-&gt;word = malloc(strlen(s)+1)</p>
<p class="content_5">strcpy(p-&gt;word,s)</p>
<p class="content_5">p-&gt;next = bin[h]</p>
<p class="content_5">bin[h] = p</p>
<p class="content">incword 函数中的 for 循环查看具有相同散列值的每个结点。如果发现了该单词，就将其计数值增加1并返回；否则，函数创建一个新结点，为其分配空间并复制字符串（有经验的 C 程序员会使用 strdup 来完成该任务），然后将新结点插入到链表的最前面。</p>
<p class="content">这个C程序读取操作约需要2.4秒（跟C++版本一样），但是插入操作只需要0.5秒（C++版本需要4.9秒），输出操作只需要0.06秒（C++版本需要0.3秒）。因此总的运行时间是3.0秒（以前是7.6秒），其中处理时间是0.56秒<span id="ref57">
<a href="part0009.xhtml#annot57">[17]</a>
</span>
 （以前要5.2秒）。我们（用30行的C代码）定制的散列表比C++标准模板库中的映射快一个数量级。</p>
<p class="content">前面我们通过实例介绍了表示单词集合的两种主要方法。平衡搜索树将字符串看作不可分割的对象进行操作，标准模板库的set和map中大部分实现都使用这种结构。平衡搜索树中的元素始终处于有序状态，从而很容易执行寻找前驱结点或者按顺序输出元素之类的操作。另一方面，散列则需要深入字符串的内部，计算散列函数并将关键字分散到一个较大的表中。散列方法的平均速度很快，但缺乏平衡树提供的最坏情况性能保证，也不能支持其他涉及顺序的操作。</p>
<h3 class="thirdtitle" id="bw119">
<a href="part0000.xhtml#toc129">15.2 短语</a>
</h3>
<p class="content">单词是文档的基本组成部分，许多重要的问题可以通过搜索单词得到解决。但是，有时我们也需要在长字符串（文档、帮助文件、网页乃至整个网站）中搜索“substring searching”、“implicit data structures”之类的短语。</p>
<p class="content">如何在一个很大的文本中搜索“几个单词组成的短语”呢？如果之前没看过该文本，我们别无选择，只能从头开始扫描整个文本内容。大部分算法教材都描述了许多解决此类“子串搜索问题”的方法。</p>
<p class="content">假定我们可以在执行搜索之前对文本内容进行预处理，那么我们可以建立一个散列表（或者搜索树），为文档中的每个不同的单词建立索引，并为每个单词的每次出现存储一个链表。这样的“逆向索引”使得程序可以很快地找到给定的单词。为了查找短语，我们可以对其中包含的每个单词的链表进行交叉，但是实现起来比较复杂，速度可能会很慢。（不过一些网页搜索引擎用的就是这种方法。）</p>
<p class="content">下面我们介绍一种强大的数据结构，并将其应用到一个小问题上：给定一个文本文件作为输入，查找其中最长的重复子字符串。例如，“Ask not what your country can do for you,but what you can do for your country”中最长的重复字符串是“can do for you”，第二长的是“your country”。如何编写解决这个问题的程序呢？</p>
<p class="content">这个问题使我们想起了2.4节的变位词程序。如果输入字符串存储在c[0..n-1]中，那么我们可能会使用类似下面的伪代码比较每对子串：</p>
<p class="content">maxlen = -1</p>
<p class="content">for i = [0,n)</p>
<p class="content">for j = (i,n)</p>
<p class="content_5">if (thislen = comlen(&amp;c[i],&amp;c[j])) &gt; maxlen</p>
<p class="content_7">maxlen = thislen</p>
<p class="content_7">maxi = i</p>
<p class="content_7">maxj = j</p>
<p class="content">comlen函数返回其两个参数字符串中共同部分的长度，从第一个字符开始比较：</p>
<p class="content">int comlen(char *p,char *q)</p>
<p class="content_5">i = 0</p>
<p class="content_5">while *p &amp;&amp; (*p++ == *q++)</p>
<p class="content_7">i++</p>
<p class="content_5">return i</p>
<p class="content">由于该算法查看所有的字符串对，因此所需的最少时间是n<span class="super">2</span>
 的倍数。可以用散列表搜索短语中的单词来实现提速，但这里我们打算采用一种全新的方法。</p>
<p class="content">我们的程序最多处理MAXN个字符，这些字符存储在数组c中：</p>
<p class="content">#define MAXN 5000000</p>
<p class="content">char c[MAXN],*a[MAXN];</p>
<p class="content">我们将使用一个称为“后缀数组”的简单数据结构。尽管该术语在20世纪90年代才提出，但70 年代人们就开始使用该结构了。这个结构是一个字符指针数组，记为a。读取输入时，我们对a进行初始化，使得每个元素指向输入字符串中的相应字符：</p>
<p class="content">while (ch = getchar()) != EOF</p>
<p class="content_5">a[n] = &amp;c[n]</p>
<p class="content_5">c[n++] = ch</p>
<p class="content">c[n] = 0;</p>
<p class="content">c的最后一个元素是空字符，空字符是所有字符串结束的标志。</p>
<p class="content">元素a[0]指向整个字符串，下一个元素指向从第二个字符开始的数组后缀，依此类推。对于输入字符串“banana”，该数组能够表示下面这些后缀：</p>
<p class="content">a[0]: banana</p>
<p class="content">a[1]: anana</p>
<p class="content">a[2]: nana</p>
<p class="content">a[3]: ana</p>
<p class="content">a[4]: na</p>
<p class="content">a[5]: a</p>
<p class="content">数组a中指针所指的对象包含了字符串的每一个后缀，因此称a为“后缀数组”。</p>
<p class="content">如果某个长字符串在数组c中出现两次，那么它将出现在两个不同的后缀中，因此我们对数组排序以寻找相同的后缀（就像在2.4节用排序寻找变位词一样）。“banana”数组排序为：</p>
<p class="content">a[0]: a</p>
<p class="content">a[1]: ana</p>
<p class="content">a[2]: anana</p>
<p class="content">a[3]: banana</p>
<p class="content">a[4]: na</p>
<p class="content">a[5]: nana</p>
<p class="content">然后我们就可以扫描数组，通过比较相邻元素来找出最长的重复字符串，本例为“ana”。</p>
<p class="content">可以使用qsort函数对后缀数组进行排序：</p>
<p class="content">qsort(a,n,sizeof(char *),pstrcmp)</p>
<p class="content">其中比较函数pstrcmp实际上是对strcmp库函数的一层间接调用。扫描数组时，使用comlen函数统计两个相邻单词共有的字母数：</p>
<p class="content">for i = [0,n)</p>
<p class="content_5">if comlen(a[i],a[i+1]) &gt; maxlen</p>
<p class="content_7">maxlen = comlen(a[i],a[i+1])</p>
<p class="content_7">maxi = i</p>
<p class="content">printf("%.*s\n",maxlen,a[maxi])</p>
<p class="content">printf语句使用“*”精度输出字符串中的maxlen个字符。</p>
<p class="content">运行我们的程序，在Samuel Butler翻译的《荷马史诗》一书的807 503个字符中寻找最长的重复字符串。程序需要4.8秒来定位该字符串：</p>
<p class="content">whose sake so many of the Achaeans have died at Troy,far from their homes? Go about at once among the host,and speak fairly to them,man by man,that they draw not their ships into the sea.</p>
<p class="content">这段文字第一次出现在Juno（朱诺）建议Minerva（密涅瓦）阻止希腊人（Achaean）离开特洛伊的时候，不久它又在Minerva将这段话一字不差地重复给Ulysses（尤里西斯）听的时候出现了。在这种具有n个字符的常见文本文件上，由于排序的存在，算法需要O(n log n)的运行时间。</p>
<p class="content">对于n个字符的输入文本，后缀数组使用文本自身和额外的n个指针来表示每个子串。习题6研究了如何用后缀数组解决子串搜索问题，下面我们来看看后缀数组的一个更复杂的应用。</p>
<h3 class="thirdtitle" id="bw120">
<a href="part0000.xhtml#toc130">15.3 生成文本</a>
</h3>
<p class="content">如何生成随机文本？一种比较经典的方法是让一只可怜的猴子在旧打字机上敲击。如果猴子敲击任何一个小写字母或空格键的概率是一样的，那么输出可能像下面这样：</p>
<p class="content">uzlpcbizdmddk njsdzyyvfgxbgjjgbtsak rqvpgnsbyputvqqdtmgltz ynqotqigex jumqphu jcfwn ll jiexpyqzgsdllgcoluphl sefsrvqqytjakmav bfusvirsjl wprwqt</p>
<p class="content">这显然不是英文文本。</p>
<p class="content">如果统计一下单词游戏（如Scrabble<span class="super">TM</span>
 或Boggle<span class="super">TM</span>
 ）中的字母数，我们会发现不同字母的出现次数是不一样的，例如A比Z多得多。通过统计文档中的字母数，猴子可以打出更像英文的文本——如果A在文本中出现了300次而B只出现了100次，那么猴子输入A的概率就是输入B的3倍。这样我们就离英文近了一小步：</p>
<p class="content">saade ve mw hc n entt da k eethetocusosselalwo gx fgrsnoh,tvettaf aetnlbilo fc lhd okleutsndyeosht- bogo eet ib nheaoopefni ngent</p>
<p class="content">多数事件发生在上下文中。假定我们要随机生成一年的华氏温度数据，0～100范围内的365个随机整数序列无法欺骗一般的观察者。我们可以通过把今天的温度设置为昨天温度的（随机）函数来得到更可信的结果：如果今天是85℃，那么明天不太可能是15℃。</p>
<p class="content">对于英文单词也是这样：如果当前字母是Q，那么下一个字母是U的可能性很大。通过把每个字母设置为其前一个字母的随机函数，生成器可以得到更令人感兴趣的文本。因此，我们可以先读取一个样本，统计A之后每个字母出现的次数、B之后每个字母出现的次数，等等。在写随机文本的时候，我们用当前字母的一个随机函数生成下一个字母，下面的“1阶”（Order-1）文本就是用这种方案生成的：</p>
<p class="content">Order-1:t I amy,vin.id wht omanly heay atuss n macon aresethe hired boutwhe t,tl,ad torurest t plur I wit hengamind tarer-plarody thishand.</p>
<p class="content">Order-2:Ther I the heingoind of-pleat,blur it dwere wing waske hat trooss.Yout lar on wassing,an sit." "Yould," "I that vide was nots ther.</p>
<p class="content">Order-3: I has them the saw the secorrow.And wintails on my my ent,thinks,fore voyager lanated the been elsed helder was of him a very free bottlemarkable,Order-4:His heard.""Exactly he very glad trouble,and by Hopkins!That it on of the who difficentralia.He rushed likely?" "Blood night that.</p>
<p class="content">我们可以把这一思想扩展到更长的字母序列上。2 阶文本是通过把每个字母设置为其前面两个字母的函数得到的（一对字母通常称为二连字母）。例如，二连字母TH在英文中后面通常跟A、E、I、O、U和Y，后面跟R和W的可能性小一些，跟其他字母的情况很少。3 阶文本是通过把下一个字母设置为其前面三个字母（三连字母）的函数得到的。而到了4阶文本，大多数单词都是英文单词了，当我们发现它来自《福尔摩斯探案集》中的“格兰其修道院历险记”时可能不会感到惊讶。一位学习过古典文学的读者在阅读本章草稿时评论说，这4段文本使他想起了古代英语到维多利亚英语的演变。</p>
<p class="content">具有数学背景的读者可能会将这个过程视为一个马尔可夫链。每个状态表示一个k 连字母，并且从一个状态到另一个状态的概率是不变的。因此这是一个“具有固定转换概率的有限状态马尔可夫链”。</p>
<p class="content">我们也可以在单词级别上生成随机文本：最笨的方法是随机输出字典中的单词；稍微好一点的方法是读取一个文档，对每个单词计数，然后根据适当的概率选择下一个输出的单词（15.1 节的程序用到了适合这种任务的工具）；如果使用在生成下一个单词时考虑前面几个单词的马尔可夫链，我们可以得到更加令人感兴趣的文本。下面是阅读本书前14章的草稿后所生成的随机文本。</p>
<p class="content">Order-1: The table shows how many contexts; it uses two or equal to the sparse matrices were not chosen.In Section 13.1,for a more efficient that “the more time was published by calling recursive structure translates to build scaffolding to try to know of selected and testing and more robust and a binary search).</p>
<p class="content">Order-2:The program is guided by verification ideas,and the second errs in the STL implementation (which guarantees good worst-case performance),and is especially rich in speedups due to Gordon Bell.Everything should be to use a macro: for n=10,000,its run time; that point Martin picked up from his desk</p>
<p class="content">Order-3:A Quicksort would be quite efficient for the main-memory sorts,and it requires only a few distinct values in this particular problem,we can write them all down in the program,and they were making progress towards a solution at a snail’s pace.</p>
<p class="content">1 阶文本几乎可以大声地读出来；3 阶文本由原始输入中的长短语构成，短语之间的转换是随机的；而2阶文本模拟英文的效果通常是最理想的。</p>
<p class="content">我是在香农1948年的著名的论文“Mathematical Theory of Communication”中第一次看到字母级别和单词级别的英文文本k阶近似的。香农是这样说的：“以构建[字母级别的1阶文本]<span id="ref58">
<a href="part0009.xhtml#annot58">[18]</a>
</span>
 为例，我们随机打开一本书并在该页随机选择一个字母记录下来。然后翻到另一页开始读，直到遇到该字母，此时记录下其后面的那个字母。再翻到另外一页搜索上述第二个字母并记录其后面的那个字母，依此类推。对于[字母级别的1阶、2阶文本和单词级别的0阶、1阶文本]<span id="ref59">
<a href="part0009.xhtml#annot59">[19]</a>
</span>
 ，处理过程是类似的。如果后续的近似都可以构建，那将是非常有趣的，不过工作量也将会非常大。”</p>
<p class="content">可以用程序来自动完成这一艰苦的工作。我们生成k阶马尔可夫链的C程序最多在数组inputchars中存储5 MB的文本：</p>
<p class="content">int k = 2;</p>
<p class="content">char inputchars[5000000];</p>
<p class="content">char *word[1000000];</p>
<p class="content">int nword = 0;</p>
<p class="content">我们可以通过扫描整个输入文本来直接实现香农的算法，从而生成每个单词（不过当文本很大时这样做可能比较慢）。我们实际采用的做法是把数组word作为一种指向字符的后缀数组，不同之处在于它仅从单词的边界开始（常见的修改）。变量nword保存单词的数目。我们用下面的代码读取文件：</p>
<p class="content">word[0] = inputchars</p>
<p class="content">while scanf("%s",word[nword]) != EOF</p>
<p class="content_5">word[nword+1] = word[nword] + strlen(word[nword]) + 1</p>
<p class="content_5">nword++</p>
<p class="content">每个单词都附加到inputchars的后面（不需要分配其他存储空间），并用scanf 提供的</p>
<p class="content">空字符作为结束标志。</p>
<p class="content">读完输入后，我们将对word 数组进行排序，以得到指向同一个k单词序列的所有指针。下列函数完成比较工作：</p>
<p class="content">int wordncmp(char *p,char* q)</p>
<p class="content_5">n = k</p>
<p class="content_5">for ( ; *p == *q; p++,q++)</p>
<p class="content_7">if (*p == 0 &amp;&amp; --n == 0)</p>
<p class="content_8">return 0</p>
<p class="content_7">return *p - *q</p>
<p class="content">该函数在字符相同时持续扫描两个字符串。每次遇到空字符时，它将计数器n减1，并在找到k个相同的单词后返回相同；当遇到不同的字符时，返回差别。</p>
<p class="content">读完输入后，我们先在word 数组后面附加k个空字符（这样比较函数就不会运行到最后），并输出文档的前k个单词（启动随机输出），然后调用排序：</p>
<p class="content">for i = [0,k)</p>
<p class="content_5">word[nword][i] = 0</p>
<p class="content">for i = [0,k)</p>
<p class="content_5">print word[i]</p>
<p class="content">qsort(word,nword,sizeof(word[0]),sortcmp)</p>
<p class="content">像通常一样，sortcmp函数为它的指针参数增加了一层间接调用。</p>
<p class="content">我们的空间高效结构现在包含了大量有关文本中k连单词的信息。如果k为1且输入文本为“of the people,by the people,for the people”，则word数组可能像下面这样：</p>
<p class="content">word[0]: by the</p>
<p class="content">word[1]: for the</p>
<p class="content">word[2]: of the</p>
<p class="content">word[3]: people</p>
<p class="content">word[4]: people,for</p>
<p class="content">word[5]: people,by</p>
<p class="content">word[6]: the people,</p>
<p class="content">word[7]: the people</p>
<p class="content">word[8]: the people,</p>
<p class="content">清晰起见，上面仅给出了数组word中每个元素所指向的前k+1个单词，通常后面还有更多单词。如果要查找“the”后面所跟的单词，就在后缀数组中进行查找，发现有三个选择：两次“people,”，一次“people”。</p>
<p class="content">现在我们可以用下面的伪代码描述来生成无意义的文本：</p>
<p class="content">phrase = first phrase in input array</p>
<p class="content">loop</p>
<p class="content_5">perform a binary search for phrase in word[0..nword-1]</p>
<p class="content_5">for all phrases equal in the first k words</p>
<p class="content_7">select one at random,pointed to by p</p>
<p class="content_5">phrase = word following p</p>
<p class="content_5">if k-th word of phrase is length 0</p>
<p class="content_7">break</p>
<p class="content_5">print k-th word of phrase</p>
<p class="content">我们通过将phrase设置为输入文件中的第一个短语（回忆一下，这些单词已经在输出文件中了）来对循环进行初始化。二分搜索使用9.3节的代码来定位phrase的第一次出现（找到第一次出现非常关键，9.3节的二分搜索实现的正是这个功能）。接下来的for循环扫描所有相同的短语，并使用答案12.10从中随机选择一个。如果该短语的第k个单词长度为0，那么当前短语是文档中的最后一个，因此我们跳出循环。</p>
<p class="content">下面的完整伪代码实现了这些想法，并设置了所生成单词数目的上界：</p>
<p class="content">phrase = inputchars</p>
<p class="content">for (wordsleft = 10000; wordsleft &gt; 0; wordsleft--)</p>
<p class="content_5">l = -1</p>
<p class="content_5">u = nword</p>
<p class="content_5">while l+1 != u</p>
<p class="content_7">m = (l + u) / 2</p>
<p class="content_7">if wordncmp(word[m],phrase) &lt; 0</p>
<p class="content_8">l = m</p>
<p class="content_7">else</p>
<p class="content_8">u = m</p>
<p class="content_5">for (i = 0; wordncmp(phrase,word[u+i]) == 0; i++)</p>
<p class="content_7">if rand() % (i+1) == 0</p>
<p class="content_8">p = word[u+i]</p>
<p class="content_5">phrase = skip(p,1)</p>
<p class="content_5">if strlen(skip(phrase,k-1)) == 0</p>
<p class="content_7">break</p>
<p class="content_5">print skip(phrase,k-1)</p>
<p class="content">Kernighan和Pike的Practice of Programming（5.9节介绍过）一书的第3章专门讨论“设计与实现”这一主题。该章围绕单词级别的马尔可夫文本生成问题进行讨论，因为“它具有一定的代表性：读入一些数据，输出一些数据，处理过程需要一点技巧”。他们介绍了该问题的有趣历史，并使用C、Java、C++、Awk和Perl进行了实现。</p>
<p class="content">本节的程序与他们的C程序性能相当，但代码量是它们的一半。通过用一个指向k 个连续单词的指针来表示短语，可以有效利用空间且实现起来比较方便。当输入规模接近1 MB时，两个程序的速度大致相同。由于Kernighan和Pike使用了较大的结构，并大量使用了效率不高的malloc，因此在我的系统上，本章的程序所需的内存空间要小一个数量级。如果结合答案 14 的加速，并用散列表替代二分搜索和排序，那么本节的程序速度将提高一倍（内存使用增加约50%）。</p>
<h3 class="thirdtitle" id="bw121">
<a href="part0000.xhtml#toc131">15.4 原理</a>
</h3>
<p class="content">字符串问题。编译器如何在符号表中查找变量名？在我们输入查询字符串的每个字符时，帮助系统如何快速地搜索整个CD-ROM？网页搜索引擎如何查找一个短语？解决这些实际问题需要用到本章简单介绍过的一些技巧。</p>
<p class="content">字符串的数据结构。我们已经看到了几种用于表示字符串的最为重要的数据结构。</p>
<p class="content">散列。这一结构的平均速度很快，且易于实现。</p>
<p class="content">平衡树。这些结构在最坏情况下也有较好的性能，C++标准模板库的 set 和map的大部分实现都采用平衡树。</p>
<p class="content">后缀数组。初始化指向文本中每个字符（或每个单词）的指针数组，对其排序就得到一个后缀数组。然后可以遍历该数组以查找接近的字符串，也可以使用二分搜索查找单词或短语。</p>
<p class="content">13.8节使用了其他几种结构来表示字典中的单词。</p>
<p class="content">使用库组件还是使用定制的组件？C++标准模板库中的sets、maps和strings使用起来都很方便，但是它们通用而强大的接口也意味着它们的效率不如专用的散列函数高。另外一些库组件则非常高效：散列使用strcmp，后缀数组使用qsort。我在马尔可夫程序中写二分搜索和wordncmp函数的代码时参考了bsearch和strcmp的库实现。</p>
<h3 class="thirdtitle" id="bw122">
<a href="part0000.xhtml#toc132">15.5 习题</a>
</h3>
<p class="content">1.本章通篇对单词采用如下的简单定义：单词由空白字符隔开。但 HTML 或 RTF等格式的许多实际文档包含格式命令。如何处理这种命令？是否还需要进行其他处理？</p>
<p class="content">2.在内存很大的机器上如何使用C++标准模板库的set或map来解决13.8节的搜索问题？与McIlroy的结构进行比较，它需要多少内存？</p>
<p class="content">3.在15.1节的散列函数中采用答案9.2中的专用malloc，能使速度提升多少？</p>
<p class="content">4.当散列表较大，且散列函数能够均匀分布数据时，表中每个链表的元素都不多。如果这两个条件都满足，那么查找所需的时间就会很多。如果15.1节的散列表中没有找到某个新的字符串，就将它放到链表的最前面。为了模拟散列存在的问题，将NHASH设置为1，并用15.1节的链表策略和其他的链表策略（例如添加到链表的最后面，或者将最近找到的元素放置到链表的最前面）进行实验。</p>
<p class="content">5.在观察15.1节词频程序的输出时，将单词按频率递减的顺序输出是最合适的。如何修改 C 和C++程序以完成这一任务？如何仅输出M 个最常见的单词（其中 M是常数，例如10或者1000）？</p>
<p class="content">6.给定一个新的输入字符串，如何搜索后缀数组，以找到所存储文本中的最长匹配？如何建立一个图形用户界面来完成该任务？</p>
<p class="content">7.我们的程序对于“常见”的输入能够快速找到重复的字符串，但是在某些输入下速度很慢（超过平方复杂度）。计算这类输入下程序运行的时间。实际应用中曾出现过这类输入吗？</p>
<p class="content">8.如何修改查找重复字符串的程序，以找出出现超过M次的最长的字符串？</p>
<p class="content">9.给定两个输入文本，找出它们共有的最长字符串。</p>
<p class="content">10.说明在查找重复字符串的程序中，如何通过仅指向从单词边界开始的后缀来减少指针的数目。这对程序的输出有何影响？</p>
<p class="content">11.实现一个程序，生成字母级别的马尔可夫文本。</p>
<p class="content">12.如何使用15.1节中的工具和方法生成（零阶或非马尔可夫）随机文本？</p>
<p class="content">13.本书网站上提供了生成单词级别的马尔可夫文本的程序，用自己的一些文档测试该程序。</p>
<p class="content">14.如何使用散列对马尔可夫程序提速？</p>
<p class="content">15.15.3节中对香农的引用描述了他用来构建马尔可夫文本的算法，编写程序实现该算法。它给出了马尔可夫频率的很好的近似，但不是精确的形式。解释为什么不是精确的形式。编写程序从头开始扫描整个字符串（从而可以使用真实的频率）以生成每个单词。</p>
<p class="content">16.如何使用本章的方法形成字典的单词列表（这是13.8节中Doug McIlroy面临的问题）？如何在不使用字典的前提下建立拼写检查器？如何在不使用语法规则的前提下建立语法检查器？</p>
<p class="content">17.研究一下在语音识别和数据压缩等应用中，与k连字母分析有关的方法是如何使用的。</p>
<h3 class="thirdtitle" id="bw123">
<a href="part0000.xhtml#toc133">15.6 深入阅读</a>
</h3>
<p class="content">8.8节引用的很多书都有表示和处理字符串的有效算法和数据结构的内容。</p>
<hr class="calibre2"/>
<p class="noindent" id="annot41">
<a href="part0009.xhtml#ref41">[1].</a>
 C.A.R.Hoare（1934—），著名计算机科学家，1980年图灵奖得主。现为微软剑桥研究院高级研究员。1960年提出Quicksort，后开发了用于程序验证的Hoare逻辑。——编者注</p>
<p class="noindent" id="annot42">
<a href="part0009.xhtml#ref42">[2].</a>
 下一节将讨论更常见的双向划分的快速排序。虽然其基本思想非常简单，但实现细节上很需要技巧——我曾花两天的时间跟踪一个错误，结果却发现该错误隐藏在一个很短的划分循环内。看过本章草稿的一位读者认为，标准的方法实际上比Lomuto的方法简单，并马上写出一些代码来证明他的观点，我在他的代码中发现两个错误后就不再继续看了。</p>
<p class="noindent" id="annot43">
<a href="part0009.xhtml#ref43">[3].</a>
 很容易忽略这一步并使用参数(l,m)和(m+1,u)进行递归。不幸的是，当t是子数组中严格最大的元素时，这会导致死循环。验证终止条件的时候会发现这个问题，不过读者大概能猜到我实际上是如何发现该问题的。Miriam Jacob给出了一个优雅的不正确性证明：由于从来不移动x[l]，因此只有当数组中的最小元素为x[0]时该排序才是正确的。</p>
<p class="noindent" id="annot44">
<a href="part0009.xhtml#ref44">[4].</a>
 实际的程序产生范围1～n内的m个整数；本章为了与其他各章的范围保持一致，将范围改为从0开始，这样就能够使用本章的程序生成C数组的随机样本。程序员从0开始计数，而民意调查人员从1开始。</p>
<p class="noindent" id="annot45">
<a href="part0009.xhtml#ref45">[5].</a>
 该书第3版英文影印版先后由清华大学出版社和机械工业出版社出版，中文书名为《计算机程序设计艺术 第2卷 半数值算法》，中译版由国防工业出版社出版，中文书名为《计算机程序设计艺术 第2卷 半数值算法》。——编者注</p>
<p class="noindent" id="annot46">
<a href="part0009.xhtml#ref46">[6].</a>
 该书第57页概述了Arthur Koestler对3种创新性的看法：ah!表示原创性，aha!（啊哈！）表示新发现，西点军校这个学生的解决方案属于haha!——用低技术含量的答案来解决高技术含量的问题是很有趣的。</p>
<p class="noindent" id="annot47">
<a href="part0009.xhtml#ref47">[7].</a>
 第13章中的说法是1 600 000。——审校者注</p>
<p class="noindent" id="annot48">
<a href="part0009.xhtml#ref48">[8].</a>
 Robert W.Floyd（1936—2001），著名计算机科学家，1978年图灵奖得主。他设计了Floyd算法，并开创了使用逻辑断言进行程序验证的领域。他与Knuth紧密合作，是The Art of Computer Programming的主要审稿人，也是书中引用次数最多的人。——编者注</p>
<p class="noindent" id="annot49">
<a href="part0009.xhtml#ref49">[9].</a>
 习题6描述了一个根据编程风格评分的课堂练习。大部分学生都提交了一页的解决方案，因此都得到了中等的成绩。有两个学生前一个暑假刚参加过一个大型的软件开发项目，他们提交了长达5页的美观程序，程序由十多个函数组成，每个函数都有详细的标题。我给了他俩不及格：最好的程序只有5行代码，膨胀了60倍的代码当然不能及格。当这两个学生向我抱怨说他们使用了标准的软件工程工具时，我引用了Pamela Zave的名言：“软件工程的目的是控制复杂度，而不是增加复杂度。”他们只要多花几分钟的时间来寻求简单的程序，就能节省好几个小时的时间。</p>
<p class="noindent" id="annot50">
<a href="part0009.xhtml#ref50">[10].</a>
 我写的第一个版本的中序遍历有一个奇怪的问题：编译器报告内部不一致然后就死掉了，而关闭优化选项后这个问题就没有了，因此当时我认为是编译器的问题。后来我发现了问题所在：我在快速编写遍历代码时，忘记加上对p进行是否为空的if 测试了。优化器试图将尾递归转化为循环，如果找不到终止循环的测试就会死掉。</p>
<p class="noindent" id="annot51">
<a href="part0009.xhtml#ref51">[11].</a>
 与第12章的说法1 700 000不一致，不过这不影响理解。——译者注</p>
<p class="noindent" id="annot52">
<a href="part0009.xhtml#ref52">[12].</a>
 在其他一些场合中，“堆”是指能够分配可变大小的结点的一段较大的内存。本章不考虑这层意义。</p>
<p class="noindent" id="annot53">
<a href="part0009.xhtml#ref53">[13].</a>
 循环不变式中没有说明这个重要的性质。Don Knuth发现，为了更加精确，应该将不变式加强为“如果i没有父结点，那么heap(1,n)为真；否则，如果x[i]被x[p]替换（其中p是i的父结点），那么heap(1,n)也为真”。稍后的siftdown循环也有类似的结论。</p>
<p class="noindent" id="annot54">
<a href="part0009.xhtml#ref54">[14].</a>
 由于可包含同一元素的多个副本，“多集”或“包”的叫法可能更精确。并运算符定义为{2,3} {2}={2,2,3}。</p>
<p class="noindent" id="annot55">
<a href="part0009.xhtml#ref55">[15].</a>
 也就是说，假设1号种子必胜2号种子，2号种子必胜3号种子，依此类推。——译者注</p>
<p class="noindent" id="annot56">
<a href="part0009.xhtml#ref56">[16].</a>
 原文为“Almost eight percent of the 789 616 words in the text were the word “the” (as opposed to 16 percent of the words in this sentence)”，其中共25个单词，不算带引号的“the”，普通的the出现4次。——译者注</p>
<p class="noindent" id="annot57">
<a href="part0009.xhtml#ref57">[17].</a>
 原书为0.55秒，有误。——译者注</p>
<p class="noindent" id="annot58">
<a href="part0009.xhtml#ref58">[18].</a>
 香农原著为“second-order approximation”。——译者注</p>
<p class="noindent" id="annot59">
<a href="part0009.xhtml#ref59">[19].</a>
 香农原著为“third-order approximation,first-order word approximation,and second-order word approximation”。——译者注</p>



  </div>

  <div class="calibreEbNav">
    
      <a href="part0008.xhtml" class="calibreAPrev">上一页
</a>
    

    <a href="../../../kvhzrpvu.html" class="calibreAHome">目录
</a>

    
      <a href="part0010.xhtml" class="calibreANext">下一页
</a>
    
  </div>

</div>

</body>
</html>
